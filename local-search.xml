<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通俗易懂的React原理（九）：commit流程后续</title>
    <link href="/2025/10/03/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9Acommit%E6%B5%81%E7%A8%8B%E5%90%8E%E7%BB%AD/"/>
    <url>/2025/10/03/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9Acommit%E6%B5%81%E7%A8%8B%E5%90%8E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a> ，并且经过简化，仅保留了关键的逻辑，以便于理解流程</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 前略</span><br>    <span class="hljs-title function_">flushMutationEffects</span>();<br>    <span class="hljs-title function_">flushLayoutEffects</span>();<br>    <span class="hljs-comment">// Skip flushAfterMutationEffects</span><br>    <span class="hljs-title function_">flushSpawnedWork</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上一篇，我们已经看完了<code>flushMutationEffects</code>的逻辑，那么我们就该继续看<code>flushLayoutEffects</code>和<code>flushSpawnedWork</code>的逻辑了。</p><h1 id="flushLayoutEffects"><a href="#flushLayoutEffects" class="headerlink" title="flushLayoutEffects"></a>flushLayoutEffects</h1><p>这一部分的主要目的，就是处理useLayoutEffect的逻辑。</p><p>和mutation阶段一样，layout这部分的核心逻辑在里层的方法里，名为<code>commitLayoutEffectOnFiber</code>。</p><p>也是根据fiber.tag的不同类型，执行不同的逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">finishedRoot</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">current</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">finishedWork</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">committedLanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(<br>        finishedRoot,<br>        finishedWork,<br>        committedLanes,<br>      );<br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-title function_">commitHookLayoutEffects</span>(finishedWork, <span class="hljs-title class_">HookLayout</span> | <span class="hljs-title class_">HookHasEffect</span>);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostHoistable</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(<br>        finishedRoot,<br>        finishedWork,<br>        committedLanes,<br>      );<br><br>      <span class="hljs-comment">// Renderers may schedule work to be done after host components are mounted</span><br>      <span class="hljs-comment">// (eg DOM renderer may schedule auto-focus for inputs and form controls).</span><br>      <span class="hljs-comment">// These effects should only be committed when components are first mounted,</span><br>      <span class="hljs-comment">// aka when there is no current/alternate.</span><br>      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> &amp;&amp; flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-title function_">commitHostMount</span>(finishedWork);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Ref</span>) &#123;<br>        <span class="hljs-title function_">safelyAttachRef</span>(finishedWork, finishedWork.<span class="hljs-property">return</span>);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// Fallthrough</span><br>    <span class="hljs-attr">default</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(<br>        finishedRoot,<br>        finishedWork,<br>        committedLanes,<br>      );<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和mutation阶段的逻辑很相似，layout阶段也是先递归执行子节点的逻辑。<code>recursivelyTraverseLayoutEffects</code>方法会遍历子节点，所有的子节点，如果flags包含layout(Update | Callback | Ref | Visibility)，则直接对子节点执行<code>commitLayoutEffectOnFiber</code>。比mutation阶段简单的多，不需要先递归删除，逻辑清晰了不少。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">parentFiber</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (parentFiber.<span class="hljs-property">subtreeFlags</span> &amp; <span class="hljs-title class_">LayoutMask</span>) &#123;<br>    <span class="hljs-keyword">let</span> child = parentFiber.<span class="hljs-property">child</span>;<br>    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">const</span> current = child.<span class="hljs-property">alternate</span>;<br>      <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(root, current, child, lanes);<br>      child = child.<span class="hljs-property">sibling</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="处理函数组件"><a href="#处理函数组件" class="headerlink" title="处理函数组件"></a>处理函数组件</h2><p>递归处理子节点完毕后，回到对当前节点的处理。如果当前节点是函数组件，并且flags包含Update，那么就要执行useLayoutEffect里面的逻辑（return的逻辑已经在mutation阶段执行）,<code>commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect)</code></p><h2 id="处理host组件"><a href="#处理host组件" class="headerlink" title="处理host组件"></a>处理host组件</h2><p>由于useLayoutEffect只在React组件里才能有，所以host类型的组件是不会有layout阶段的副作用的。在这个阶段，host组件只需要处理一些问题，例如对于autofocus的元素，让它们focus（<code>commitHostMount</code>）。以及将React的ref绑定到dom上。</p><h1 id="flushSpawnedWork"><a href="#flushSpawnedWork" class="headerlink" title="flushSpawnedWork"></a>flushSpawnedWork</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSpawnedWork</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (<br>    pendingEffectsStatus !== <span class="hljs-variable constant_">PENDING_SPAWNED_WORK</span> &amp;&amp;<br>    <span class="hljs-comment">// If a startViewTransition times out, we might flush this earlier than</span><br>    <span class="hljs-comment">// after mutation phase. In that case, we just skip the after mutation phase.</span><br>    pendingEffectsStatus !== <span class="hljs-variable constant_">PENDING_AFTER_MUTATION_PHASE</span><br>  ) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  pendingEffectsStatus = <span class="hljs-variable constant_">NO_PENDING_EFFECTS</span>;<br><br>  <span class="hljs-keyword">const</span> root = pendingEffectsRoot;<br>  <span class="hljs-keyword">const</span> finishedWork = pendingFinishedWork;<br>  <span class="hljs-keyword">const</span> lanes = pendingEffectsLanes;<br>  <span class="hljs-keyword">const</span> didIncludeRenderPhaseUpdate = pendingDidIncludeRenderPhaseUpdate;<br><br>  <span class="hljs-keyword">const</span> passiveSubtreeMask = <span class="hljs-title class_">PassiveMask</span>;<br>  <span class="hljs-keyword">const</span> rootDidHavePassiveEffects = <span class="hljs-comment">// If this subtree rendered with profiling this commit, we need to visit it to log it.</span><br>    (finishedWork.<span class="hljs-property">subtreeFlags</span> &amp; passiveSubtreeMask) !== <span class="hljs-title class_">NoFlags</span> ||<br>    (finishedWork.<span class="hljs-property">flags</span> &amp; passiveSubtreeMask) !== <span class="hljs-title class_">NoFlags</span>;<br><br>  <span class="hljs-keyword">if</span> (rootDidHavePassiveEffects) &#123;<br>    pendingEffectsStatus = <span class="hljs-variable constant_">PENDING_PASSIVE_PHASE</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    pendingEffectsStatus = <span class="hljs-variable constant_">NO_PENDING_EFFECTS</span>;<br>    pendingEffectsRoot = (<span class="hljs-attr">null</span>: <span class="hljs-built_in">any</span>); <span class="hljs-comment">// Clear for GC purposes.</span><br>    pendingFinishedWork = (<span class="hljs-attr">null</span>: <span class="hljs-built_in">any</span>); <span class="hljs-comment">// Clear for GC purposes.</span><br>  &#125;<br><br>  <span class="hljs-comment">// Read this again, since an effect might have updated it</span><br>  <span class="hljs-keyword">let</span> remainingLanes = root.<span class="hljs-property">pendingLanes</span>;<br><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-title function_">includesSyncLane</span>(pendingEffectsLanes) &amp;&amp;<br>    (disableLegacyMode || root.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">LegacyRoot</span>)<br>  ) &#123;<br>    <span class="hljs-title function_">flushPendingEffects</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// Always call this before exiting `commitRoot`, to ensure that any</span><br>  <span class="hljs-comment">// additional work on this root is scheduled.</span><br>  <span class="hljs-title function_">ensureRootIsScheduled</span>(root);<br><br>  <span class="hljs-comment">// Read this again, since a passive effect might have updated it</span><br>  remainingLanes = root.<span class="hljs-property">pendingLanes</span>;<br><br>  <span class="hljs-comment">// Check if this render scheduled a cascading synchronous update. This is a</span><br>  <span class="hljs-comment">// heurstic to detect infinite update loops. We are intentionally excluding</span><br>  <span class="hljs-comment">// hydration lanes in this check, because render triggered by selective</span><br>  <span class="hljs-comment">// hydration is conceptually not an update.</span><br>  <span class="hljs-keyword">if</span> (<br>    (enableInfiniteRenderLoopDetection &amp;&amp;<br>      (didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate)) ||<br>    (<span class="hljs-title function_">includesSomeLane</span>(lanes, <span class="hljs-title class_">UpdateLanes</span>) &amp;&amp;<br>      <span class="hljs-title function_">includesSomeLane</span>(remainingLanes, <span class="hljs-title class_">SyncUpdateLanes</span>))<br>  ) &#123;<br>    <span class="hljs-keyword">if</span> (root === rootWithNestedUpdates) &#123;<br>      nestedUpdateCount++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      nestedUpdateCount = <span class="hljs-number">0</span>;<br>      rootWithNestedUpdates = root;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    nestedUpdateCount = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">flushSyncWorkOnAllRoots</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flushSpawnedWork</code>阶段，主要是处理前面阶段里，派生出来的问题。比如在<code>useLayoutEffect</code>里面如果使用了<code>useState</code>的dispatch，那么这个这个dispatch对应的工作就会在<code>flushSpawnedWork</code>阶段被处理。</p><p>其实去掉了一堆试验阶段的特性和日志后，这部分的逻辑也比较简单。比较重要的一点就是，如果当前有同步优先级的更新（syncLane），那么会立刻同步的执行<code>flushPendingEffects</code>方法。里面会同步的执行<code>flushMutationEffects</code>，<code>flushLayoutEffects</code>和<code>flushPassiveEffects</code>。</p><p>最值得注意的就是会同步执行<code>flushPassiveEffects</code>了。这部分是处理passive effect的，即<code>useEffect</code>里面的内容。通常情况下，<code>useEffect</code>是在commit阶段结束后，下一个宏任务里去执行的，这个在上一篇<code>commitRoot</code>方法的源码里我们能够看到。但是当<code>pendingEffectsLanes</code>包含了同步优先级（在commitRoot里给<code>pendingEffectsLanes</code>赋值），则会改为同步执行。</p><p>值得注意的是，React项目初次渲染，组件mount的时候，优先级是DefaultLane，是低于同步优先级的。所以第一次的useEffect会异步执行。而如果是点击事件触发了状态更新，进而产生了passive effect，那么这次useEffect即passive effect，会同步执行。这对应这个解释<a href="https://github.com/reactwg/react-18/discussions/128">useEffect fires synchronously when it’s the result of a discrete input</a>.</p><p>接下来，React会检测处理副作用时候产生的新的更新，是否有导致无限的循环渲染。</p><p>最后，<code>flushSyncWorkAcrossRoots_impl</code>去把当前root上的所有同步的更新，执行一遍这可能会重新走一遍render的阶段。至于重新渲染一遍的逻辑，在前面已经讲过了，这里不再赘述。</p><h1 id="flushPassiveEffects"><a href="#flushPassiveEffects" class="headerlink" title="flushPassiveEffects"></a>flushPassiveEffects</h1><p><code>commitRoot</code>里面的关键方法还剩<code>flushPassiveEffects</code>没讲。上面提到过，这个是执行<code>useEffect</code>里面的副作用的代码。</p><p>它的主要逻辑在<code>flushPassiveEffectsImpl</code>里，并且可以被简要提炼为下面几行</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushPassiveEffectsImpl</span>(<span class="hljs-params"><span class="hljs-attr">wasDelayedCommit</span>: <span class="hljs-built_in">void</span> | <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-comment">// Cache and clear the transitions flag</span><br>  <span class="hljs-keyword">const</span> transitions = pendingPassiveTransitions;<br>  pendingPassiveTransitions = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">const</span> root = pendingEffectsRoot;<br>  <span class="hljs-keyword">const</span> lanes = pendingEffectsLanes;<br>  pendingEffectsStatus = <span class="hljs-variable constant_">NO_PENDING_EFFECTS</span>;<br>  pendingEffectsRoot = (<span class="hljs-attr">null</span>: <span class="hljs-built_in">any</span>); <span class="hljs-comment">// Clear for GC purposes.</span><br>  pendingFinishedWork = (<span class="hljs-attr">null</span>: <span class="hljs-built_in">any</span>); <span class="hljs-comment">// Clear for GC purposes.</span><br>  pendingEffectsLanes = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-title function_">commitPassiveUnmountEffects</span>(root.<span class="hljs-property">current</span>);<br>  <span class="hljs-title function_">commitPassiveMountEffects</span>(<br>    root,<br>    root.<span class="hljs-property">current</span>,<br>    lanes,<br>    transitions,<br>    pendingEffectsRenderEndTime,<br>  );<br><br>  <span class="hljs-title function_">flushSyncWorkOnAllRoots</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先<code>commitPassiveUnmountEffects</code>，这个前面看了mutation阶段和layout阶段，我们其实都能猜到了，从根节点开始，递归遍历全部子节点，把每个子节点上面的passive effect的return方法都执行一遍，且是先执行子节点的，再行父节点的。</p><p>而<code>commitPassiveMountEffects</code>方法，则是递归遍历所有子节点，把他们的passive effect的内容都执行一遍。</p><p>这样我们其实也能看出来，useEffect的执行顺序，先是把所有Fiber上面的return按先子后父的顺序执行完，然后再按先子后父的顺序把原本的副作用执行一遍。</p><p>最后，再执行<code>flushSyncWorkOnAllRoots</code>方法，把所有的同步任务都清一遍。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是commitRoot阶段，React的主要流程。后续我们会了解一下Scheduler的工作逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（八）：commit流程之flushMutationEffects</title>
    <link href="/2025/09/27/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9Acommit%E6%B5%81%E7%A8%8B%E4%B9%8BflushMutationEffects/"/>
    <url>/2025/09/27/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9Acommit%E6%B5%81%E7%A8%8B%E4%B9%8BflushMutationEffects/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a> ，并且经过简化，仅保留了关键的逻辑，以便于理解流程</p></blockquote><p>前面我们基本讲完了render阶段，也就是React生成新的fiber tree的过程。后面我们就该看commit阶段了，这是根据新的Fiber tree去修改真实dom的过程。</p><p>我们之前说的可中断，也仅仅是针对render阶段的。因为render阶段，只是修改内存中，后缓冲区的那个workInProgress fiber tree。而commit阶段，则是要去修改dom了，为了保证页面上展示的不是半新半老的，commit阶段是不可被打断，同步执行下来的。</p><p>commit阶段的入口，就在<code>performWorkOnRoot</code>里面，当渲染逻辑结束后，如果一次渲染正常结束，会执行<code>finishConcurrentRender</code>方法，进而沿着<code>finishConcurrentRender</code>-&gt;<code>commitRootWhenReady</code>-&gt;<code>commitRoot</code>这个路径，进入到commitRoot的逻辑里。</p><h1 id="commitRoot方法"><a href="#commitRoot方法" class="headerlink" title="commitRoot方法"></a>commitRoot方法</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">finishedWork</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">recoverableErrors</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">CapturedValue</span>&lt;mixed&gt;&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">transitions</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Transition</span>&gt; | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">didIncludeRenderPhaseUpdate</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">spawnedLane</span>: <span class="hljs-title class_">Lane</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">updatedLanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">suspendedRetryLanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">exitStatus</span>: <span class="hljs-title class_">RootExitStatus</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">suspendedCommitReason</span>: <span class="hljs-title class_">SuspendedCommitReason</span>, <span class="hljs-comment">// Profiling-only</span></span><br><span class="hljs-params">  <span class="hljs-attr">completedRenderStartTime</span>: <span class="hljs-built_in">number</span>, <span class="hljs-comment">// Profiling-only</span></span><br><span class="hljs-params">  <span class="hljs-attr">completedRenderEndTime</span>: <span class="hljs-built_in">number</span>, <span class="hljs-comment">// Profiling-only</span></span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which</span><br>    <span class="hljs-comment">// means `flushPassiveEffects` will sometimes result in additional</span><br>    <span class="hljs-comment">// passive effects. So we need to keep flushing in a loop until there are</span><br>    <span class="hljs-comment">// no more pending effects.</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Might be better if `flushPassiveEffects` did not automatically</span><br>    <span class="hljs-comment">// flush synchronous work at the end, to avoid factoring hazards like this.</span><br>    <span class="hljs-title function_">flushPendingEffects</span>();<br>  &#125; <span class="hljs-keyword">while</span> (pendingEffectsStatus !== <span class="hljs-variable constant_">NO_PENDING_EFFECTS</span>);<br>  <span class="hljs-title function_">flushRenderPhaseStrictModeWarningsInDEV</span>();  <span class="hljs-comment">// Check which lanes no longer have any work scheduled on them, and mark</span><br>  <span class="hljs-keyword">let</span> passiveSubtreeMask;<br><br>  passiveSubtreeMask = <span class="hljs-title class_">PassiveMask</span>;<br><br>  <span class="hljs-keyword">if</span> (<br>    (finishedWork.<span class="hljs-property">subtreeFlags</span> &amp; passiveSubtreeMask) !== <span class="hljs-title class_">NoFlags</span> ||<br>    (finishedWork.<span class="hljs-property">flags</span> &amp; passiveSubtreeMask) !== <span class="hljs-title class_">NoFlags</span><br>  ) &#123;<br>      root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>      root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLane</span>;<br>      <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalSchedulerPriority</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">flushPassiveEffects</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// This render triggered passive effects: release the root cache pool</span><br>        <span class="hljs-comment">// *after* passive effects fire to avoid freeing a cache pool that may</span><br>        <span class="hljs-comment">// be referenced by a node in the tree (HostRoot, Cache boundary etc)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If we don&#x27;t have passive effects, we&#x27;re not going to need to perform more work</span><br>    <span class="hljs-comment">// so we can clear the callback now.</span><br>    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;<br>    root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLane</span>;<br>  &#125;<br><br>  pendingEffectsStatus = <span class="hljs-variable constant_">PENDING_MUTATION_PHASE</span>;<br>  <span class="hljs-comment">// Flush synchronously.</span><br>  <span class="hljs-title function_">flushMutationEffects</span>();<br>  <span class="hljs-title function_">flushLayoutEffects</span>();<br>  <span class="hljs-comment">// Skip flushAfterMutationEffects</span><br>  <span class="hljs-title function_">flushSpawnedWork</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>commitRoot的核心代码大致如上所示。其中finishedWork这个参数，后面也会多次出现，对应的是render阶段的workInProgress，都表示当前遍历到，正在处理的那个Fiber节点。</p><p>首先要保证执行下面的代码时，没有pending状态的副作用（注释里写了为什么可能这时会有副作用），所以需要不停地执行<code>flushPendingEffects</code>，里面会把所有类型的副作用都执行一遍。</p><p>然后，如果整个fiber树中有passive类型的副作用（即<code>useEffect</code>产生的副作用），那么会通过Scheduler，注册一个宏任务，在下一个宏任务里执行整棵树上所有的passive类型副作用。</p><p>然后我们跳过了一个beforeMutationEffect的处理，因为这个跟函数组件没什么关系了，所以不是我们关注的重点。</p><p>最后，按顺序处理三个任务：MutationEffect类型的副作用，LayoutEffect类型的副作用，以及处理前面的任务过程中，新出现的任务即SpawnedWork</p><p>其整体流程简要如下图所示，特别将这一节要讲的mutationEffect内容也展开，便于理解</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">commitRoot<br>   ├─ flushPendingEffects<br>   ├─ flushMutationEffects<br>   │    └─ commitMutationEffectsOnFiber<br>   │         ├─ recursivelyTraverseMutationEffects<br>   │         │    └─ commitDeletionEffectsOnFiber<br>   │         ├─ commitReconciliationEffects (Placement)<br>   │         └─ Update (hooks/DOM更新)<br>   ├─ flushLayoutEffects<br>   └─ flushSpawnedWork<br></code></pre></td></tr></table></figure><h1 id="MutationEffect"><a href="#MutationEffect" class="headerlink" title="MutationEffect"></a>MutationEffect</h1><p>mutationEffect，即改变dom的effect。删除dom节点，新增dom节点之类的，都是在这个阶段完成。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushMutationEffects</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (pendingEffectsStatus !== <span class="hljs-variable constant_">PENDING_MUTATION_PHASE</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  pendingEffectsStatus = <span class="hljs-variable constant_">NO_PENDING_EFFECTS</span>;<br><br>  <span class="hljs-keyword">const</span> root = pendingEffectsRoot;<br>  <span class="hljs-keyword">const</span> finishedWork = pendingFinishedWork;<br>  <span class="hljs-keyword">const</span> lanes = pendingEffectsLanes;<br>  <span class="hljs-keyword">const</span> subtreeMutationHasEffects =<br>    (finishedWork.<span class="hljs-property">subtreeFlags</span> &amp; <span class="hljs-title class_">MutationMask</span>) !== <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-keyword">const</span> rootMutationHasEffect = (finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">MutationMask</span>) !== <span class="hljs-title class_">NoFlags</span>;<br><br>  <span class="hljs-keyword">if</span> (subtreeMutationHasEffects || rootMutationHasEffect) &#123;<br>    <span class="hljs-keyword">const</span> prevTransition = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">T</span>;<br>    <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">T</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">const</span> previousPriority = <span class="hljs-title function_">getCurrentUpdatePriority</span>();<br>    <span class="hljs-title function_">setCurrentUpdatePriority</span>(<span class="hljs-title class_">DiscreteEventPriority</span>);<br>    <span class="hljs-keyword">const</span> prevExecutionContext = executionContext;<br>    executionContext |= <span class="hljs-title class_">CommitContext</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// The next phase is the mutation phase, where we mutate the host tree.</span><br>      <span class="hljs-title function_">commitMutationEffects</span>(root, finishedWork, lanes);<br><br>      <span class="hljs-keyword">if</span> (enableCreateEventHandleAPI) &#123;<br>        <span class="hljs-keyword">if</span> (shouldFireAfterActiveInstanceBlur) &#123;<br>          <span class="hljs-title function_">afterActiveInstanceBlur</span>();<br>        &#125;<br>      &#125;<br>      <span class="hljs-title function_">resetAfterCommit</span>(root.<span class="hljs-property">containerInfo</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// Reset the priority to the previous non-sync value.</span><br>      executionContext = prevExecutionContext;<br>      <span class="hljs-title function_">setCurrentUpdatePriority</span>(previousPriority);<br>      <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">T</span> = prevTransition;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// The work-in-progress tree is now the current tree. This must come after</span><br>  <span class="hljs-comment">// the mutation phase, so that the previous tree is still current during</span><br>  <span class="hljs-comment">// componentWillUnmount, but before the layout phase, so that the finished</span><br>  <span class="hljs-comment">// work is current during componentDidMount/Update.</span><br>  root.<span class="hljs-property">current</span> = finishedWork;<br>  pendingEffectsStatus = <span class="hljs-variable constant_">PENDING_LAYOUT_PHASE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面可见，这段代码的核心逻辑是在<code>commitMutationEffects</code>里的。而<code>commitMutationEffects</code>方法里，几乎就是直接执行了<code>commitMutationEffectsOnFiber</code>方法，所以我们只看<code>commitMutationEffectsOnFiber</code>方法就可以了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffectsOnFiber</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">finishedWork</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(root, finishedWork, lanes);<br>      <span class="hljs-title function_">commitReconciliationEffects</span>(finishedWork, lanes);<br><br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-title function_">commitHookEffectListUnmount</span>(<br>          <span class="hljs-title class_">HookInsertion</span> | <span class="hljs-title class_">HookHasEffect</span>,<br>          finishedWork,<br>          finishedWork.<span class="hljs-property">return</span>,<br>        );<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use a commitHookInsertionUnmountEffects wrapper to record timings.</span><br>        <span class="hljs-title function_">commitHookEffectListMount</span>(<span class="hljs-title class_">HookInsertion</span> | <span class="hljs-title class_">HookHasEffect</span>, finishedWork);<br>        <span class="hljs-title function_">commitHookLayoutUnmountEffects</span>(<br>          finishedWork,<br>          finishedWork.<span class="hljs-property">return</span>,<br>          <span class="hljs-title class_">HookLayout</span> | <span class="hljs-title class_">HookHasEffect</span>,<br>        );<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(root, finishedWork, lanes);<br><br>      <span class="hljs-title function_">commitReconciliationEffects</span>(finishedWork, lanes);<br><br>      <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ContentReset</span>) &#123;<br>        <span class="hljs-title function_">commitHostResetTextContent</span>(finishedWork);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">Instance</span> = finishedWork.<span class="hljs-property">stateNode</span>;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// Commit the work prepared earlier.</span><br>          <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span><br>          <span class="hljs-comment">// as the newProps. The updatePayload will contain the real change in</span><br>          <span class="hljs-comment">// this case.</span><br>          <span class="hljs-keyword">const</span> newProps = finishedWork.<span class="hljs-property">memoizedProps</span>;<br>          <span class="hljs-keyword">const</span> oldProps =<br>            current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedProps</span> : newProps;<br>          <span class="hljs-title function_">commitHostUpdate</span>(finishedWork, newProps, oldProps);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(root, finishedWork, lanes);<br>      <span class="hljs-title function_">commitReconciliationEffects</span>(finishedWork, lanes);<br><br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">newText</span>: <span class="hljs-built_in">string</span> = finishedWork.<span class="hljs-property">memoizedProps</span>;<br>        <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span><br>        <span class="hljs-comment">// as the newProps. The updatePayload will contain the real change in</span><br>        <span class="hljs-comment">// this case.</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">oldText</span>: <span class="hljs-built_in">string</span> =<br>          current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedProps</span> : newText;<br><br>        <span class="hljs-title function_">commitHostTextUpdate</span>(finishedWork, newText, oldText);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commitMutationEffectsOnFiber</code>方法里面，主要是根据fiber.tag的不同类型，做不同的操作。我们主要关注三种类型，即<code>FunctionComponent</code>（函数组件），<code>HostComponent</code>（dom的html标签，如<code>&lt;div&gt;</code>之类的对应的fiber node）和<code>HostText</code>（dom里面的文本节点对应的fiber node）</p><h2 id="recursivelyTraverseMutationEffects"><a href="#recursivelyTraverseMutationEffects" class="headerlink" title="recursivelyTraverseMutationEffects"></a>recursivelyTraverseMutationEffects</h2><p>我们可以看到，对于三种类型的节点，首先都要执行<code>recursivelyTraverseMutationEffects</code>方法，而后才是真正的当前节点的处理逻辑。所以我们先看一下<code>recursivelyTraverseMutationEffects</code>方法，都干了什么。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">parentFiber</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Deletions effects can be scheduled on any fiber type. They need to happen</span><br>  <span class="hljs-comment">// before the children effects have fired.</span><br>  <span class="hljs-keyword">const</span> deletions = parentFiber.<span class="hljs-property">deletions</span>;<br>  <span class="hljs-keyword">if</span> (deletions !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; deletions.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> childToDelete = deletions[i];<br>      <span class="hljs-title function_">commitDeletionEffects</span>(root, parentFiber, childToDelete);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<br>    parentFiber.<span class="hljs-property">subtreeFlags</span> &amp;<br>    (enablePersistedModeClonedFlag ? <span class="hljs-title class_">MutationMask</span> | <span class="hljs-title class_">Cloned</span> : <span class="hljs-title class_">MutationMask</span>)<br>  ) &#123;<br>    <span class="hljs-keyword">let</span> child = parentFiber.<span class="hljs-property">child</span>;<br>    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">commitMutationEffectsOnFiber</span>(child, root, lanes);<br>      child = child.<span class="hljs-property">sibling</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顾名思义，这是个递归的辅助方法。不难发现，它最后又会调用<code>commitMutationEffectsOnFiber</code>方法，整体上形成了<code>commitMutationEffectsOnFiber</code> -&gt; <code>recursivelyTraverseMutationEffects</code> -&gt; <code>commitMutationEffectsOnFiber</code>这样的递归逻辑。这个递归的含义，就是先处理子节点，然后处理子节点的兄弟节点，最后再处理自身。</p><p>我们仔细看这个递归的逻辑，是首先找到当前Fiber下，所有需要被删除的子节点，将他们都删除。然后继续对所有子节点的处理</p><h3 id="commitDeletionEffectsOnFiber"><a href="#commitDeletionEffectsOnFiber" class="headerlink" title="commitDeletionEffectsOnFiber"></a>commitDeletionEffectsOnFiber</h3><p><code>commitDeletionEffects</code>里面会调用<code>commitDeletionEffectsOnFiber</code>来完成删除逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletionEffectsOnFiber</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">finishedRoot</span>: <span class="hljs-title class_">FiberRoot</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nearestMountedAncestor</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">deletedFiber</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Delete this Hook once new DevTools ships everywhere. No longer needed.</span><br>  <span class="hljs-title function_">onCommitUnmount</span>(deletedFiber);<br><br>  <span class="hljs-comment">// The cases in this outer switch modify the stack before they traverse</span><br>  <span class="hljs-comment">// into their subtree. There are simpler cases in the inner switch</span><br>  <span class="hljs-comment">// that don&#x27;t modify the stack.</span><br>  <span class="hljs-keyword">switch</span> (deletedFiber.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>: &#123;<br>      <span class="hljs-comment">// We only need to remove the nearest host child. Set the host parent</span><br>      <span class="hljs-comment">// to `null` on the stack to indicate that nested children don&#x27;t</span><br>      <span class="hljs-comment">// need to be removed.</span><br>      <span class="hljs-keyword">const</span> prevHostParent = hostParent;<br>      <span class="hljs-keyword">const</span> prevHostParentIsContainer = hostParentIsContainer;<br>      hostParent = <span class="hljs-literal">null</span>;<br>      <span class="hljs-title function_">recursivelyTraverseDeletionEffects</span>(<br>        finishedRoot,<br>        nearestMountedAncestor,<br>        deletedFiber,<br>      );<br>      hostParent = prevHostParent;<br>      hostParentIsContainer = prevHostParentIsContainer;<br>      <span class="hljs-keyword">if</span> (hostParent !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Now that all the child effects have unmounted, we can remove the</span><br>        <span class="hljs-comment">// node from the tree.</span><br>        <span class="hljs-title function_">commitHostRemoveChild</span>(<br>          deletedFiber,<br>          nearestMountedAncestor,<br>          ((<span class="hljs-attr">hostParent</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Instance</span>),<br>          (deletedFiber.<span class="hljs-property">stateNode</span>: <span class="hljs-title class_">Instance</span> | <span class="hljs-title class_">TextInstance</span>),<br>         );<br>      &#125;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>: &#123;<br>      <span class="hljs-title function_">commitHookEffectListUnmount</span>(<br>          <span class="hljs-title class_">HookInsertion</span>,<br>          deletedFiber,<br>          nearestMountedAncestor,<br>      );<br>  <span class="hljs-title function_">commitHookLayoutUnmountEffects</span>(<br>          deletedFiber,<br>          nearestMountedAncestor,<br>          <span class="hljs-title class_">HookLayout</span>,<br>      );<br>      <span class="hljs-title function_">recursivelyTraverseDeletionEffects</span>(<br>        finishedRoot,<br>        nearestMountedAncestor,<br>        deletedFiber,<br>      );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-attr">default</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseDeletionEffects</span>(<br>        finishedRoot,<br>        nearestMountedAncestor,<br>        deletedFiber,<br>      );<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧是根据Fiber的不同tag类型，执行不同的逻辑。这里<code>HostComponent</code>，<code>HostText</code>执行的逻辑基本是一致的。</p><p><code>recursivelyTraverseDeletionEffects</code>其实又是一个递归逻辑，就是对Fiber的所有子节点，都执行一遍<code>commitDeletionEffects</code>，我们就不展开去看了。</p><p>当子节点的删除逻辑执行完之后，会执行<code>commitHostRemoveChild</code>方法，把自己对应的dom删除掉，最终的实现是dom的removeChild方法。</p><p>而对于函数组件，则要先处理一下卸载自身时候的hooks的return方法，然后再去删除所有子组件。所以这里我们也可以知道组件卸载的时候，这些hooks的执行顺序，是先父组件，然后再子组件。</p><p>其中<code>commitHookEffectListUnmount</code>入参指定了effect的flag是<code>HookInsertion</code>，处理<code>useInsertionEffect</code>的return方法。这个hooks是针对<code>css in js</code>库的开发者提供的方法，我们不做过多关心。</p><p>然后<code>commitHookLayoutUnmountEffects</code>，根据入参我们可以看到，是对删除的Fiber节点处理<code>HookLayout</code>类型的effect，对应的就是<code>useLayoutEffect</code>的return方法。</p><p>接下来就去递归删除子节点，删除子节点最终会终结在叶子结点，一定是host类型的Fiber上，也就是前面提到的<code>HostComponent</code>和<code>HostText</code>，最终会实际删除真正的dom节点。</p><h2 id="执行删除以外的mutation"><a href="#执行删除以外的mutation" class="headerlink" title="执行删除以外的mutation"></a>执行删除以外的mutation</h2><p>看完了<code>recursivelyTraverseMutationEffects</code>的逻辑，我们继续回来看<code>commitMutationEffectsOnFiber</code>的逻辑。</p><p>在递归处理完子节点后，回来处理当前Fiber，需要执行<code>commitReconciliationEffects</code>方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitReconciliationEffects</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">finishedWork</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">committedLanes</span>: <span class="hljs-title class_">Lanes</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Placement effects (insertions, reorders) can be scheduled on any fiber</span><br>  <span class="hljs-comment">// type. They needs to happen after the children effects have fired, but</span><br>  <span class="hljs-comment">// before the effects on this fiber have fired.</span><br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br>  <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Placement</span>) &#123;<br>    <span class="hljs-title function_">commitHostPlacement</span>(finishedWork);<br>    finishedWork.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Placement</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Hydrating</span>) &#123;<br>    finishedWork.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Hydrating</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前Fiber的flags包含了<code>Placement</code>（前几篇讲的diff流程中打上的标记，包含了新增和重排序，统一处理为插入），那么就执行<code>commitHostPlacement</code>方法来执行插入，插入后去掉<code>Placement</code>标记。</p><p>关于<code>commitHostPlacement</code>里面插入的逻辑，首先需要找到插入到哪里。从当前Fiber的父节点开始向上寻找，找到第一个是host类型的Fiber，记为<code>hostParentFiber</code>。我们只看<code>hostParentFiber.tag</code>是<code>HostComponent</code>的场景。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Instance</span> = hostParentFiber.<span class="hljs-property">stateNode</span>;<br><span class="hljs-keyword">if</span> (hostParentFiber.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ContentReset</span>) &#123;<br>  <span class="hljs-comment">// Reset the text content of the parent before doing any insertions</span><br>  <span class="hljs-title function_">resetTextContent</span>(parent);<br>  <span class="hljs-comment">// Clear ContentReset from the effect tag</span><br>  hostParentFiber.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">ContentReset</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> before = <span class="hljs-title function_">getHostSibling</span>(finishedWork);<br><span class="hljs-comment">// We only have the top Fiber that was inserted but we need to recurse down its</span><br><span class="hljs-comment">// children to find all the terminal nodes.</span><br><span class="hljs-title function_">insertOrAppendPlacementNode</span>(<br>  finishedWork,<br>  before,<br>  parent,<br>  parentFragmentInstances,<br>);<br></code></pre></td></tr></table></figure><p>找到<code>HostComponent</code>对应的实际dom，如果flags包含<code>ContentReset</code>，则清空里面的文本节点内容。react-dom通过这个方法区更改dom的文本</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setTextContent</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">Element</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (text) &#123;<br>    <span class="hljs-keyword">const</span> firstChild = node.<span class="hljs-property">firstChild</span>;<br><br>    <span class="hljs-keyword">if</span> (<br>      firstChild &amp;&amp;<br>      firstChild === node.<span class="hljs-property">lastChild</span> &amp;&amp;<br>      firstChild.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span><br>    ) &#123;<br>      firstChild.<span class="hljs-property">nodeValue</span> = text;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  node.<span class="hljs-property">textContent</span> = text;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了可能要清空里面的文本，还要真的执行插入逻辑。通过<code>getHostSibling</code>方法，找到应该插入到哪个节点后面。<code>getHostSibling</code>的逻辑比较长，简要概括就是要找自己在最终dom树上的sibling。</p><p>因为Fiber tree和dom tree上的节点并不是一一对应的，fiber tree上的sibling如果不是host类型的节点，最终就不会体现在dom上。所以<code>getHostSibling</code>的逻辑考虑了很多情况，但是简要概括就是根据fiber tree的结构，去找sibling，如果他不是host类型就继续找，可能还会去找叔叔节点的子节点，因为最终dom tree上他们可能是相邻的。并且找到的这个节点自身还不能有<code>Placement</code>标记，因为有这个标记说明它在dom tree中的位置也是不可靠的，它也在等待被插入，不能把它当做锚点来插入。。一定要找到没有发生变化的节点。最终找到的节点被记作<code>before</code>，如果不存在这样一个节点，那么before就是undefined。</p><p>找到后，<code>insertOrAppendPlacementNode</code>方法会把当前Fiber插入到<code>before</code>前面。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertOrAppendPlacementNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">node</span>: <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">before</span>: ?<span class="hljs-title class_">Instance</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Instance</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">parentFragmentInstances</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">FragmentInstanceType</span>&gt;,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123;tag&#125; = node;<br>  <span class="hljs-keyword">const</span> isHost = tag === <span class="hljs-title class_">HostComponent</span> || tag === <span class="hljs-title class_">HostText</span>;<br>  <span class="hljs-keyword">if</span> (isHost) &#123;<br>    <span class="hljs-keyword">const</span> stateNode = node.<span class="hljs-property">stateNode</span>;<br>    <span class="hljs-keyword">if</span> (before) &#123;<br>      <span class="hljs-title function_">insertBefore</span>(parent, stateNode, before);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">appendChild</span>(parent, stateNode);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <br><br>  <span class="hljs-keyword">const</span> child = node.<span class="hljs-property">child</span>;<br>  <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">insertOrAppendPlacementNode</span>(child, before, parent, parentFragmentInstances);<br>    <span class="hljs-keyword">let</span> sibling = child.<span class="hljs-property">sibling</span>;<br>    <span class="hljs-keyword">while</span> (sibling !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">insertOrAppendPlacementNode</span>(<br>        sibling,<br>        before,<br>        parent,<br>        parentFragmentInstances,<br>      );<br>      sibling = sibling.<span class="hljs-property">sibling</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果待插入的Fiber是host类型的，那么只要看上半的逻辑就好了。如果存在before节点，那么就通过dom的<code>insertBefore</code>API完成插入。如果before节点不存在，那么就通过dom的<code>appendChild</code>API，完成插入。</p><p>如果待插入的Fiber不是host类型的，也就是说它本身不对应实际的dom节点，那么就对他自身不做任何处理，而是去递归处理他的子节点，直到找到了host类型的节点，再将子节点们按上半部分的逻辑完成插入。</p><p>这就是<code>commitReconciliationEffects</code>方法的逻辑，里面处理了Fiber节点的插入的逻辑</p><p>目前我们已经看完了节点删除，和节点插入的逻辑。接下来会继续看<code>commitMutationEffectsOnFiber</code>的逻辑</p><h2 id="处理完删除和插入后"><a href="#处理完删除和插入后" class="headerlink" title="处理完删除和插入后"></a>处理完删除和插入后</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>对于函数组件，我们可以看到还需要执行以下代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>  <span class="hljs-title function_">commitHookEffectListUnmount</span>(<br>    <span class="hljs-title class_">HookInsertion</span> | <span class="hljs-title class_">HookHasEffect</span>,<br>    finishedWork,<br>    finishedWork.<span class="hljs-property">return</span>,<br>  );<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Use a commitHookInsertionUnmountEffects wrapper to record timings.</span><br>  <span class="hljs-title function_">commitHookEffectListMount</span>(<span class="hljs-title class_">HookInsertion</span> | <span class="hljs-title class_">HookHasEffect</span>, finishedWork);<br>  <span class="hljs-title function_">commitHookLayoutUnmountEffects</span>(<br>    finishedWork,<br>    finishedWork.<span class="hljs-property">return</span>,<br>    <span class="hljs-title class_">HookLayout</span> | <span class="hljs-title class_">HookHasEffect</span>,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个Fiber的flags包含Update，那么说明这个组件进行了重新渲染，需要重新执行它里面的hooks。注意前面删除节点的时候，我们已经执行了删除节点的<code>useInsertionEffect</code>和<code>useLayoutEffect</code>hooks的return方法。这里更新节点的时候，要先执行<code>useInsertionEffect</code>hooks的return方法。</p><p>这里值得注意的是，更新流程和删除流程，父子节点，执行hooks的return方法的顺序是反过来的，更新流程里优先执行子节点的。</p><p>执行完return方法，会立刻执行下一轮次的<code>useInsertionEffect</code>的副作用，并且执行上一轮和<code>useLayoutEffect</code>的return方法。</p><h3 id="HostComponent和HostText"><a href="#HostComponent和HostText" class="headerlink" title="HostComponent和HostText"></a>HostComponent和HostText</h3><p>对于<code>HostText</code>，逻辑更简单一点。执行<code>commitHostTextUpdate</code>方法，替换里面的文本，实际就是直接替换文本节点里面的<code>nodeValue</code>，更新为新的字符串。</p><p>对于<code>HostComponent</code>，则是更新这个dom上面的各种字段，例如name, value, defaultValue之类的。详见<code>updateProperties</code>方法</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是<code>commitMutationEffectsOnFiber</code>的逻辑，也是commit阶段，处理mutation阶段的逻辑。</p><p>下面几篇，我们会继续了解commitRoot余下的逻辑，包括处理layoutEffect，和spawnedWork，以及处理passiveEffect</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（六）：一次状态更新如何触发渲染</title>
    <link href="/2025/09/04/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93/"/>
    <url>/2025/09/04/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a></p></blockquote><p>在本系列第二篇文章中，我们介绍了React是如何在一次渲染中，构建Fiber tree的。只不过我们当时是直接从<code>workLoopConcurrentByScheduler</code>&#x2F;<code>workLoopConcurrent</code>&#x2F;<code>workLoopSync</code>开始讲的，他们里面去循环遍历执行<code>performUnitOfWork</code>方法，构建Fiber tree。但是总归有点突兀，因为我们也不知道是谁调用的上面这三个方法。那么这一篇，我们就梳理一下调用流程，从一次状态更新，一直看到开始重新渲染。</p><h1 id="一次同步更新"><a href="#一次同步更新" class="headerlink" title="一次同步更新"></a>一次同步更新</h1><p>我们看个简单的例子，就比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>c+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>就比如这样一个简单的场景吧，当你点击了一个按钮，触发了<code>onClick</code>方法，那么我们知道执行<code>setCount</code>，会触发React的重新渲染。并且由于没有使用并发的API，所以这次重新渲染会是不可中断的，会执行到<code>workLoopSync</code>这个方法里。</p><p>我们就来看看<code>setCount</code>是最终如何走到<code>workLoopSync</code>的吧</p><h2 id="setCount实际是dispatchSetState方法"><a href="#setCount实际是dispatchSetState方法" class="headerlink" title="setCount实际是dispatchSetState方法"></a>setCount实际是dispatchSetState方法</h2><p>前面我们介绍<code>hooks</code>的时候，以<code>useReducer</code>为例，讲了一下hooks在渲染过程中是怎么被处理的。<code>useState</code>其实是同理。在mount阶段，<code>useState</code>被替换成<code>dispatchSetState</code>方法，实际的重点逻辑在<code>dispatchSetStateInternal</code>里。</p><p><code>dispatchSetStateInternal</code>的逻辑其实在番外篇一里，也简单看过啦，这里再看一遍吧</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> dispatchSetStateInternal&lt;S, A&gt;(<br>  <span class="hljs-attr">fiber</span>: <span class="hljs-title class_">Fiber</span>,<br>  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;S, A&gt;,<br>  <span class="hljs-attr">action</span>: A,<br>  <span class="hljs-attr">lane</span>: <span class="hljs-title class_">Lane</span>,<br>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&lt;S, A&gt; = &#123;<br>    lane,<br>    <span class="hljs-attr">revertLane</span>: <span class="hljs-title class_">NoLane</span>,<br>    action,<br>    <span class="hljs-attr">hasEagerState</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">eagerState</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">next</span>: (<span class="hljs-attr">null</span>: <span class="hljs-built_in">any</span>),<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRenderPhaseUpdate</span>(fiber)) &#123;<br>    <span class="hljs-title function_">enqueueRenderPhaseUpdate</span>(queue, update);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> alternate = fiber.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">if</span> (<br>      fiber.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span> &amp;&amp;<br>      (alternate === <span class="hljs-literal">null</span> || alternate.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span>)<br>    ) &#123;<br>      <span class="hljs-keyword">const</span> lastRenderedReducer = queue.<span class="hljs-property">lastRenderedReducer</span>;<br>      <span class="hljs-keyword">if</span> (lastRenderedReducer !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> prevDispatcher = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> <span class="hljs-attr">currentState</span>: S = (queue.<span class="hljs-property">lastRenderedState</span>: <span class="hljs-built_in">any</span>);<br>          <span class="hljs-keyword">const</span> eagerState = <span class="hljs-title function_">lastRenderedReducer</span>(currentState, action);<br><br>          update.<span class="hljs-property">hasEagerState</span> = <span class="hljs-literal">true</span>;<br>          update.<span class="hljs-property">eagerState</span> = eagerState;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is</span>(eagerState, currentState)) &#123;<br>            <span class="hljs-title function_">enqueueConcurrentHookUpdateAndEagerlyBailout</span>(fiber, queue, update);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          <span class="hljs-comment">// Suppress the error. It will throw again in the render phase.</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>            <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span> = prevDispatcher;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">enqueueConcurrentHookUpdate</span>(fiber, queue, update, lane);<br>    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);<br>      <span class="hljs-title function_">entangleTransitionUpdate</span>(root, queue, lane);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>入参<code>action</code>就是我们传的更新行为，在我的例子里是<code>c=&gt;c+1</code>这个函数</p><p>首先如果是渲染过程中的更新，那么会立刻把这个<code>action</code>加入到对应hook的<code>queue.pending</code>，这个环形链表当中。</p><p>如果不是渲染过程中的更新，那么则判断是否能做<code>eagerState</code>优化。要求是，当前Fiber和它的alernate节点，都不能有待处理的更新，并且执行action前后，state没有发生变化。如果满足条件，则命中<code>eagerState</code>优化，这一次不会重新渲染。</p><p>如果未命中优化，则正常将更新需要的参数都塞到数组里，然后执行<code>scheduleUpdateOnFiber</code>方法。</p><h2 id="关键的scheduleUpdateOnFiber和ensureRootIsScheduled"><a href="#关键的scheduleUpdateOnFiber和ensureRootIsScheduled" class="headerlink" title="关键的scheduleUpdateOnFiber和ensureRootIsScheduled"></a>关键的scheduleUpdateOnFiber和ensureRootIsScheduled</h2><p><code>scheduleUpdateOnFiber</code>方法是很常用的，基本上看到它，就等同于安排重新渲染了。然而它里面还是判断了很多的逻辑，有很多分支我们都不会走进去。对于现阶段来讲，我们只需要关注它里面调用了<code>ensureRootIsScheduled(root)</code>即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params"><span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-comment">// This function is called whenever a root receives an update. It does two</span><br>  <span class="hljs-comment">// things 1) it ensures the root is in the root schedule, and 2) it ensures</span><br>  <span class="hljs-comment">// there&#x27;s a pending microtask to process the root schedule.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Most of the actual scheduling logic does not happen until</span><br>  <span class="hljs-comment">// `scheduleTaskForRootDuringMicrotask` runs.</span><br><br>  <span class="hljs-comment">// Add the root to the schedule</span><br>  <span class="hljs-keyword">if</span> (root === lastScheduledRoot || root.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// Fast path. This root is already scheduled.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (lastScheduledRoot === <span class="hljs-literal">null</span>) &#123;<br>      firstScheduledRoot = lastScheduledRoot = root;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastScheduledRoot.<span class="hljs-property">next</span> = root;<br>      lastScheduledRoot = root;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Any time a root received an update, we set this to true until the next time</span><br>  <span class="hljs-comment">// we process the schedule. If it&#x27;s false, then we can quickly exit flushSync</span><br>  <span class="hljs-comment">// without consulting the schedule.</span><br>  mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">if</span> (!didScheduleMicrotask) &#123;<br>    didScheduleMicrotask = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ensureRootIsScheduled</code>方法，负责将一个root加入调度。这里可以看到，React依然是用环形列表来维护需要调度的root的，React在频繁需要尾插的场景都是使用的环形列表。当然，通常来讲我们的应用里只有一个root。少数的应用，可能会在多处调用<code>ReactDom.createRoot</code>，这样就会有多个root。处于简单考虑，我们理解的时候可以只去想一个root的场景。</p><p>然后，将<code>mightHavePendingSyncWork</code>设为true，后面可以看到这是个标记位，如果没有同步任务可以提前结束。</p><p>接下来，如果当前已经在调度中了，那么就不需要调度了，保证了一次事件循环里，只触发一次重新渲染。如果没有调度，则标记为正在调度，并且进行调度，即执行<code>scheduleImmediateRootScheduleTask</code>。</p><p><code>scheduleImmediateRootScheduleTask</code>方法源码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleImmediateRootScheduleTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Can we land supportsMicrotasks? Which environments don&#x27;t support it?</span><br>  <span class="hljs-comment">// Alternatively, can we move this check to the host config?</span><br>  <span class="hljs-keyword">if</span> (supportsMicrotasks) &#123;<br>    <span class="hljs-title function_">scheduleMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// In Safari, appending an iframe forces microtasks to run.</span><br>      <span class="hljs-comment">// https://github.com/facebook/react/issues/22459</span><br>      <span class="hljs-comment">// We don&#x27;t support running callbacks in the middle of render</span><br>      <span class="hljs-comment">// or commit so we need to check against that.</span><br>      <span class="hljs-keyword">const</span> executionContext = <span class="hljs-title function_">getExecutionContext</span>();<br>      <span class="hljs-keyword">if</span> ((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) &#123;<br>        <span class="hljs-comment">// Note that this would still prematurely flush the callbacks</span><br>        <span class="hljs-comment">// if this happens outside render or commit phase (e.g. in an event).</span><br><br>        <span class="hljs-comment">// Intentionally using a macrotask instead of a microtask here. This is</span><br>        <span class="hljs-comment">// wrong semantically but it prevents an infinite loop. The bug is</span><br>        <span class="hljs-comment">// Safari&#x27;s, not ours, so we just do our best to not crash even though</span><br>        <span class="hljs-comment">// the behavior isn&#x27;t completely correct.</span><br>        <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<br>          <span class="hljs-title class_">ImmediateSchedulerPriority</span>,<br>          processRootScheduleInImmediateTask,<br>        );<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">processRootScheduleInMicrotask</span>();<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If microtasks are not supported, use Scheduler.</span><br>    <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<br>      <span class="hljs-title class_">ImmediateSchedulerPriority</span>,<br>      processRootScheduleInImmediateTask,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>scheduleImmediateRootScheduleTask</code>的内容也很简单，判断一下当前宿主环境是否支持微任务。在<code>react-dom</code>中，<code>supportsMicrotasks</code>是true，所以不会走到最下面用scheduler调度的分支里去。那个分支最快会在下个宏任务开始渲染。而在支持微任务的场景下，最快会在下个微任务开始渲染。</p><p>微任务调度，会通过<code>scheduleMicrotask</code>来实现。<code>scheduleMicrotask</code>其实就是<code>queueMicrotask</code>。如果浏览器不支持<code>queueMicrotask</code>API，则会通过promise去生成一个微任务。然后在微任务里面，去执行<code>processRootScheduleInMicrotask</code>.</p><p>不过如果当前是在render或者commit流程中，那么要使用宏任务去调度，这是为了避免无限循环。这种场景只在safari导致的bug中会出现。</p><p>如果是正常场景，则会调用<code>processRootScheduleInMicrotask</code>方法。这个方法的功能如字面意思所示，是在微任务中调度。在另外通过宏任务调度是，callback方法是<code>processRootScheduleInImmediateTask</code>，两个callback是不一样的。</p><p>在<code>processRootScheduleInMicrotask</code>方法中，react会选出下一次渲染需要执行的优先级，最后开始重新渲染</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processRootScheduleInMicrotask</span>(<span class="hljs-params"></span>) &#123;<br>  didScheduleMicrotask = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// We&#x27;ll recompute this as we iterate through all the roots and schedule them.</span><br>  mightHavePendingSyncWork = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">let</span> syncTransitionLanes = <span class="hljs-title class_">NoLanes</span>;<br>  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> root = firstScheduledRoot;<br>  <span class="hljs-keyword">while</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> next = root.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">scheduleTaskForRootDuringMicrotask</span>(root, currentTime);<br>    <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLane</span>) &#123;<br>      <span class="hljs-comment">// This root has no more pending work. Remove it from the schedule. To</span><br>      <span class="hljs-comment">// guard against subtle reentrancy bugs, this microtask is the only place</span><br>      <span class="hljs-comment">// we do this — you can add roots to the schedule whenever, but you can</span><br>      <span class="hljs-comment">// only remove them here.</span><br><br>      <span class="hljs-comment">// Null this out so we know it&#x27;s been removed from the schedule.</span><br>      root.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (prev === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new head of the list</span><br>        firstScheduledRoot = next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.<span class="hljs-property">next</span> = next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// This is the new tail of the list</span><br>        lastScheduledRoot = prev;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This root still has work. Keep it in the list.</span><br>      prev = root;<br><br>      <span class="hljs-comment">// This is a fast-path optimization to early exit from</span><br>      <span class="hljs-comment">// flushSyncWorkOnAllRoots if we can be certain that there is no remaining</span><br>      <span class="hljs-comment">// synchronous work to perform. Set this to true if there might be sync</span><br>      <span class="hljs-comment">// work left.</span><br>      <span class="hljs-keyword">if</span> (<br>        <span class="hljs-comment">// Common case: we&#x27;re not treating any extra lanes as synchronous, so we</span><br>        <span class="hljs-comment">// can just check if the next lanes are sync.</span><br>        <span class="hljs-title function_">includesSyncLane</span>(nextLanes)<br>      ) &#123;<br>        mightHavePendingSyncWork = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    root = next;<br>  &#125;<br><br>  <span class="hljs-comment">// At the end of the microtask, flush any pending synchronous work. This has</span><br>  <span class="hljs-comment">// to come at the end, because it does actual rendering work that might throw.</span><br>  <span class="hljs-title function_">flushSyncWorkAcrossRoots_impl</span>(syncTransitionLanes, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，将<code>didScheduleMicrotask</code>置为false。这个是防止重复调度的，你既然已经开始执行了，那么相当于调度已经完成了，所以将它改为false。</p><p>然后将<code>mightHavePendingSyncWork</code>置为false，因为这个值会在下面重新计算，看root上面是否真的有同步任务。</p><p>接下来对遍历root，我们可以忽略循环，只看里面要执行的代码。因为大多数情况，我们的react应用只有一个root。要通过<code>scheduleTaskForRootDuringMicrotask</code>方法，找到这个root下面，下一次渲染要执行的优先级。如果是同步优先级，那么直接返回。如果是低优先级，则会通过scheduler去调度低优先级中，优先级最高的任务。</p><p>如果<code>nextLanes</code>是<code>NoLane</code>了，就说明这个root没有待完成的更新了。</p><p>如果<code>nextLanes</code>有值，如果它是同步的优先级，那么将<code>mightHavePendingSyncWork</code>设置为true。</p><p>然后执行<code>flushSyncWorkAcrossRoots_impl</code>，开始渲染，把所有同步优先级的任务都执行干净。</p><p>因为这一次是同步的更新，所以我们只关注<code>flushSyncWorkAcrossRoots_impl</code>就可以了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncWorkAcrossRoots_impl</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">syncTransitionLanes</span>: <span class="hljs-title class_">Lanes</span> | <span class="hljs-title class_">Lane</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">onlyLegacy</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (isFlushingWork) &#123;<br>    <span class="hljs-comment">// Prevent reentrancy.</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Is this overly defensive? The callers must check the execution</span><br>    <span class="hljs-comment">// context first regardless.</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!mightHavePendingSyncWork) &#123;<br>    <span class="hljs-comment">// Fast path. There&#x27;s no sync work to do.</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// There may or may not be synchronous work scheduled. Let&#x27;s check.</span><br>  <span class="hljs-keyword">let</span> didPerformSomeWork;<br>  isFlushingWork = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    didPerformSomeWork = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> root = firstScheduledRoot;<br>    <span class="hljs-keyword">while</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (onlyLegacy &amp;&amp; (disableLegacyMode || root.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">LegacyRoot</span>)) &#123;<br>        <span class="hljs-comment">// Skip non-legacy roots.</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (syncTransitionLanes !== <span class="hljs-title class_">NoLanes</span>) &#123;<br>          <span class="hljs-comment">// 同步更新走不到</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">const</span> workInProgressRoot = <span class="hljs-title function_">getWorkInProgressRoot</span>();<br>          <span class="hljs-keyword">const</span> workInProgressRootRenderLanes =<br>            <span class="hljs-title function_">getWorkInProgressRootRenderLanes</span>();<br>          <span class="hljs-keyword">const</span> rootHasPendingCommit =<br>            root.<span class="hljs-property">cancelPendingCommit</span> !== <span class="hljs-literal">null</span> ||<br>            root.<span class="hljs-property">timeoutHandle</span> !== noTimeout;<br>          <span class="hljs-keyword">const</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(<br>            root,<br>            root === workInProgressRoot<br>              ? workInProgressRootRenderLanes<br>              : <span class="hljs-title class_">NoLanes</span>,<br>            rootHasPendingCommit,<br>          );<br>          <span class="hljs-keyword">if</span> (<br>            (<span class="hljs-title function_">includesSyncLane</span>(nextLanes) ||<br>              (enableSwipeTransition &amp;&amp; <span class="hljs-title function_">isGestureRender</span>(nextLanes))) &amp;&amp;<br>            !<span class="hljs-title function_">checkIfRootIsPrerendering</span>(root, nextLanes)<br>          ) &#123;<br>            <span class="hljs-comment">// This root has pending sync work. Flush it now.</span><br>            didPerformSomeWork = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">performSyncWorkOnRoot</span>(root, nextLanes);<br>          &#125;<br>        &#125;<br>      &#125;<br>      root = root.<span class="hljs-property">next</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (didPerformSomeWork);<br>  isFlushingWork = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，如果<code>isFlushingWork</code>已经是true，就提前结束，防止重入。然后如果进入到这里的时候，没有同步的更新，也直接结束。</p><p>接下来<code>getNextLanes</code>方法返回当下最高的更新优先级，如果有同步更新，则直接执行<code>performSyncWorkOnRoot</code>方法。</p><p>后续的调用流程就比较简单了，大致是<code>performSyncWorkOnRoot</code>-&gt;<code>performSyncWorkOnRoot</code>-&gt;<code>performWorkOnRoot</code>-&gt;<code>renderRootSync</code>-&gt;<code>workLoopSync</code>这么个流程，就不展开细讲了</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实这篇关于细节讲得也很粗略，有点惭愧，因为我也没能对于React的每个细节都深入了解，也有些是写着写着才发现自己不懂。所以可能这篇主要还是起到一个，让大家简要熟悉触发渲染的大致流程的作用。至少我们知道了，在React19里，一次同步优先级的更新，是通过微任务调度。即在下一个微任务去执行，并且会同步执行完reconcile阶段，即构建完整棵fiber树（因为是同步优先级，所以中间不可打断）。</p><p>说到这里，也希望给大家分享一个别人分享给我的网站。这个网站像是一个专门针对前端的leetCode，其中专门有一个react-quiz这一节，前面的题都比较简单，但是到了后面还是挺有难度的。大家有兴趣也可以去看看。<a href="https://bigfrontend.dev/react-quiz">https://bigfrontend.dev/react-quiz</a></p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Fiber</tag>
      
      <tag>渲染流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（番外篇之一）：学习React源码有什么用</title>
    <link href="/2025/08/31/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E7%95%AA%E5%A4%96%E7%AF%87%E4%B9%8B%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%A6%E4%B9%A0React%E6%BA%90%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
    <url>/2025/08/31/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E7%95%AA%E5%A4%96%E7%AF%87%E4%B9%8B%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AD%A6%E4%B9%A0React%E6%BA%90%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a> 。</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>不知道各位读者学习React源码是为了什么。我学习React的源码，有一部分是好奇，因为我不想把总打交道的东西当成一个黑盒。了解它的实现，不仅可以在用的时候更少踩坑，还可以知其所以然。还有一部分原因就是，我相信日常的学习积累，总有一天会派上用场。机会总是给有准备的人。</p><p>之所以写一篇番外，是前几天解决了一个公司项目偶现的问题。问题的现象是，一个React组件一直在不停的重复渲染，但是找不出重复渲染的原因。我们通过埋点，在发现短时间高频次重复渲染时，上报数据，但是也排查不出问题。这个问题困扰了我们组差不多半年时间，看起来非常玄乎，因为state，props，context全都没有发生变化。</p><p>最初我也看着一头雾水，而在最近几个月入门了解了React的源码之后，偶然间我又复现了这个问题。由于对React代码不再是完全陌生，我尝试打断点去排查问题。当时自己从晚上七点，初步定位到问题，一直到凌晨十二点半，找到问题根因。然后第二天上午，重新理一遍流程，写出最小可复现demo，心情非常舒畅。</p><p>如果说不了解React的源码，我认为是讲不清楚这个问题的原因的。从避免问题的角度来说，代码写规范一点就不会遇到这个问题。但是通常来讲，不规范的写法不至于导致这么奇特的后果，你说出去也很难令人相信。只有从源码的角度来解释，才能理解问题的真相。</p><p>包括现在很多人认为，AI的高速发展，使得人们不需要再投入大量精力去了解这些内部的实现细节，有问题可以直接问AI。实不相瞒，我学习React的源码，很大程度上也是依靠着AI，有些看不懂的代码，我会让AI去帮忙给我解释它的含义。但是我是会实际把流程串一遍的，也经常本地起一个小项目去打断点调试，来验证得到的知识和实际是否相符。</p><p>试想，如果你连React的源码都没看过，你就去问AI为什么会出现这个问题，AI给出的答案你根本没有能力去判断对错，这又有什么意义呢？我一直认为，你得出一个问题的结论，至少要能说服自己。把一个自己都没有搞清楚流程的结论，当做问题的答案，这种行为我做不到。所以所谓的“AI万能论”和“源码无用论”，我是完全无法认可的。</p><p>那么下面我讲一下我排查出的那个问题的原因吧。概括地讲，我认为这是由于React并发渲染模式下，不恰当的写法导致的无限循环渲染问题。</p><p>可复现代码在<a href="https://github.com/miku03090831/react-confusions-explain-demo%EF%BC%8C">https://github.com/miku03090831/react-confusions-explain-demo，</a></p><p>启动后选择<code>Infinite Loop Demo</code>即可。</p><h1 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h1><p>问题发生在React18，一个基于Remix1.x的流式渲染项目中，项目使用<code>react-dom</code>的新API，支持并发渲染。在某种情况下，水合的时候会产生一个低优先级的更新。很可惜的是，我还没有看到水合的部分，因此还不清楚这个低优先级的更新具体是怎么产生的。所以我的demo中，是使用<code>useTransition</code>来产生一个低优先级的更新。</p><p>我们看一下demo里的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> initialObj = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">obj</span>: <span class="hljs-keyword">typeof</span> initialObj,</span><br><span class="hljs-params">  <span class="hljs-attr">action</span>: &#123; <span class="hljs-keyword">type</span>: <span class="hljs-built_in">string</span>; payload?: <span class="hljs-built_in">any</span> &#125;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...obj, <span class="hljs-attr">count</span>: obj.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，定义一个<code>reducer</code>，其实这个demo里不用<code>useReducer</code>，用<code>useState</code>也可以。只需要保证，我们用到的状态是个对象类型，不是基本类型，即可。</p><p>然后组件里面的逻辑也很简单</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();<br><span class="hljs-keyword">const</span> [ok, setOk] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">const</span> [obj, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialObj);<br><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setOk</span>(<span class="hljs-literal">false</span>);<br>&#125;, [obj]);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span> &#125;);<br>  &#125;);<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;increment&quot;</span> &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们看下，当触发<code>onClick</code>后，会去执行两次<code>dispatch</code>，一次低优先级，一次高优先级。而<code>dispatch</code>会改变<code>obj</code>，进而在重新渲染的时候，执行<code>useEffect</code>里面的逻辑。</p><p>而<code>useEffect</code>里面的逻辑就更简单了，将<code>ok</code>恒设为false。那我们直觉看上去，是不是觉得点一下按钮，得到了<code>increment</code>两次的一个<code>obj</code>，和值是<code>false</code>的<code>ok</code>，然后一切就结束了呢？</p><p>然而，当你本地运行，点击按钮，触发<code>onClick</code>后，打开控制台，你会发现这个组件一直在重新渲染。每渲染一次，他就会输出一条console.log，而控制台此刻正在不停地打印日志。</p><h1 id="解释原因"><a href="#解释原因" class="headerlink" title="解释原因"></a>解释原因</h1><p>和这个问题相关的React源码部分有，<code>useReducer</code>的实现、<code>dispatch</code>的实现、<code>useEffect</code>的实现、<code>scheduler</code>调度。以上内容虽然我没有全部讲过，但是看过前几篇文章的读者，如果能理解并发更新，可中断，以及hooks的原理，那么对于听懂这个问题的原因是有很大帮助的。</p><p>由于两次<code>dispatch</code>的优先级不同，React会优先执行高优先级的更新。在高优先级的更新执行完毕后，等到下一个宏任务，再执行低优先级的更新。</p><p>当你去dispatch的时候，会执行<code>scheduleUpdateOnFiber</code>，进而去触发React的重新渲染。</p><h2 id="useReducer的优先级处理"><a href="#useReducer的优先级处理" class="headerlink" title="useReducer的优先级处理"></a>useReducer的优先级处理</h2><p>我们前面dispatch了两次，第一次低优先级，第二次高优先级。那么在并发模式下，React会如何处理呢？</p><p>React会优先取更高的优先级，去重新渲染。</p><p>在重新渲染的时候，执行到<code>useReducer</code>，React会根据此次渲染的优先级，去计算最终的State。大致描述为，执行高优先级的更新，跳过低优先级的更新。</p><p>具体逻辑如下：优先级符合的更新被执行，低优先级的更新被跳过并保留起来。最重要的是，排在低优先级更新后的更新（例如第二个dispatch，它排在第一个dispatch后面，但它优先级更高），<strong>不论是否执行，都会被一并保留</strong>。具体原因详见上一篇对于<code>useReducer</code>的详解。</p><p>而第一次高优先级的更新渲染完毕后，由于<code>obj</code>发生了变化，那么<code>useEffect</code>里面的代码会被执行，执行<code>setOk(false)</code>。</p><h2 id="useState的eagerState优化失效"><a href="#useState的eagerState优化失效" class="headerlink" title="useState的eagerState优化失效"></a>useState的eagerState优化失效</h2><p>这次<code>setOk(false)</code>是否会导致重新渲染呢？</p><p>理论上<code>ok</code>的值一直从最开始就是<code>false</code>，那么将它改成<code>false</code>按照经验来说应该无事发生。这是依赖<code>useState</code>的<code>eagerState</code>优化机制，即结果不变则不触发重新渲染。</p><p>但是这个优化是有条件的，要求wip和current当前不能有待执行的更新，也就是<code>lanes</code>要是<code>NoLanes</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<br>  fiber.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span> &amp;&amp;<br>  (alternate === <span class="hljs-literal">null</span> || alternate.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span>)<br>) &#123;<br>  <span class="hljs-keyword">const</span> lastRenderedReducer = queue.<span class="hljs-property">lastRenderedReducer</span>;<br>  <span class="hljs-keyword">if</span> (lastRenderedReducer !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">let</span> prevDispatcher = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      prevDispatcher = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span>;<br>      <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span> = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateInDEV</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">currentState</span>: S = (queue.<span class="hljs-property">lastRenderedState</span>: any);<br>      <span class="hljs-keyword">const</span> eagerState = <span class="hljs-title function_">lastRenderedReducer</span>(currentState, action);<br>      update.<span class="hljs-property">hasEagerState</span> = <span class="hljs-literal">true</span>;<br>      update.<span class="hljs-property">eagerState</span> = eagerState;<br>      <span class="hljs-comment">// 如果state没变则不重新渲染。前提是能进入最上面的if分支</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is</span>(eagerState, currentState)) &#123;<br>        <span class="hljs-title function_">enqueueConcurrentHookUpdateAndEagerlyBailout</span>(fiber, queue, update);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// Suppress the error. It will throw again in the render phase.</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>        <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span> = prevDispatcher;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而此刻，<code>obj</code>还有一个低优先级更新等待执行。所以不满足条件，React依旧会重新渲染，并且这次重新渲染是由<code>setOk</code>触发的，优先级依旧是高。</p><h2 id="浅拷贝导致obj变化"><a href="#浅拷贝导致obj变化" class="headerlink" title="浅拷贝导致obj变化"></a>浅拷贝导致obj变化</h2><p>由于这一次渲染的优先级还是高，那么针对<code>obj</code>的低优先级的dispatch还是会被跳过。</p><p>在这次渲染中，<code>useReducer</code>会执行一遍上次被执行过的更新（具体原理详见上一节），这一执行就出问题了，得到了一个内容虽然没有变化，但是发生了浅拷贝的对象。因为我们的reducer里面就是这么写的，返回<code>&#123; ...obj, count: obj.count + 1 &#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// updateReducerImpl的实现</span><br><span class="hljs-comment">// Process this update.</span><br><span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;<br><span class="hljs-keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;<br>  <span class="hljs-title function_">reducer</span>(newState, action);<br>&#125;<br><span class="hljs-keyword">if</span> (update.<span class="hljs-property">hasEagerState</span>) &#123;<br>  newState = ((update.<span class="hljs-property">eagerState</span>: any): S);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 走到这个分支</span><br>  newState = <span class="hljs-title function_">reducer</span>(newState, action);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们继续看，这一次高优先级的渲染完成后，依旧是到处理副作用的阶段，由于<code>useEffect</code>的依赖发生了变化，里面的<code>setOk(false)</code>又会被执行。进而，如上面已经所讲过的一样，又重新触发一次高优先级的渲染。</p><p>至此，这个流程已经陷入了死循环了。因为针对<code>obj</code>的低优先级渲染永远不会被执行到，每一次跳过它之后，都会触发<code>useEffect</code>，然后又产生了一个高优先级的更新。然后，就会不断重复上述的过程</p><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>我偷懒了不想画流程图，简要表述一下，就像这样</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs isbl">点击按钮<br>  → <span class="hljs-variable">dispatch</span> 高优先级更新<br>    → 渲染 → <span class="hljs-variable">useEffect</span> → <span class="hljs-function"><span class="hljs-title">setOk</span>(<span class="hljs-variable"><span class="hljs-literal">false</span></span>)</span><br>      → 再次渲染（高优先级）<br>        → 低优先级更新继续挂起<br>          → <span class="hljs-variable">reducer</span> 返回浅拷贝对象<br>            → <span class="hljs-variable">useEffect</span> 再次执行 <span class="hljs-function"><span class="hljs-title">setOk</span>(<span class="hljs-variable"><span class="hljs-literal">false</span></span>)</span><br>              → 再次渲染（高优先级）<br>                → 低优先级更新继续挂起<br>                  → <span class="hljs-variable">reducer</span> 返回浅拷贝对象<br>                    → ……<br><br></code></pre></td></tr></table></figure><p>这个无限渲染的根因是三个机制叠加：</p><ol><li><strong>优先级处理</strong>：高优先级更新先执行，低优先级更新被挂起；</li><li><strong>eagerState 失效</strong>：由于仍存在挂起更新（<code>lanes</code> 非 <code>NoLanes</code>），<code>setOk(false)</code> <strong>不会被“结果相同则跳过”优化</strong>拦下，仍触发渲染；</li><li><strong>对象引用变化</strong>：<code>reducer</code> 返回的新对象（以及可能的值变化）使依赖判定为变化，<code>useEffect</code> 再次触发 <code>setOk(false)</code>。</li></ol><p>三者循环往复，形成死循环。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>那其实找到原因了，解决起来自然就是非常简单，打破循环就可以了。</p><p>比如，我们不让每一次重新渲染后，都触发<code>useEffect</code>里面逻辑的执行，将<code>useEffect</code>的依赖项，从<code>obj</code>这么一个对象，改成<code>obj.count</code>这样一个具体的值。本身<code>useEffect</code>去依赖一个对象，就要考虑到对象容易变化这个风险，因此写依赖项的时候更要结合实际，看你是真的需要依赖整个对象是否变化，还是依赖对象上面的具体字段是否变化。</p><p>再比如，退一步说，你真的就是要判断<code>obj</code>对象本身是否发生变化。那你也可以手动地去判一下，<code>setOk</code>的目标值，和当前<code>ok</code>的值是否有变化，如果没变化，不执行<code>setOk</code>就好了</p><p>以上两种都可以打破这个死循环</p><h1 id="最终感悟"><a href="#最终感悟" class="headerlink" title="最终感悟"></a>最终感悟</h1><p>你只管去学，你的积累总有一天会带给你意想不到的惊喜。</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
      <tag>React源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（五）：子节点的diff算法</title>
    <link href="/2025/08/24/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <url>/2025/08/24/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a> 。下文中展示的代码可能省略了部分不影响主题逻辑的代码，例如dev环境下才执行的代码、水合时执行的代码</p></blockquote><p>本篇我们继续来看<code>beginWork</code>里面的部分，依旧是以函数组件为例。</p><h1 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h1><p>看完了执行组件自身的部分，我们接下来要看<code>reconcileChildren</code>部分了。</p><p>执行组件自身，返回了他的jsx，也就是它的子组件。而我们都知道，jsx语法会被babel处理成ReactElement对象。那么<code>reconcileChildren</code>的工作，就是把这些ReactElement转成FiberNode，并且和当前正在构建的workInProgress这棵树连接起来。换个角度说，<code>reconcileChildren</code>是为workInProgress树中当前遍历到的FiberNode，构建子FiberNode的。</p><p><code>reconcileChildren</code>的入参包括了当前workInProgress对应的current树中的节点，当前workInProgress节点，当前workInProgress的子节点（ReactElement形式），渲染优先级。它生成当前workInProgress的子节点（以FiberNode形式），并将子节点和workInProgress连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  nextChildren: any,</span><br><span class="hljs-params">  renderLanes: Lanes,</span><br><span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span><br>    <span class="hljs-comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span><br>    <span class="hljs-comment">// we will add them all to the child before it gets rendered. That means</span><br>    <span class="hljs-comment">// we can optimize this reconciliation pass by not tracking side-effects.</span><br>    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">mountChildFibers</span>(<br>      workInProgress,<br>      <span class="hljs-literal">null</span>,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If the current child is the same as the work in progress, it means that</span><br>    <span class="hljs-comment">// we haven&#x27;t yet started any work on these children. Therefore, we use</span><br>    <span class="hljs-comment">// the clone algorithm to create a copy of all the current children.</span><br><br>    <span class="hljs-comment">// If we had any progressed work already, that is invalid at this point so</span><br>    <span class="hljs-comment">// let&#x27;s throw it out.</span><br>    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(<br>      workInProgress,<br>      current.<span class="hljs-property">child</span>,<br>      nextChildren,<br>      renderLanes,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里根据当前组件是首次mount，还是后续update，分别执行了两个方法。而这两个方法其实都来自<code>createChildReconciler</code>方法，区别只是mount不需要追踪副作用，把新增的节点插进去就行了。而update的时候是需要的，需要和原来的节点对比，做什么操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> mountChildFibers: ChildReconciler = <span class="hljs-built_in">createChildReconciler</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-type">const</span> reconcileChildFibers: ChildReconciler = <span class="hljs-built_in">createChildReconciler</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="createChildReconciler"><a href="#createChildReconciler" class="headerlink" title="createChildReconciler"></a>createChildReconciler</h1><p>我们接下来看一下<code>createChildReconciler</code>方法的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChildReconciler</span>(<span class="hljs-params">shouldTrackSideEffects: boolean</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildFibers</span>(<span class="hljs-params"></span><br><span class="hljs-params">    returnFiber: Fiber,</span><br><span class="hljs-params">    currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    newChild: any,</span><br><span class="hljs-params">    lanes: Lanes,</span><br><span class="hljs-params">  </span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>&#123;<br>        <span class="hljs-comment">// xxx</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> reconcileChildFibers<br>&#125;<br></code></pre></td></tr></table></figure><p>它在内部定义了一个<code>reconcileChildFibers</code>方法，最终return了这个方法。并且根据<code>shouldTrackSideEffects</code>参数的不同，<code>reconcileChildFibers</code>中间的很多逻辑也都有所不同，具体等后面深入的时候会讲到。</p><p>我们观察<code>reconcileChildFibers</code>的声明，以及前面调用它的时候，可以看到它的入参是当前workInProgress节点，对应的current节点的第一个子节点，自身的子节点（ReactElement形式），以及渲染优先级。它最终会返回workInProgress的子节点（FiberNode形式），也可能不返回，就说明没有子节点了。</p><h2 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h2><p>除了<code>reconcileChildFibers</code>，<code>createChildReconciler</code>内部还定义了许多工具方法，用于协助创建FiberNode。为了方便后续深入学习，我们先简要了解一下这些工具方法。</p><h3 id="useFiber"><a href="#useFiber" class="headerlink" title="useFiber"></a>useFiber</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFiber</span>(<span class="hljs-params">fiber: Fiber, pendingProps: mixed</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-comment">// We currently set sibling to null and index to 0 here because it is easy</span><br>  <span class="hljs-comment">// to forget to do before returning it. E.g. for the single child case.</span><br>  <span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">createWorkInProgress</span>(fiber, pendingProps);<br>  clone.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;<br>  clone.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>useFiber</code>方法主要用来从current树克隆FiberNode节点，通常在diff算法中判断可复用老节点时使用。所以当你看到<code>useFiber</code>方法的时候，你就知道是复用节点就可以了。</p><h3 id="placeChild"><a href="#placeChild" class="headerlink" title="placeChild"></a>placeChild</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">placeChild</span>(<span class="hljs-params"></span><br><span class="hljs-params">  newFiber: Fiber,</span><br><span class="hljs-params">  lastPlacedIndex: number,</span><br><span class="hljs-params">  newIndex: number,</span><br><span class="hljs-params"></span>): number &#123;<br>  newFiber.<span class="hljs-property">index</span> = newIndex;<br>  <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) &#123;<br>    <span class="hljs-comment">// During hydration, the useId algorithm needs to know which fibers are</span><br>    <span class="hljs-comment">// part of a list of children (arrays, iterators).</span><br>    newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Forked</span>;<br>    <span class="hljs-keyword">return</span> lastPlacedIndex;<br>  &#125;<br>  <span class="hljs-keyword">const</span> current = newFiber.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> oldIndex = current.<span class="hljs-property">index</span>;<br>    <span class="hljs-keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;<br>      <span class="hljs-comment">// This is a move.</span><br>      newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">PlacementDEV</span>;<br>      <span class="hljs-keyword">return</span> lastPlacedIndex;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This item can stay in place.</span><br>      <span class="hljs-keyword">return</span> oldIndex;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// This is an insertion.</span><br>    newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">PlacementDEV</span>;<br>    <span class="hljs-keyword">return</span> lastPlacedIndex;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>placeChild</code> 用于多子节点场景下判断当前子节点是否需要<strong>移动&#x2F;插入</strong>。通过<code>lastPlacedIndex</code>去判断新的节点是否需要被打上移动的标记。这个方法只在一个场景被调用，所以它的具体逻辑，我将在调用它的地方讲解。</p><h3 id="placeSingleChild"><a href="#placeSingleChild" class="headerlink" title="placeSingleChild"></a>placeSingleChild</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-params">newFiber: Fiber</span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-comment">// This is simpler for the single child case. We only need to do a</span><br>  <span class="hljs-comment">// placement for inserting new children.</span><br>  <span class="hljs-keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) &#123;<br>    newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">PlacementDEV</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newFiber;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>placeSingleChild</code>方法，就是新插入一个子节点，即给它打上插入（placement）的标记flag。</p><p>当然，排除了父组件初次mount（<code>shouldTrackSideEffects</code>为false），或者其子节点初次mount（newFiber.alternate会是null）的场景</p><h3 id="deleteChild"><a href="#deleteChild" class="headerlink" title="deleteChild"></a>deleteChild</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteChild</span>(<span class="hljs-params">returnFiber: Fiber, childToDelete: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) &#123;<br>    <span class="hljs-comment">// Noop.</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> deletions = returnFiber.<span class="hljs-property">deletions</span>;<br>  <span class="hljs-keyword">if</span> (deletions === <span class="hljs-literal">null</span>) &#123;<br>    returnFiber.<span class="hljs-property">deletions</span> = [childToDelete];<br>    returnFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ChildDeletion</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    deletions.<span class="hljs-title function_">push</span>(childToDelete);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>deleteChild</code>方法用于删除单个子节点。删除子节点的方式，是在父节点上打上删除子节点的标记flag，并且把子节点推入deletions数组。</p><h3 id="deleteRemainingChildren"><a href="#deleteRemainingChildren" class="headerlink" title="deleteRemainingChildren"></a>deleteRemainingChildren</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteRemainingChildren</span>(<span class="hljs-params"></span><br><span class="hljs-params">  returnFiber: Fiber,</span><br><span class="hljs-params">  currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) &#123;<br>    <span class="hljs-comment">// Noop.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For the shouldClone case, this could be micro-optimized a bit by</span><br>  <span class="hljs-comment">// assuming that after the first child we&#x27;ve already added everything.</span><br>  <span class="hljs-keyword">let</span> childToDelete = currentFirstChild;<br>  <span class="hljs-keyword">while</span> (childToDelete !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">deleteChild</span>(returnFiber, childToDelete);<br>    childToDelete = childToDelete.<span class="hljs-property">sibling</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>deleteRemainingChildren</code>方法用于删除从当前子节点开始的全部子节点，实现相似于删除单个子节点。</p><h2 id="diff相关的方法"><a href="#diff相关的方法" class="headerlink" title="diff相关的方法"></a>diff相关的方法</h2><p><code>reconcileChildFibers</code>的主要实现逻辑都在<code>reconcileChildFibersImpl</code>里，在它之外应该是做了对suspense的处理。而<code>reconcileChildFibersImpl</code>里面，则又根据子节点的类型，分了很多处理方法。</p><p>常见的子节点类型，有ReactElement（<code>REACT_ELEMENT_TYPE</code>），子元素数组（通过isArray判断），和普通的文本节点（字符串、数字。基本上叶子结点都是文本节点了）。其余的类型不详细讲了，我们着重讲一下上面三种。</p><p>他们首先可分为两类，即单子节点（ReactElement，文本）和多子节点（多个子节点组成的数组）。这里需要注意的是，我们是拿wip的子节点（新）去和current的子节点（旧）去比较，难免会出现新旧不一致的情况。我们这里说的单节点还是多节点，都是针对新子节点而言，与旧子节点有多少个无关，</p><h3 id="单子节点：reconcileSingleElement"><a href="#单子节点：reconcileSingleElement" class="headerlink" title="单子节点：reconcileSingleElement"></a>单子节点：<strong>reconcileSingleElement</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>: &#123;<br>  <span class="hljs-keyword">const</span> prevDebugInfo = <span class="hljs-title function_">pushDebugInfo</span>(newChild.<span class="hljs-property">_debugInfo</span>);<br>  <span class="hljs-keyword">const</span> firstChild = <span class="hljs-title function_">placeSingleChild</span>(<br>    <span class="hljs-title function_">reconcileSingleElement</span>(<br>      returnFiber,<br>      currentFirstChild,<br>      newChild,<br>      lanes,<br>    ),<br>  );<br>  currentDebugInfo = prevDebugInfo;<br>  <span class="hljs-keyword">return</span> firstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>placeSingleElement</code>上面已经介绍过了，就是插入单个节点的方法（如果父节点或者子节点是首次mount，则不需要记录插入副作用）</p><p>下面着重看一下<code>reconcileSingleElement</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleElement</span>(<span class="hljs-params"></span><br><span class="hljs-params">  returnFiber: Fiber,</span><br><span class="hljs-params">  currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  element: ReactElement,</span><br><span class="hljs-params">  lanes: Lanes,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-keyword">const</span> key = element.<span class="hljs-property">key</span>;<br>  <span class="hljs-keyword">let</span> child = currentFirstChild;<br>  <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If key === null and child.key === null, then this only applies to</span><br>    <span class="hljs-comment">// the first item in the list.</span><br>    <span class="hljs-keyword">if</span> (child.<span class="hljs-property">key</span> === key) &#123;<br>      <span class="hljs-keyword">const</span> elementType = element.<span class="hljs-property">type</span>;<br><br>      <span class="hljs-keyword">if</span> (child.<span class="hljs-property">elementType</span> === elementType) &#123;<br>        <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);<br>        <span class="hljs-keyword">const</span> existing = <span class="hljs-title function_">useFiber</span>(child, element.<span class="hljs-property">props</span>);<br>        <span class="hljs-title function_">coerceRef</span>(existing, element);<br>        existing.<span class="hljs-property">return</span> = returnFiber;<br>        <span class="hljs-keyword">return</span> existing;<br>      &#125;<br>      <span class="hljs-comment">// Didn&#x27;t match.</span><br>      <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child);<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">deleteChild</span>(returnFiber, child);<br>    &#125;<br>    child = child.<span class="hljs-property">sibling</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> created = <span class="hljs-title function_">createFiberFromElement</span>(element, returnFiber.<span class="hljs-property">mode</span>, lanes);<br>  <span class="hljs-title function_">coerceRef</span>(created, element);<br>  created.<span class="hljs-property">return</span> = returnFiber;<br><br>  <span class="hljs-keyword">return</span> created;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是精简后的逻辑，去掉了对于React Fragment、React Lazy、以及开发环境hot reload的处理。我们可以看到，逻辑相当清晰明了。</p><p>以最复杂的，旧子节点有多个的情况去考虑（由于是链表结构，单个是多个的一种简化版本）。从旧子节点的第一个开始，一个一个遍历，去找key和新子节点相同的。如果不同，则删掉当前遍历的子节点，继续遍历。其中，如果都没有指定key，那么key都为null，也会认为key是相同的。</p><p>如果key相同，并且元素类型也相同（例如同为div），则认为匹配成功，从旧的节点clone得到新节点，并且删除掉后续的旧子节点。将clone得到的新fiber连回父节点，就结束了</p><p>如果key相同，但是元素类型不同，则认为匹配失败。用于key相同，暗示了对应关系，对应的节点都匹配失败了，即已经没有能复用的节点了。先删掉后续的所有旧节点，然后基于新节点的ReactElement形式，新生成一个Fiber Node，连回父节点。</p><h3 id="单子节点：reconcileSingleTextNode"><a href="#单子节点：reconcileSingleTextNode" class="headerlink" title="单子节点：reconcileSingleTextNode"></a>单子节点：reconcileSingleTextNode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<br>  (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; newChild !== <span class="hljs-string">&#x27;&#x27;</span>) ||<br>  <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span> ||<br>  <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;bigint&#x27;</span><br>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(<br>    <span class="hljs-title function_">reconcileSingleTextNode</span>(<br>      returnFiber,<br>      currentFirstChild,<br>      <span class="hljs-string">&#x27;&#x27;</span> + newChild,<br>      lanes,<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>对于文本类型的子节点，React会通过<code>reconcileSingleTextNode</code>方法，得到新的子节点。然后通过前面讲过的<code>placeSingleChild</code>方法，判断是否需要为这个节点打上插入的标记。</p><p>所以重点逻辑还是在<code>reconcileSingleTextNode</code>里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleTextNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  returnFiber: Fiber,</span><br><span class="hljs-params">  currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  textContent: string,</span><br><span class="hljs-params">  lanes: Lanes,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-comment">// There&#x27;s no need to check for keys on text nodes since we don&#x27;t have a</span><br>  <span class="hljs-comment">// way to define them.</span><br>  <span class="hljs-keyword">if</span> (currentFirstChild !== <span class="hljs-literal">null</span> &amp;&amp; currentFirstChild.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) &#123;<br>    <span class="hljs-comment">// We already have an existing node so let&#x27;s just update it and delete</span><br>    <span class="hljs-comment">// the rest.</span><br>    <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild.<span class="hljs-property">sibling</span>);<br>    <span class="hljs-keyword">const</span> existing = <span class="hljs-title function_">useFiber</span>(currentFirstChild, textContent);<br>    existing.<span class="hljs-property">return</span> = returnFiber;<br>    <span class="hljs-keyword">return</span> existing;<br>  &#125;<br>  <span class="hljs-comment">// The existing first child is not a text node so we need to create one</span><br>  <span class="hljs-comment">// and delete the existing ones.</span><br>  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);<br>  <span class="hljs-keyword">const</span> created = <span class="hljs-title function_">createFiberFromText</span>(textContent, returnFiber.<span class="hljs-property">mode</span>, lanes);<br>  created.<span class="hljs-property">return</span> = returnFiber;<br><br>  <span class="hljs-keyword">return</span> created;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于文本节点而言，它们没有key这个概念。所以其实只需要判断，如果旧的子节点寸止，并且类型也是<code>HostText</code>，那么就可以复用。删除掉剩余的旧的子节点，从第一个旧子节点克隆一个fiber出来就好了。</p><p>如果没能满足复用的条件，那么就删除全部的旧的子节点，然后重新创造一个文本节点的Fiber。</p><p>不论怎样，得到新子节点的fiber后，将它连回父节点。</p><h3 id="多子节点：reconcileChildrenArray"><a href="#多子节点：reconcileChildrenArray" class="headerlink" title="多子节点：reconcileChildrenArray"></a>多子节点：reconcileChildrenArray</h3><p>下面我们来看可能是最复杂的一个场景，就是新子节点是个数组的情况。</p><p>其实还有一种场景，就是新子节点是个可迭代的对象的场景。和数组的场景类似，有细节上的差别，我们只看数组的场景来理解核心流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(newChild)) &#123;<br>  <span class="hljs-keyword">const</span> prevDebugInfo = <span class="hljs-title function_">pushDebugInfo</span>(newChild.<span class="hljs-property">_debugInfo</span>);<br>  <span class="hljs-keyword">const</span> firstChild = <span class="hljs-title function_">reconcileChildrenArray</span>(<br>    returnFiber,<br>    currentFirstChild,<br>    newChild,<br>    lanes,<br>  );<br>  currentDebugInfo = prevDebugInfo;<br>  <span class="hljs-keyword">return</span> firstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果新子节点是数组，那么执行<code>reconcileChildrenArray</code>方法。</p><p>这里依旧只是以新子节点为判断依据，它是数组就会进到这个逻辑分支。而旧的子节点，最复杂的场景当然也是数组。如果不是数组的话，可以当做是一种简化的场景。</p><p><code>reconcileChildrenArray</code>方法很长，并且逻辑较为复杂。我们分为三个部分来看。</p><h4 id="第一部分：key能匹配上"><a href="#第一部分：key能匹配上" class="headerlink" title="第一部分：key能匹配上"></a>第一部分：key能匹配上</h4><p>第一部分，在新子节点数组中，从头开始，找出key能匹配上的最长子串</p><p>这部分的代码实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildrenArray</span>(<span class="hljs-params"></span><br><span class="hljs-params">  returnFiber: Fiber,</span><br><span class="hljs-params">  currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  newChildren: <span class="hljs-built_in">Array</span>&lt;any&gt;,</span><br><span class="hljs-params">  lanes: Lanes,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">knownKeys</span>: <span class="hljs-title class_">Set</span>&lt;string&gt; | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">resultingFirstChild</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">previousNewFiber</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">let</span> oldFiber = currentFirstChild;<br>  <span class="hljs-keyword">let</span> lastPlacedIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> nextOldFiber = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>    <span class="hljs-keyword">if</span> (oldFiber.<span class="hljs-property">index</span> &gt; newIdx) &#123;<br>      nextOldFiber = oldFiber;<br>      oldFiber = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateSlot</span>(<br>      returnFiber,<br>      oldFiber,<br>      newChildren[newIdx],<br>      lanes,<br>    );<br>    <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>        oldFiber = nextOldFiber;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>      <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// We matched the slot, but we didn&#x27;t reuse the existing fiber, so we</span><br>        <span class="hljs-comment">// need to delete the existing child.</span><br>        <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);<br>      &#125;<br>    &#125;<br>    lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>    <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span><br>      resultingFirstChild = newFiber;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Defer siblings if we&#x27;re not at the right index for this slot.</span><br>      <span class="hljs-comment">// I.e. if we had null values before, then we want to defer this</span><br>      <span class="hljs-comment">// for each null value. However, we also don&#x27;t want to call updateSlot</span><br>      <span class="hljs-comment">// with the previous one.</span><br>      previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>    &#125;<br>    previousNewFiber = newFiber;<br>    oldFiber = nextOldFiber;<br>  &#125;<br>      <br>  <span class="hljs-comment">// 后续部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们直接从循环开始看，里面第一个判断，<code>if (oldFiber.index &gt; newIdx)</code>，正常情况下，不会进入到这个分支，因为新旧节点通常情况下是一起向后推进的，他们的index会保持同样的节奏递增。只有少数场景会进入第一个分支，例如旧子节点中有null，导致相邻的兄弟节点，index相差2而不是1。</p><p><img src="oldIndex%E4%B8%8D%E8%BF%9E%E7%BB%AD.png"></p><p>那么下面我们肯定能看出来了，<code>updateSlot</code>是一个比较重要的方法，他得到了新的子节点数组中，一个子节点的Fiber Node。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSlot</span>(<span class="hljs-params"></span><br><span class="hljs-params">  returnFiber: Fiber,</span><br><span class="hljs-params">  oldFiber: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  newChild: any,</span><br><span class="hljs-params">  lanes: Lanes,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>       <span class="hljs-comment">// 前略</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>: &#123;<br>        <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">key</span> === key) &#123;<br>          <span class="hljs-keyword">const</span> prevDebugInfo = <span class="hljs-title function_">pushDebugInfo</span>(newChild.<span class="hljs-property">_debugInfo</span>);<br>          <span class="hljs-keyword">const</span> updated = <span class="hljs-title function_">updateElement</span>(<br>            returnFiber,<br>            oldFiber,<br>            newChild,<br>            lanes,<br>          );<br>          currentDebugInfo = prevDebugInfo;<br>          <span class="hljs-keyword">return</span> updated;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 后略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里指定了唯一的新子节点，和唯一的旧子节点去比较。如果他们的key没匹配上，那么直接<code>return null</code>给新子节点。如果key匹配上了，就进入<code>updateElement</code>的逻辑。</p><p><code>updateElement</code>方法里面，还是区分了子节点的各种类型，这里我们还是只看函数组件这种场景。因为逻辑很简单就不放源码了，感兴趣可以自己去看，就是类型相同，那么就复用节点。类型不同，那么就重新生成节点（但是不会立刻就删除旧节点）</p><p>接下来继续看第一部分的代码，如果新子节点是null，比如本来新子节点就是null，或者刚才<code>updateSlot</code>里Key没匹配上，那么就会跳出第一部分了。</p><p>如果没有跳出，继续往下走，那么当父节点是update，而不是mount（即<code>shouldTrackSideEffects</code>为true）的时候，如果新子节点不是从旧子节点复用得到的，那么就会标记删除旧子节点。</p><p>接下来，<code>lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</code>。当我们得到新子节点数组中的一个节点的时候，我们就会调用<code>placeChild</code>方法。对于新节点，我们会通过alternate指针，拿到对应的旧节点，从而拿到oldIndex，得知它在旧子节点数组中的顺序。</p><p>由于在第一阶段，我们是按顺序去推进新旧两个列表的，所以不会出现<code>oldIndex&lt;lastPlacedIndex</code>的场景，而是每次进入，都命中第二个分支，去更新<code>lastPlacedIndex</code>。换一个角度来理解，如果新旧子节点，key都能一一对应上，那么也不需要移动了，因为原本顺序就是对的。如下图所示，所有新节点都不需要被打上插入标记。</p><p><img src="%E4%B8%8D%E9%9C%80%E8%A6%81%E7%A7%BB%E5%8A%A8.png"></p><p>以上就是第一部分的内容，在key都能匹配得上，且newFiber不是null的时候，一直往下遍历，就是第一部分的逻辑。</p><p>而一旦key有不匹配了，或者newFiber是null，那么第一部分的逻辑就结束了。</p><p><strong>这是顺序匹配阶段。</strong> 当新旧子节点依次遍历、且 key 能一一对应时，就能快速复用旧 Fiber 来生成新 Fiber。如果整个循环都顺利完成，就进入第二部分；如果中途因为 key 不匹配而中断，则转入第三部分。</p><h4 id="第二部分：新旧数组长度不一致时的处理"><a href="#第二部分：新旧数组长度不一致时的处理" class="headerlink" title="第二部分：新旧数组长度不一致时的处理"></a>第二部分：新旧数组长度不一致时的处理</h4><p>接下来是第二部分的逻辑，是处理正常走完第一部分，而不是中途跳出循环的场景的。</p><p>因为新旧子节点可能长度不一致，所以一方遍历完了，另一方可能还有没被遍历到的节点。第二部分，就是去处理另一方被剩下的，没遍历到的子节点的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (newIdx === newChildren.<span class="hljs-property">length</span>) &#123;<br>  <span class="hljs-comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span><br>  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>()) &#123;<br>    <span class="hljs-keyword">const</span> numberOfForks = newIdx;<br>    <span class="hljs-title function_">pushTreeFork</span>(returnFiber, numberOfForks);<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br><br><span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// If we don&#x27;t have any more existing children we can choose a fast path</span><br>  <span class="hljs-comment">// since the rest will all be insertions.</span><br>  <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>    <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);<br>    <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>    <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span><br>      resultingFirstChild = newFiber;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>    &#125;<br>    previousNewFiber = newFiber;<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果新子节点已经遍历完了，那么就把旧子节点余下的部分删掉。</p><p>如果旧子节点已经遍历完了，那么对于剩余的新子节点，每个节点都要重新生成Fiber Node，并连回父节点上。然后通过<code>placeChild</code>方法，给新的子节点打上插入的标记（因为旧子节点不存在，父组件又是update，所以新子节点算是插入）。</p><p>然后再把新的子节点们通过sibling指针连起来，最后返回第一个子节点，就结束了</p><p><strong>这是收尾处理阶段。</strong> 针对新旧子节点数量不一致的情况：</p><ul><li>如果新子节点先遍历完 → 删除剩余的旧子节点；</li><li>如果旧子节点先遍历完 → 剩余的新子节点全部新建 Fiber 并打上插入标记。</li></ul><h4 id="第三部分：中途跳出循环后，第二次循环"><a href="#第三部分：中途跳出循环后，第二次循环" class="headerlink" title="第三部分：中途跳出循环后，第二次循环"></a>第三部分：中途跳出循环后，第二次循环</h4><p>第二部分是完整走完第一部分后的处理。如果中途跳出了第一部分，那么第二部分的两个if分支都不会被进入。那么就会进入到第三部分，</p><p>第三部分会从第一部分终端的newIndex开始，进行第二次循环，俗称“慢匹配”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Add all children to a key map for quick lookups.</span><br><span class="hljs-keyword">const</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(oldFiber);<br><br><span class="hljs-comment">// Keep scanning and use the map to restore deleted items as moves.</span><br><span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>  <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateFromMap</span>(<br>    existingChildren,<br>    returnFiber,<br>    newIdx,<br>    newChildren[newIdx],<br>    lanes,<br>  );<br>  <span class="hljs-keyword">if</span> (newFiber !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>      <span class="hljs-keyword">if</span> (newFiber.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// The new fiber is a work in progress, but if there exists a</span><br>        <span class="hljs-comment">// current, that means that we reused the fiber. We need to delete</span><br>        <span class="hljs-comment">// it from the child list so that we don&#x27;t add it to the deletion</span><br>        <span class="hljs-comment">// list.</span><br>        existingChildren.<span class="hljs-title function_">delete</span>(<br>          newFiber.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : newFiber.<span class="hljs-property">key</span>,<br>        );<br>      &#125;<br>    &#125;<br>    lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>    <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>      resultingFirstChild = newFiber;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>    &#125;<br>    previousNewFiber = newFiber;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>  <span class="hljs-comment">// Any existing children that weren&#x27;t consumed above were deleted. We need</span><br>  <span class="hljs-comment">// to add them to the deletion list.</span><br>  existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child));<br>&#125;<br><br><span class="hljs-keyword">return</span> resultingFirstChild;<br></code></pre></td></tr></table></figure><p>首先，将所有还没遍历到的旧节点，添加到map里面。如果旧节点有key，那么就用key来当做map的key。如果旧节点没有key，那么就用index当做map的key。然后把fiber本身当做value，就这样把<code>(key，value)</code>对存进map里。</p><p>然后去遍历跳出循环后的新子节点，对于每个新子节点，从map里去找和它对应的旧子节点（依旧是有key用key，无key用index）。构建哈希表，并且通过哈希表查找，这里就是“慢匹配”额外的开销。</p><p>在找到旧节点后，其实是和第一部分顺序匹配的后续逻辑一样，都是根据旧节点去得到新节点。看新旧节点的类型是否一致，决定是复用，还是重新创建。</p><p>在生成newFiber后，需要通过<code>placeChild</code>方法，把新生成的节点视情况是否打上插入标记。这里的逻辑就比较复杂了，因为新和旧的顺序完全无法保证，是通过map里key来对应的，而不是index。</p><p>这里就涉及到<code>placeChild</code>真正复杂的场景了。因为此前，新旧节点都是一一对应的。而到了第三部分，旧节点是从map里用key取出来的，就没办法保证顺序了。所以，这时候就需要给部分新的子节点打上插入标记。</p><p>那么如何判断是否需要打插入标记，就是问题的关键了。如果说要当成两个数组的最小编辑距离来看，时间复杂度就有点不能接受了。而React则是采用了一种线性时间复杂度的贪心算法，其逻辑如下：在新的子节点数组中，一步步构建出出符合旧节点数组顺序的子序列，子序列中的这些节点就是不需要移动的，而不在子序列中的节点，则需要打上插入的标记（实际是需要移动这些节点，但是React 并不区分「这是全新的节点」还是「这是原来就有的节点、只是换了个位置」，只是把这个dom放到正确的位置上）。</p><p>我们可以看结合<code>placeChild</code>的源码和下面这张图，来表示一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">placeChild</span>(<span class="hljs-params"></span><br><span class="hljs-params">  newFiber: Fiber,</span><br><span class="hljs-params">  lastPlacedIndex: number,</span><br><span class="hljs-params">  newIndex: number,</span><br><span class="hljs-params"></span>): number &#123;<br>  newFiber.<span class="hljs-property">index</span> = newIndex;<br>  <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) &#123;<br>    <span class="hljs-comment">// During hydration, the useId algorithm needs to know which fibers are</span><br>    <span class="hljs-comment">// part of a list of children (arrays, iterators).</span><br>    newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Forked</span>;<br>    <span class="hljs-keyword">return</span> lastPlacedIndex;<br>  &#125;<br>  <span class="hljs-keyword">const</span> current = newFiber.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> oldIndex = current.<span class="hljs-property">index</span>;<br>    <span class="hljs-keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;<br>      <span class="hljs-comment">// This is a move.</span><br>      newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">PlacementDEV</span>;<br>      <span class="hljs-keyword">return</span> lastPlacedIndex;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// This item can stay in place.</span><br>      <span class="hljs-keyword">return</span> oldIndex;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// This is an insertion.</span><br>    newFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">PlacementDEV</span>;<br>    <span class="hljs-keyword">return</span> lastPlacedIndex;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="%E8%B4%AA%E5%BF%83%E5%AD%90%E5%BA%8F%E5%88%97.png"></p><p>上图中，红色的节点表示被添加到子序列中的节点。而蓝色的则是没能被添加到子序列中，而被打上插入标记的节点。</p><p>我们可以看到，react在遍历新子节点的时候，每遍历到一个子节点，都会看一下他能否加入到子序列的尾部，还保持原来的顺序。例如，[a,d]就是符合[a,b,c,d,e]顺序的一个子序列，所以d被加入进去了。对应的就是<code>lastPlacedIndex</code>被更新为d的<code>oldIndex</code>。而下一个新的子节点，c，没能被加入到子序列中，因为[a,d,c]不是符合[a,b,c,d,e]的顺序的子序列，所以新子节点c被打上了插入标记，b也同理。最后，[a,d,e]是符合[a,b,c,d,e]的，所以最后，a,d,e三个子节点是不需要移动的，而c和b则被打上了插入的标记，会被移动位置。这就是我认为diff算法中，最复杂的一个逻辑了。</p><p>最后，如果父组件是update而不是mount，就把map里的旧子组件全部删掉，因为新子组件里没有与它们对应的，说明他们在新一次渲染中不存在了。</p><p><strong>这是慢匹配阶段。</strong> 一旦第一部分顺序匹配中断，就会把所有剩余的旧子节点放入 Map，再逐个用新子节点去查找对应的旧节点。能复用则复用，不能复用则新建，并通过 <code>placeChild</code> 判断是否需要移动。</p><h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>前面我们说过了，<code>useFiber</code>就是从旧节点clone Fiber出来，相当于是复用。而<code>createFiberFromElement</code>则是重新创建Fiber Node。那么这两个的区别，究竟有多大呢？</p><p>我们可以看下<code>useFiber</code>的实现，它里面保留了旧Fiber上面的很多字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">workInProgress.<span class="hljs-property">flags</span> = current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">StaticMask</span>;<br>workInProgress.<span class="hljs-property">childLanes</span> = current.<span class="hljs-property">childLanes</span>;<br>workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;<br><br>workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;<br>workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;<br>workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;<br>workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>;<br></code></pre></td></tr></table></figure><p>而相应的，<code>createFiberFromElement</code>自然这些字段就都没有了。</p><p>那么这给我们带来了什么思考呢？我们知道，决定是执行<code>useFiber</code>还是<code>createFiberFromElement</code>，基本就是看key是否相同，和节点类型是否一致。那么我们经常看到React在开发环境下的一个warning，提示我们列表渲染需要给子元素加上key。那么是否加key，可能对列表造成什么影响呢？</p><p>我们以这个<a href="https://github.com/miku03090831/react-confusions-explain-demo">demo</a>里的代码来做个演示，我们本地启动这个demo，然后选择<code>Key Property Demo</code></p><p>我们有一个固定的list</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;a&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;b&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;d&quot;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><p>然后分别有四个场景，每个场景都是依据这个list，去map渲染出各自的child。然而，在每个child内部，又有着child自己维护的state。这个count是每个child各自独有的，应该是互相区分的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Child</span> = (<span class="hljs-params">&#123; name &#125;: &#123; name: string &#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">        setCount((count) =&gt; count + 1);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;&#123;`$&#123;name&#125;:$&#123;count&#125;`&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后四个场景，分别是</p><ol><li>无key</li><li>以数组index作为key</li><li>用完全随机数作为key</li><li>用独特的值，这里是用name作为key</li></ol><p>我们首先，点击各个按钮，得到下面这个状态</p><p><img src="%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png"></p><p>然后我们点击“反转列表”的按钮，变成了下面的状态</p><p><img src="%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8.png"></p><p>可以看到，只有第四个场景下的值是正确的，count依旧能和name对应起来。</p><p>前两个场景中，由于key使用的不正确，导致Fiber被错误的复用。Fiber复用的时候，会保留内部的hooks的状态，而它的子文本节点却在后来被单独更新掉。从而导致state维护的count，和name不能保持对应关系。</p><p>而第三个场景也是很搞笑，由于它的key是个随机数，每一次他重新渲染，所有的子节点都没办法复用，从而全部重新创建，进而丢失了hooks上的全部值。所以每一次重新渲染，第三个场景子元素的count全部都会归零。</p><p><img src="%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC.png"></p><p>如果你点击的是“浅拷贝重新赋值”的按钮，列表的实际内容没有变化，第三个场景也依旧会出现问题，因为子节点依旧无法匹配成功。而由于这次节点顺序没有变化，第一、二个场景是表现正确的。</p><p>所以我们可以看到，如果你列表的子组件，内部是有状态的，并且顺序是可能发生改变的（包括反转、中间插入等等），那么有一个唯一的key是非常有必要的，不然就会发生状态错位的问题。</p><p>但是如果你的列表的子组件并没有状态，甚至可能只是渲染一个文本，那么是否复用错误，或许并没有那么重要。因为即使div被错误的复用了，它的下一级的文本节点还是会被正常更新。</p><p>以上，可能就是了解了diff算法原理后，对我们带来的一些启示</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
      <tag>diff算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（三）：函数组件和hooks原理</title>
    <link href="/2025/07/29/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8Chooks%E5%8E%9F%E7%90%86/"/>
    <url>/2025/07/29/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8Chooks%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a></p></blockquote><p>上一篇我们讲了React构建fiber树的整体流程，即循环调用performUnitOfWork，里面穿插着beginWork和completeWork的调用，并且最后给出了简洁的伪代码实现。</p><p>那么这一篇呢，我们先看一下beginWork前半部分的逻辑。因为beginWork它的主要工作是渲染组件（此处的渲染即，我们平时所说的渲染，对于函数组件来说就是执行），并且根据返回的jsx，生成子节点。说到了渲染组件，我觉得这肯定是很多人最感兴趣的了。对于这么重量级的部分，我认为有必要牺牲一下学习的连贯性，把他吃透，这样反而更有利于加深我们对React的理解。</p><p>这一篇篇幅会很长，我会从beginWork入手，讲到React的hooks实现，并且以useReducer为例，讲一下React Hooks实现的原理，讲完了之后，下一篇再回来继续看beginWork的部分。</p><h1 id="beginWork里面的逻辑"><a href="#beginWork里面的逻辑" class="headerlink" title="beginWork里面的逻辑"></a>beginWork里面的逻辑</h1><h2 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h2><p>先看beginWork代码，依旧是去掉开发环境下的代码，和Profiler相关的代码。然后它里面有个switch case的逻辑，分支太多了，我就保留几个意思意思吧，想了解更多可以自己去看源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: Fiber | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  renderLanes: Lanes,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;<br>    <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br><br>    <span class="hljs-keyword">if</span> (<br>      oldProps !== newProps ||<br>      <span class="hljs-title function_">hasLegacyContextChanged</span>() ||<br>      (__DEV__ ? workInProgress.<span class="hljs-property">type</span> !== current.<span class="hljs-property">type</span> : <span class="hljs-literal">false</span>)<br>    ) &#123;<br>      didReceiveUpdate = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> hasScheduledUpdateOrContext = <span class="hljs-title function_">checkScheduledUpdateOrContext</span>(<br>        current,<br>        renderLanes,<br>      );<br>      <span class="hljs-keyword">if</span> (<br>        !hasScheduledUpdateOrContext &amp;&amp;<br>        (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span><br>      ) &#123;<br>        didReceiveUpdate = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(<br>          current,<br>          workInProgress,<br>          renderLanes,<br>        );<br>      &#125;<br>      <span class="hljs-keyword">if</span> ((current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ForceUpdateForLegacySuspense</span>) !== <span class="hljs-title class_">NoFlags</span>) &#123;<br>        didReceiveUpdate = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        didReceiveUpdate = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    didReceiveUpdate = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>() &amp;&amp; <span class="hljs-title function_">isForkedChild</span>(workInProgress)) &#123;<br>      <span class="hljs-keyword">const</span> slotIndex = workInProgress.<span class="hljs-property">index</span>;<br>      <span class="hljs-keyword">const</span> numberOfForks = <span class="hljs-title function_">getForksAtLevel</span>(workInProgress);<br>      <span class="hljs-title function_">pushTreeId</span>(workInProgress, numberOfForks, slotIndex);<br>    &#125;<br>  &#125;<br><br>  workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> elementType = workInProgress.<span class="hljs-property">elementType</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLazyComponent</span>(<br>        current,<br>        workInProgress,<br>        elementType,<br>        renderLanes,<br>      );<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>      <span class="hljs-keyword">const</span> resolvedProps =<br>        disableDefaultPropsExceptForClasses ||<br>        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span><br>          ? unresolvedProps<br>          : <span class="hljs-title function_">resolveDefaultPropsOnNonClassComponent</span>(<span class="hljs-title class_">Component</span>, unresolvedProps);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(<br>        current,<br>        workInProgress,<br>        <span class="hljs-title class_">Component</span>,<br>        resolvedProps,<br>        renderLanes,<br>      );<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>: &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;<br>      <span class="hljs-keyword">const</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>      <span class="hljs-keyword">const</span> resolvedProps = <span class="hljs-title function_">resolveClassComponentProps</span>(<br>        <span class="hljs-title class_">Component</span>,<br>        unresolvedProps,<br>        workInProgress.<span class="hljs-property">elementType</span> === <span class="hljs-title class_">Component</span>,<br>      );<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(<br>        current,<br>        workInProgress,<br>        <span class="hljs-title class_">Component</span>,<br>        resolvedProps,<br>        renderLanes,<br>      );<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostRoot</span>(current, workInProgress, renderLanes);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, renderLanes);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostText</span>(current, workInProgress);<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Throw</span>: &#123;<br>      <span class="hljs-comment">// This represents a Component that threw in the reconciliation phase.</span><br>      <span class="hljs-comment">// So we&#x27;ll rethrow here. This might be a Thenable.</span><br>      <span class="hljs-keyword">throw</span> workInProgress.<span class="hljs-property">pendingProps</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>删减了很多，但是依旧是很长。前面一大段不重要啊，就是判断这个组件是否需要重新渲染的。如果不需要重新渲染，就跳过了。值得提一嘴的就是前面那个<code>current!==null</code>，就是判断是初次渲染（mount），还是重新渲染（update）。因为初次渲染是没有current节点的，这一点前面我们讲current tree和workInProgress tree关系的时候，没有详细说，所以这次特别提一下。</p><p>直接看下面switch case那一段，就是根据fiber node的各种tag，去执行不同的操作。比如，对于函数组件，就去执行updateFunctionComponent这个方法。我们给他传入的入参，分别是current节点，workInProgress节点，函数组件本身（没错，对于函数组件，fiber节点的type字段就是这个函数本身，你可以随便本地起个React项目打断点看一下），组件的props，和这个组件的渲染优先级。</p><h2 id="updateFunctionComponent"><a href="#updateFunctionComponent" class="headerlink" title="updateFunctionComponent"></a>updateFunctionComponent</h2><p>看看对于函数组件干了什么，依旧是精简后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  current: <span class="hljs-literal">null</span> | Fiber,</span><br><span class="hljs-params">  workInProgress: Fiber,</span><br><span class="hljs-params">  Component: any,</span><br><span class="hljs-params">  nextProps: any,</span><br><span class="hljs-params">  renderLanes: Lanes,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> context;<br>  <span class="hljs-keyword">if</span> (!disableLegacyContext &amp;&amp; !disableLegacyContextForFunctionComponents) &#123;<br>    <span class="hljs-keyword">const</span> unmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">true</span>);<br>    context = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, unmaskedContext);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> nextChildren;<br>  <span class="hljs-keyword">let</span> hasId;<br>  <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);<br><br>  nextChildren = <span class="hljs-title function_">renderWithHooks</span>(<br>    current,<br>    workInProgress,<br>    <span class="hljs-title class_">Component</span>,<br>    nextProps,<br>    context,<br>    renderLanes,<br>  );<br>  hasId = <span class="hljs-title function_">checkDidRenderIdHook</span>();<br><br>  <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;<br>    <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>() &amp;&amp; hasId) &#123;<br>    <span class="hljs-title function_">pushMaterializedTreeId</span>(workInProgress);<br>  &#125;<br><br>  <span class="hljs-comment">// React DevTools reads this flag.</span><br>  workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;<br>  <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);<br>  <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面几行依旧不重要，是处理context 相关的。其实这个方法里最重要的就两个函数调用，一个是renderWithHooks，一个是reconcileChildren。它们分别完成了渲染组件，和生成子节点的任务。关于reconcileChildren，我们要很久之后再见了。接下来很大的篇幅，包括后面几篇，我都会讲renderWithHooks，和hooks的具体实现相关的内容。</p><h2 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h2><p>renderWithHooks的简要逻辑如下，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> renderWithHooks&lt;<span class="hljs-title class_">Props</span>, <span class="hljs-title class_">SecondArg</span>&gt;(<br>  <span class="hljs-attr">current</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">workInProgress</span>: <span class="hljs-title class_">Fiber</span>,<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-function">(<span class="hljs-params">p: Props, arg: SecondArg</span>) =&gt;</span> any,<br>  <span class="hljs-attr">props</span>: <span class="hljs-title class_">Props</span>,<br>  <span class="hljs-attr">secondArg</span>: <span class="hljs-title class_">SecondArg</span>,<br>  <span class="hljs-attr">nextRenderLanes</span>: <span class="hljs-title class_">Lanes</span>,<br>): any &#123;<br>  renderLanes = nextRenderLanes;<br>  currentlyRenderingFiber = workInProgress;<br><br>  workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;<br>  workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;<br>  workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br><br>  <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span> =<br>      current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">memoizedState</span> === <span class="hljs-literal">null</span><br>        ? <span class="hljs-title class_">HooksDispatcherOnMount</span><br>        : <span class="hljs-title class_">HooksDispatcherOnUpdate</span>;<br><br>  <span class="hljs-keyword">let</span> children = <span class="hljs-title class_">Component</span>(props, secondArg);<br><br>  <span class="hljs-keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;<br>    children = <span class="hljs-title function_">renderWithHooksAgain</span>(<br>      workInProgress,<br>      <span class="hljs-title class_">Component</span>,<br>      props,<br>      secondArg,<br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">finishRenderingHooks</span>(current, workInProgress, <span class="hljs-title class_">Component</span>);<br><br>  <span class="hljs-keyword">return</span> children;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单总结，就是首先把这个fiber节点的一些字段都清空，然后根据是mount还是update，分别给所有的hooks赋值上相应的实现。</p><p>然后就去执行这个函数，这个其实我们之前平时写React就知道，函数组件的渲染就是执行它本身嘛。你在函数组件里面写的代码，全会在此时被执行。</p><p>然后如果组件渲染过程中，又产生了新的更新，比如在函数体里面setState（虽然这是不对的），那么react会再重新render一遍，直到组件稳定了，不会在渲染过程中产生新的更新，或是重复调用太多次而报错。</p><p>最后，还原一下上下文，等着下一个组件来渲染。</p><p>我们可以先看一下给hooks添加上实现的那一段，也就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">H</span> =<br>    current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">memoizedState</span> === <span class="hljs-literal">null</span><br>      ? <span class="hljs-title class_">HooksDispatcherOnMount</span><br>      : <span class="hljs-title class_">HooksDispatcherOnUpdate</span>;<br></code></pre></td></tr></table></figure><p>我们直接去packages&#x2F;react目录下搜索一下hooks的实现，比如useReducer，能看到它的实现其实是<code>resolveDispatcher().useReducer(reducer, initialArg, init)</code>。而这个<code>resolveDispatcher</code>，其实就是直接返回了<code>ReactSharedInternals.H</code>。这个变量是定义在shared包里的，供React各个子包一起使用的。</p><p>而<code>HooksDispatcherOnMount</code>和<code>HooksDispatcherOnUpdate</code>，分别就是mount过程中和update过程中，全部hooks的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnMount</span>: <span class="hljs-title class_">Dispatcher</span> = &#123;<br>  readContext,<br><br>  use,<br>  <span class="hljs-attr">useCallback</span>: mountCallback,<br>  <span class="hljs-attr">useContext</span>: readContext,<br>  <span class="hljs-attr">useEffect</span>: mountEffect,<br>  <span class="hljs-attr">useImperativeHandle</span>: mountImperativeHandle,<br>  <span class="hljs-attr">useLayoutEffect</span>: mountLayoutEffect,<br>  <span class="hljs-attr">useInsertionEffect</span>: mountInsertionEffect,<br>  <span class="hljs-attr">useMemo</span>: mountMemo,<br>  <span class="hljs-attr">useReducer</span>: mountReducer,<br>  <span class="hljs-attr">useRef</span>: mountRef,<br>  <span class="hljs-attr">useState</span>: mountState,<br>  <span class="hljs-attr">useDebugValue</span>: mountDebugValue,<br>  <span class="hljs-attr">useDeferredValue</span>: mountDeferredValue,<br>  <span class="hljs-attr">useTransition</span>: mountTransition,<br>  <span class="hljs-attr">useSyncExternalStore</span>: mountSyncExternalStore,<br>  <span class="hljs-attr">useId</span>: mountId,<br>  <span class="hljs-attr">useHostTransitionStatus</span>: useHostTransitionStatus,<br>  <span class="hljs-attr">useFormState</span>: mountActionState,<br>  <span class="hljs-attr">useActionState</span>: mountActionState,<br>  <span class="hljs-attr">useOptimistic</span>: mountOptimistic,<br>  useMemoCache,<br>  <span class="hljs-attr">useCacheRefresh</span>: mountRefresh,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HooksDispatcherOnUpdate</span>: <span class="hljs-title class_">Dispatcher</span> = &#123;<br>  readContext,<br><br>  use,<br>  <span class="hljs-attr">useCallback</span>: updateCallback,<br>  <span class="hljs-attr">useContext</span>: readContext,<br>  <span class="hljs-attr">useEffect</span>: updateEffect,<br>  <span class="hljs-attr">useImperativeHandle</span>: updateImperativeHandle,<br>  <span class="hljs-attr">useInsertionEffect</span>: updateInsertionEffect,<br>  <span class="hljs-attr">useLayoutEffect</span>: updateLayoutEffect,<br>  <span class="hljs-attr">useMemo</span>: updateMemo,<br>  <span class="hljs-attr">useReducer</span>: updateReducer,<br>  <span class="hljs-attr">useRef</span>: updateRef,<br>  <span class="hljs-attr">useState</span>: updateState,<br>  <span class="hljs-attr">useDebugValue</span>: updateDebugValue,<br>  <span class="hljs-attr">useDeferredValue</span>: updateDeferredValue,<br>  <span class="hljs-attr">useTransition</span>: updateTransition,<br>  <span class="hljs-attr">useSyncExternalStore</span>: updateSyncExternalStore,<br>  <span class="hljs-attr">useId</span>: updateId,<br>  <span class="hljs-attr">useHostTransitionStatus</span>: useHostTransitionStatus,<br>  <span class="hljs-attr">useFormState</span>: updateActionState,<br>  <span class="hljs-attr">useActionState</span>: updateActionState,<br>  <span class="hljs-attr">useOptimistic</span>: updateOptimistic,<br>  useMemoCache,<br>  <span class="hljs-attr">useCacheRefresh</span>: updateRefresh,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Hooks的具体实现"><a href="#Hooks的具体实现" class="headerlink" title="Hooks的具体实现"></a>Hooks的具体实现</h1><p>我们在上面renderWithHooks里面看到了<code>let children = Component(props, secondArg);</code>这行代码，它会渲染我们的函数组件，即执行函数本身。执行的时候，·你在函数组件里面写的各种hooks，就被替换成上面hooks的具体实现来执行。</p><p><img src="hook%E7%9A%84%E6%9B%BF%E6%8D%A2.png"></p><p>那么我们这一篇，就以useReducer为例，来看一看Hooks的原理和具体实现，看看它在组件渲染的过程中做了什么。选useReducer是因为，最常用的Hooks是useState，而useState是useReducer的一种特殊场景，相信看到这里的也都熟悉useReducer。所以我们选择更具通用性的useReducer来研究（而且useState完全是通过调用useReducer来实现的）。</p><h2 id="mountReducer"><a href="#mountReducer" class="headerlink" title="mountReducer"></a>mountReducer</h2><p>当函数组件首次渲染，即mount的时候，对于组件里的useReducer hook，执行的就是mountReducer。简单来讲，就是把hook挂到fiber上面</p><p>我们来看看mountReducer具体是怎么实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> mountReducer&lt;S, I, A&gt;(<br>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">S, A</span>) =&gt;</span> S,<br>  <span class="hljs-attr">initialArg</span>: I,<br>  init?: <span class="hljs-function"><span class="hljs-params">I</span> =&gt;</span> S,<br>): [S, <span class="hljs-title class_">Dispatch</span>&lt;A&gt;] &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-comment">//太长啦等下再看</span><br>  <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];<br>&#125;<br></code></pre></td></tr></table></figure><p>首先第一行就是一个看名字就很重要的函数调用，<code>mountWorkInProgressHook</code>。那我们不得不再去看看它的实现了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountWorkInProgressHook</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Hook</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">hook</span>: <span class="hljs-title class_">Hook</span> = &#123;<br>    <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 当前实际的state（即useReducer返回的第一个参数）</span><br><br>    <span class="hljs-attr">baseState</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 如果有低优先级更新被打断，记录被打断之前的state</span><br>    <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">// 如果有低优先级更新被打断，则从这个更新开始，记录后续所有的更新</span><br>      <span class="hljs-comment">// 和baseState一起，用于当低优先级更新被恢复执行的时候，基于baseState，执行                       // baseQueue上所有的更新，从而计算出正确的状态</span><br>    <span class="hljs-attr">queue</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 待执行的更新相关的内容</span><br><br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// fiber节点的下一个hook</span><br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// This is the first hook in the list</span><br>    currentlyRenderingFiber.<span class="hljs-property">memoizedState</span> = workInProgressHook = hook;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Append to the end of the list</span><br>    workInProgressHook = workInProgressHook.<span class="hljs-property">next</span> = hook;<br>  &#125;<br>  <span class="hljs-keyword">return</span> workInProgressHook;<br>&#125;<br></code></pre></td></tr></table></figure><p>还好它并不长，他只是定义了一个新的hook对象，每个字段的含义我都在注释里写了。其中baseState和baseQueue如果看不懂的话可以先略过，这个和React的并发更新有关，后面会细讲，不用现在死磕。</p><p>然后workInProgressHook是一个全局对象，是一个链表。它会在合适的时候被清空。如果它是null，那就代表当前这个Fiber节点上还没有hook，那么我们就要把hook挂到Fiber节点的<code>memoizedState</code>字段上。</p><p>注意，这里的memoizedState和上面hook对象里的memoizedState，并没有关系，只是同名而已。一个代表Fiber的hooks链表，一个代表hook的state。</p><p>我们以一个很简单的react组件举例子，它用了两个useReducer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 计数器reducer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;inc&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dec&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 显隐reducer</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleReducer</span>(<span class="hljs-params">state</span>) &#123;<br>  <span class="hljs-keyword">return</span> !state;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DoubleReducerDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, dispatchCount] = <span class="hljs-title function_">useReducer</span>(countReducer, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [show, toggleShow] = <span class="hljs-title function_">useReducer</span>(toggleReducer, <span class="hljs-literal">true</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> toggleShow()&#125;&gt;Toggle Counter<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      &#123;show &amp;&amp; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchCount(&#123; type: &#x27;inc&#x27; &#125;)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatchCount(&#123; type: &#x27;dec&#x27; &#125;)&#125;&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      )&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>那么当它插入第一个hook的时候，结构是这样的</p><p><img src="%E7%AC%AC%E4%B8%80%E4%B8%AAhook.png"></p><p>如果workInProgressHook不是null，则说明这个Fiber节点上面已经有hooks了。<code>workInProgressHook = workInProgressHook.next = hook;</code>相当于<code>workInProgressHook.next = hook;workInProgressHook = workInProgressHook.next;</code>这样两句话，意思就是把刚创建好的hook插入到链表的尾部，并且更新链表的尾节点，便于下一次插入。</p><p>也就是说，fiber里面的hooks的结构是这样的：<br><img src="%E7%AC%AC%E4%BA%8C%E4%B8%AAhook.png"></p><p>最后，这个方法返回了刚才新创建好的这个hook</p><p>然后再回去看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> mountReducer&lt;S, I, A&gt;(<br>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">S, A</span>) =&gt;</span> S,<br>  <span class="hljs-attr">initialArg</span>: I,<br>  init?: <span class="hljs-function"><span class="hljs-params">I</span> =&gt;</span> S,<br>): [S, <span class="hljs-title class_">Dispatch</span>&lt;A&gt;] &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();<br>  <span class="hljs-keyword">let</span> initialState;<br>  <span class="hljs-keyword">if</span> (init !== <span class="hljs-literal">undefined</span>) &#123;<br>    initialState = <span class="hljs-title function_">init</span>(initialArg);<br>    <span class="hljs-keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;<br>      <span class="hljs-title function_">setIsStrictModeForDevtools</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-title function_">init</span>(initialArg);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-title function_">setIsStrictModeForDevtools</span>(<span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    initialState = ((<span class="hljs-attr">initialArg</span>: any): S);<br>  &#125;<br>  hook.<span class="hljs-property">memoizedState</span> = hook.<span class="hljs-property">baseState</span> = initialState;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;<br>    <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">NoLanes</span>,<br>    <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">lastRenderedReducer</span>: reducer,<br>    <span class="hljs-attr">lastRenderedState</span>: (<span class="hljs-attr">initialState</span>: any),<br>  &#125;;<br>  hook.<span class="hljs-property">queue</span> = queue;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dispatch</span>: <span class="hljs-title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="hljs-property">dispatch</span> = (dispatchReducerAction.<span class="hljs-title function_">bind</span>(<br>    <span class="hljs-literal">null</span>,<br>    currentlyRenderingFiber,<br>    queue,<br>  ): any));<br>  <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就比较贴合我们对useReducer的认知了，根据初始值和初始函数，算出一个initialState。然后把这个值，同时赋给<code>hook.memoizedState</code>和<code>hook.baseState</code>。接下来，再给<code>hook.queue</code>和<code>dispatch</code>赋值，然后<code>return [hook.memoizedState, dispatch];</code>，就结束了。</p><p>我们先来看一下给queue赋值的地方，我依旧是用注释，说明一下各个字段的含义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;<br>    <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 存放update的数组，表示待处理的更新</span><br>    <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">NoLanes</span>, <span class="hljs-comment">// 这个hook的优先级</span><br>    <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//更新的方法</span><br>    <span class="hljs-attr">lastRenderedReducer</span>: reducer, <br>    <span class="hljs-attr">lastRenderedState</span>: (<span class="hljs-attr">initialState</span>: any),<br>  &#125;;<br></code></pre></td></tr></table></figure><p>最下面两个字段的含义顾名思义，但是我看useReducer里面好像没看到哪里用到它，所以不清楚实际作用是什么，暂时略过吧。</p><p>然后我们看下面的dispatch方法，是给<code>dispatchReducerAction</code>方法绑死了currentlyRenderingFiber和queue参数。我们可以看看他的具体实现，略过开发环境的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> dispatchReducerAction&lt;S, A&gt;(<br>  <span class="hljs-attr">fiber</span>: <span class="hljs-title class_">Fiber</span>,<br>  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;S, A&gt;,<br>  <span class="hljs-attr">action</span>: A,<br>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">update</span>: <span class="hljs-title class_">Update</span>&lt;S, A&gt; = &#123;<br>    lane, <span class="hljs-comment">//优先级</span><br>    <span class="hljs-attr">revertLane</span>: <span class="hljs-title class_">NoLane</span>, <span class="hljs-comment">//revert它的优先级，和乐观更新有关</span><br>    action, <span class="hljs-comment">//具体的更新方法</span><br>    <span class="hljs-attr">hasEagerState</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//是否可以直接复用上一次的值</span><br>    <span class="hljs-attr">eagerState</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 上一次的值（如果可复用，就无需再计算）</span><br>    <span class="hljs-attr">next</span>: (<span class="hljs-attr">null</span>: any), <span class="hljs-comment">// 下一个update</span><br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRenderPhaseUpdate</span>(fiber)) &#123;<br>    <span class="hljs-title function_">enqueueRenderPhaseUpdate</span>(queue, update);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">enqueueConcurrentHookUpdate</span>(fiber, queue, update, lane);<br>    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">startUpdateTimerByLane</span>(lane);<br>      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(root, fiber, lane);<br>      <span class="hljs-title function_">entangleTransitionUpdate</span>(root, queue, lane);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法其实就是reducer的第二个参数，常见的dispatch，我们调用它去改变状态。他所做的事情，就是创建一个update对象，然后把这个update推到queue里面。具体逻辑我们暂不深究，等后面讲到相关的部分再来细讲。</p><p>也就是说，hook里面的主要结构是这样的</p><p><img src="%E7%AC%AC%E4%B8%80%E4%B8%AAhook%E7%9A%84%E5%AD%97%E6%AE%B5.png"></p><h2 id="updateReducer"><a href="#updateReducer" class="headerlink" title="updateReducer"></a>updateReducer</h2><p>当函数组件重新渲染的时候，再执行到这个hook的时候，就会执行updateReducer。我们看看updateReducer执行了什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> updateReducer&lt;S, I, A&gt;(<br>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">S, A</span>) =&gt;</span> S,<br>  <span class="hljs-attr">initialArg</span>: I,<br>  init?: <span class="hljs-function"><span class="hljs-params">I</span> =&gt;</span> S,<br>): [S, <span class="hljs-title class_">Dispatch</span>&lt;A&gt;] &#123;<br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateReducerImpl</span>(hook, ((<span class="hljs-attr">currentHook</span>: any): <span class="hljs-title class_">Hook</span>), reducer);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比mountReducer，一开始从<code>mountWorkInProgressHook</code>,变成了<code>updateWorkInProgressHook</code>。<code>mountWorkInProgressHook</code>是在组件mount的时候，把每一个hook都挂到fiber上面。而updateReducer，则是从current fiber上，把所有的hook都copy到workInProgress fiber上面。</p><p>为了节省篇幅，具体代码就不看了。代码也不复杂，抛去各种容错的代码，其实就是遍历一个老链表，把每个节点都加到新链表的末尾（每个hook节点都是新创建的字面量，但是这个节点的各个字段，例如memoizedState，和queue都和老节点值相等）</p><p>下面的<code>updateReducerImpl</code>是重头戏，它包含了useReducer最核心，也是最复杂的代码。里面为了处理可中断渲染，并发更新的逻辑，写得很复杂。我们可能关注核心逻辑，对于较为复杂的逻辑，我们简单讲解，但不花太多口舌。等到后面讲到React 18开始的新API的时候，涉及到并发渲染，我们再来详细讲吧。</p><p>对于大篇幅的代码，我们分段来看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> updateReducerImpl&lt;S, A&gt;(<br>  <span class="hljs-attr">hook</span>: <span class="hljs-title class_">Hook</span>,<br>  <span class="hljs-attr">current</span>: <span class="hljs-title class_">Hook</span>,<br>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">S, A</span>) =&gt;</span> S,<br>): [S, <span class="hljs-title class_">Dispatch</span>&lt;A&gt;] &#123;<br>  <span class="hljs-keyword">const</span> queue = hook.<span class="hljs-property">queue</span>;<br>  <span class="hljs-comment">// The last rebase update that is NOT part of the base state.</span><br>  <span class="hljs-keyword">let</span> baseQueue = hook.<span class="hljs-property">baseQueue</span>;<br><br>  <span class="hljs-comment">// The last pending update that hasn&#x27;t been processed yet.</span><br>  <span class="hljs-keyword">const</span> pendingQueue = queue.<span class="hljs-property">pending</span>;<br>  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// We have new updates that haven&#x27;t been processed yet.</span><br>    <span class="hljs-comment">// We&#x27;ll add them to the base queue.</span><br>    <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// Merge the pending queue and the base queue.</span><br>      <span class="hljs-keyword">const</span> baseFirst = baseQueue.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">const</span> pendingFirst = pendingQueue.<span class="hljs-property">next</span>;<br>      baseQueue.<span class="hljs-property">next</span> = pendingFirst;<br>      pendingQueue.<span class="hljs-property">next</span> = baseFirst;<br>    &#125;<br>    current.<span class="hljs-property">baseQueue</span> = baseQueue = pendingQueue;<br>    queue.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-comment">// 以下部分先省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先拿到了<code>hook.queue.pending</code>，记作<code>pengingQueue</code>，里面的内容是这一次新增的update。然后拿到了<code>hook.baseQueue</code>记作<code>baseQueue</code>，里面的内容是上一次渲染的时候因为优先级不够，而没有被执行的update。</p><p>简单提一下，React18开始，部分API可以使得update的优先级变低，从而使得主线程优先完成高优先级的渲染，之后有时间了再来完成低优先级的更新。所以低优先级的更新会被暂存在baseQueue里。</p><p><code>pendingQueue</code>和<code>baseQueue</code>的结构，都是一个环形链表，并且这两个变量都指向环形链表的尾节点。也就是说，<code>pendingQueue/baseQueue</code>是环形链表的尾，<code>pendingQueue.next/baseQueue.next</code>是环形链表的头。</p><p>这里之所以用这样的数据结构来记录update，是因为这里是一个经常需要在尾部插入的场景。如果用普通的单链表，记录头节点的话，那么在尾部插入的时间复杂度是O(n)。而如果使用环形链表，并且记录尾节点，则在尾部插入的时间复杂度则是O(1)。同时，由于它是个环，那么从尾部找到它的头，并且从头开始遍历，也很简单，几乎和普通单链表没有差距。如下图</p><p><img src="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.png"></p><p>而上面那一大段代码，就是把baseQueue和pendingQueue做一个合并。把这次新增的，加到上一次遗留后面，并且保证遍历的时候，先遍历到上一次遗留的。这很合理，先来后到。下面的图演示了两个环形链表如何合并成一个新的环形链表。且永远用环形链表的尾指针来表示这个链表。</p><p>我们看下面这张图，来理解一下上面合并两个环形链表的代码</p><p><img src="%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.png"></p><p>合并完毕后，将<code>current.baseQueue</code>,<code>baseQueue</code>,<code>pendingQueue</code>都指向pendingQueue，得到一个新的环形链表。这个环形链表的头节点，是原来的baseFirst。这样遍历这个链表的时候，就会先遍历到原来baseQueue的内容，然后再遍历到pendingQueue上面的内容，保证了先来后到。</p><p>我们继续看下面的代码。两个环形链表已经拼接完了，就该遍历链表，逐个取出update去更新了。这里代码实在太多，我不逐行讲解了，而是在关键位置加上注释。在后面只做简短的讲解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> updateReducerImpl&lt;S, A&gt;(<br>  <span class="hljs-attr">hook</span>: <span class="hljs-title class_">Hook</span>,<br>  <span class="hljs-attr">current</span>: <span class="hljs-title class_">Hook</span>,<br>  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">S, A</span>) =&gt;</span> S,<br>): [S, <span class="hljs-title class_">Dispatch</span>&lt;A&gt;] &#123;<br>  <span class="hljs-keyword">const</span> baseState = hook.<span class="hljs-property">baseState</span>;<br>  <span class="hljs-keyword">if</span> (baseQueue === <span class="hljs-literal">null</span>) &#123;<br>    hook.<span class="hljs-property">memoizedState</span> = baseState;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// We have a queue to process.</span><br>    <span class="hljs-keyword">const</span> first = baseQueue.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">let</span> newState = baseState;<br><br>    <span class="hljs-keyword">let</span> newBaseState = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> newBaseQueueFirst = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">newBaseQueueLast</span>: <span class="hljs-title class_">Update</span>&lt;S, A&gt; | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> update = first;<br>    <span class="hljs-keyword">let</span> didReadFromEntangledAsyncAction = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 开始遍历</span><br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">const</span> updateLane = <span class="hljs-title function_">removeLanes</span>(update.<span class="hljs-property">lane</span>, <span class="hljs-title class_">OffscreenLane</span>);<br>      <span class="hljs-keyword">const</span> isHiddenUpdate = updateLane !== update.<span class="hljs-property">lane</span>;<br><br>      <span class="hljs-comment">// 看updateLane是不是左边lane的子集</span><br>      <span class="hljs-keyword">const</span> shouldSkipUpdate = isHiddenUpdate<br>        ? !<span class="hljs-title function_">isSubsetOfLanes</span>(<span class="hljs-title function_">getWorkInProgressRootRenderLanes</span>(), updateLane)<br>        : !<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane);<br><br>      <span class="hljs-comment">// update的优先级低，这次跳过</span><br>      <span class="hljs-keyword">if</span> (shouldSkipUpdate) &#123;<br>        <span class="hljs-comment">// 拷贝一个当前update，存到新的newBaseQueue里面（遗留，作为下一次渲染的baseQueue）</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">clone</span>: <span class="hljs-title class_">Update</span>&lt;S, A&gt; = &#123;<br>          <span class="hljs-attr">lane</span>: updateLane,<br>          <span class="hljs-attr">revertLane</span>: update.<span class="hljs-property">revertLane</span>,<br>          <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,<br>          <span class="hljs-attr">hasEagerState</span>: update.<span class="hljs-property">hasEagerState</span>,<br>          <span class="hljs-attr">eagerState</span>: update.<span class="hljs-property">eagerState</span>,<br>          <span class="hljs-attr">next</span>: (<span class="hljs-attr">null</span>: any),<br>        &#125;;<br>        <span class="hljs-comment">// newBaseQueue为空，则创建一个环形链表</span><br>        <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) &#123;<br>          newBaseQueueFirst = newBaseQueueLast = clone;<br>          newBaseState = newState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// newBaseQueue不为空，则往环形链表尾部插入一个节点（这里只是插入尾部，不用每插一个就重新成  // 环。等循环结束了所有节点都插入完毕了，再让新尾部指回头部，组成环形结构）</span><br>          newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = clone;<br>        &#125;<br>        currentlyRenderingFiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(<br>          currentlyRenderingFiber.<span class="hljs-property">lanes</span>,<br>          updateLane,<br>        );<br>        <span class="hljs-title function_">markSkippedUpdateLanes</span>(updateLane);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 本次要执行这个update</span><br>        <span class="hljs-keyword">const</span> revertLane = update.<span class="hljs-property">revertLane</span>;<br>        <span class="hljs-keyword">if</span> (revertLane === <span class="hljs-title class_">NoLane</span>) &#123;<br>          <span class="hljs-comment">// 特别地，如果newBaseQueue已经不为空了，即前面已经有update被跳过，那么虽然当前update会被           // 执行，也依旧要把它拷贝一份，放到newBaseQueue尾部。这个原因会在后面讲解</span><br>          <span class="hljs-keyword">if</span> (newBaseQueueLast !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">clone</span>: <span class="hljs-title class_">Update</span>&lt;S, A&gt; = &#123;<br>              <span class="hljs-attr">lane</span>: <span class="hljs-title class_">NoLane</span>,<br>              <span class="hljs-attr">revertLane</span>: <span class="hljs-title class_">NoLane</span>,<br>              <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,<br>              <span class="hljs-attr">hasEagerState</span>: update.<span class="hljs-property">hasEagerState</span>,<br>              <span class="hljs-attr">eagerState</span>: update.<span class="hljs-property">eagerState</span>,<br>              <span class="hljs-attr">next</span>: (<span class="hljs-attr">null</span>: any),<br>            &#125;;<br>            newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = clone;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (updateLane === <span class="hljs-title function_">peekEntangledActionLane</span>()) &#123;<br>            didReadFromEntangledAsyncAction = <span class="hljs-literal">true</span>;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// 这里也略吧，太长了。。</span><br>        &#125;<br><br>        <span class="hljs-comment">// 执行传进来的更新行为，计算出这个update后新的state</span><br>        <span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;<br>        <span class="hljs-keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;<br>          <span class="hljs-title function_">reducer</span>(newState, action);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (update.<span class="hljs-property">hasEagerState</span>) &#123;<br>          newState = ((update.<span class="hljs-property">eagerState</span>: any): S);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          newState = <span class="hljs-title function_">reducer</span>(newState, action);<br>        &#125;<br>      &#125;<br>      update = update.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);<br><br>    <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) &#123;<br>      newBaseState = newState;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// newBaseQueue不为空，则让尾指向头，重新形成环形链表</span><br>      newBaseQueueLast.<span class="hljs-property">next</span> = (<span class="hljs-attr">newBaseQueueFirst</span>: any);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">is</span>(newState, hook.<span class="hljs-property">memoizedState</span>)) &#123;<br>      <span class="hljs-title function_">markWorkInProgressReceivedUpdate</span>();<br><br>      <span class="hljs-keyword">if</span> (didReadFromEntangledAsyncAction) &#123;<br>        <span class="hljs-keyword">const</span> entangledActionThenable = <span class="hljs-title function_">peekEntangledActionThenable</span>();<br>        <span class="hljs-keyword">if</span> (entangledActionThenable !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> entangledActionThenable;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    hook.<span class="hljs-property">memoizedState</span> = newState;<br>    hook.<span class="hljs-property">baseState</span> = newBaseState;<br>    hook.<span class="hljs-property">baseQueue</span> = newBaseQueueLast;<br><br>    queue.<span class="hljs-property">lastRenderedState</span> = newState;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看他这里的逻辑，主要就是遍历<code>baseQueue</code>，逐个取出里面的update。每个update有它自己的lane（优先级），我们前面已经看过了。这里的lane是用二进制位来表示的一个数字。用二进制来表示，就是为了能直观的看出位运算的结果。判断update是否要在这次渲染执行，就是看update的lane是否属于这次renderLanes的子集（即updateLane &amp; renderLanes &#x3D;&#x3D;&#x3D; updateLane?）。</p><p>如果优先级不属于这次渲染，那么就放到<code>newBaseQueue</code>里。我们上一part看到的baseQueue，说了含义是上一次渲染遗留的update，其实就是这么来的。</p><p>然后有个比较难懂的逻辑，就是虽然这个update优先级是要在这次执行的，但是当<code>newBaseQueue</code>不为空的时候，也要把这个update加进去。这个就和React的并发渲染有关。React的更新是有优先级的，比如如果你普通的<code>useReducer</code>，那么它就是高优先级。如果你用<code>startTransition</code>包裹了<code>useReducer</code>，那么它就是低优先级。</p><p>如果你像下面这样写，点击一次按钮的时候，会有两次更新。只不过一次是低优先级，一次是高优先级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onClick = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">dispatchNum</span>(<span class="hljs-function"><span class="hljs-params">n</span>=&gt;</span>n+<span class="hljs-number">2</span>)<br>    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">dispatchNum</span>(<span class="hljs-number">3</span>)<br>    &#125;)<br>    <span class="hljs-title function_">dispatchNum</span>(<span class="hljs-function"><span class="hljs-params">n</span>=&gt;</span>n+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>假设num初始值是0。我们只想最终结果，num应该是4。因为startTransition对于最终结果是不应该产生影响的。如果你为了性能优化，而影响了结果，谁还敢用呢？<br>那么第一次渲染，是高优先级的渲染，会先执行一次+2，在执行一次+1，此时n是3。然后第二次渲染，终于要执行低优先级的了。可这个低优先级的更新，是将num设为3，那这样是不是不太对，凑不成4？</p><p>所以他的真正逻辑是这样的。第一次渲染，先执行+2。然后等遍历到低优先级update的时候，发现这个update优先级不够了，于是把他存入<code>newBaseQueue</code>。同时，把当前的结果记作newBaseState，作为基准。意思就是，在此之前，所有的update都没有被跳过，执行完他们的状态是newBaseState。等以后在遍历的时候，不用管前面的update了，从第一个被跳过的update开始遍历，把newBaseState当做初始值就可以了。接着遍历第三个update，执行它，并且将它也推入到<code>newBaseQueue</code>。</p><p>那么第一遍高优先级渲染执行完，state是3（0+2+1），让用户临时看到了高优先级的结果。并且newBaseState是2，newBaseQueue里分别是“设为3”和“+1”两个更新。第二遍执行的时候，会以newBaseState作为基准，然后把<code>newBaseQueue</code>里面的所有更新都重新执行一遍。这里面会有更新被重复执行。最终第二遍渲染执行完之后，state就是最终结果4了（2&#x3D;&gt;3+1)</p><p>那么以上，就是useReducer的逻辑</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（二）：构建Fiber tree的流程</title>
    <link href="/2025/07/26/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BAFiber-tree%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/07/26/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E5%BB%BAFiber-tree%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码以React v19.1.0为例，<a href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a></p></blockquote><p>今天开始我们开始研究React的源码。我们先关注构建Fiber tree相关的内容。</p><p>这篇要涉及到beginWork和completeWork的过程，我认为其他的教程此处讲的都比较简略，重点放在了两个方法的内部，而不是两个方法是怎么被调用的。大多数教程说，beginWork是“递”的过程，而“completeWork”是归的过程。然而二者并不是简单的先递后归，而是会交替进行。而我为了让大家能尽量抓住重点，从而快速对构建Fiber的流程有一个认知，可能不会遇到一个方法，就去详细讲它。希望我的这篇文章能对读者有所帮助</p><h1 id="workLoopConcurrentByScheduler-x2F-workLoopConcurrent-x2F-workLoopSync"><a href="#workLoopConcurrentByScheduler-x2F-workLoopConcurrent-x2F-workLoopSync" class="headerlink" title="workLoopConcurrentByScheduler&#x2F;workLoopConcurrent&#x2F;workLoopSync"></a>workLoopConcurrentByScheduler&#x2F;workLoopConcurrent&#x2F;<strong>workLoopSync</strong></h1><p>多的不说，我们直接从<strong>workLoopConcurrentByScheduler</strong>&#x2F;<strong>workLoopConcurrent</strong>&#x2F;<strong>workLoopSync</strong>开始看，这三个就是去循环遍历Fiber tree，构建Fiber节点的方法。至于哪里调用的它们，我们先不管，都讲到scheduler的时候再来看吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Perform work without checking if we need to yield between fiber.</span><br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrent</span>(<span class="hljs-params">nonIdle: boolean</span>) &#123;<br>  <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> yieldAfter = <span class="hljs-title function_">now</span>() + (nonIdle ? <span class="hljs-number">25</span> : <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// $FlowFixMe[incompatible-call] flow doesn&#x27;t know that now() is side-effect free</span><br>      <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>    &#125; <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">now</span>() &lt; yieldAfter);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrentByScheduler</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) &#123;<br>    <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，三个方法其实区别不大，都是去循环执行performUnitOfWork(workInProgress)。workInProgress在我们讲的时候，可以指正在被构建的那棵Fiber tree。但是在源码里面，更多的时候，它特指workInProgress树上面<strong>当前正遍历到的那个节点</strong>。它是一个全局变量，如果这个节点遍历完了，那么就会把它赋值成刚才节点的child之类的。</p><p>workInProgress !&#x3D;&#x3D; null其实就是判断当前这棵树有没有构建完毕，为null就表示构建完了，结束循环。</p><p>三个方法的区别就是，workLoopConcurrent和workLoopConcurrentByScheduler每次循环的时候，会判断一下当前是否到了预设的时间，到了就打断，等下一次再被调度，继续循环。就跟我们上一篇举例的那道面试题很像。这里workInProgress这个全局变量就记录了中断的时候，我们遍历到哪个节点。</p><p>workLoopConcurrentByScheduler里面的shouldYield，来自scheduler这个包，功能可以简单理解为经过了5ms就返回true。</p><p>至于workLoopConcurrent里面的noIdle，是React最近新加的代码。原本只有sync和concurrent（现在被改叫workLoopConcurrentByScheduler）两种逻辑的，即固定不打断和每5ms打断一次。</p><p>而React在尝试一种新逻辑，它觉得原来每次5ms打断一次太频繁了，于是在大部分场景下延长了时间，就是现在的workLoopConcurrent逻辑。大部分场景下，React会给自己留25ms的时间去循环。也就是注释里说的，浏览器的主线程有些工作太频繁了（例如动画），可能让React的执行在调度中被饿死，所以给自己多留点时间，大不了就让浏览器帧数低一点。而在没那么紧急的场景下，React将自己每次循环的时间上限缩短到5ms，让浏览器能渲染更多帧。</p><h1 id="performUnitOfWork"><a href="#performUnitOfWork" class="headerlink" title="performUnitOfWork"></a>performUnitOfWork</h1><p>从上面我们就更可以看出，performUnitOfWork是构建Fiber tree的核心了，循环去执行这个方法嘛。从名字上来看，他就是执行了一个工作单元。这么说起来还是比较抽象，我们看下它源码的主要部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-comment">// The current, flushed, state of this fiber is the alternate. Ideally</span><br>  <span class="hljs-comment">// nothing should rely on this, but relying on it here means that we don&#x27;t</span><br>  <span class="hljs-comment">// need an additional field on the work in progress.</span><br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br><br>  <span class="hljs-keyword">let</span> next;<br>  <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; (unitOfWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) &#123;<br>    <span class="hljs-comment">// 省略，和React DevTools里面的Profiler相关。</span><br>    <span class="hljs-comment">// Profiler会记录组件渲染了多少次，每次渲染的耗时，和引起重新渲染的原因等等，对排查性能问题很有帮助</span><br>    <span class="hljs-comment">// 但是生产build不会开启这个功能</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>      <span class="hljs-comment">// 开发环境，省略不看</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br>    &#125;<br>  &#125;<br><br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// If this doesn&#x27;t spawn new work, complete the current work.</span><br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们对于源码抓大放小，从总体上把握流程，而不是拘泥于每个分支。因此我们主要看生产环境下会走到的代码，以及影响流程的部分。精简一下，代码变得更简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br><br>  <span class="hljs-keyword">let</span> next;<br>  next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, entangledRenderLanes);<br><br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用精简后的代码，结合上一篇中的图，去体会一下上一篇理论知识中Fiber tree遍历的过程</p><img src="fiber树.png" style="display: block; margin: 0 auto;" width="300"><p>我们去梳理一下代码的意义。假设performUnitOfWork传入的Fiber node是A，然后beginWork会通过A和A.alternate（即current树中，A对应的节点），构建一个A的子节点（next）返回。对图中而言，next就是B。子节点是存在的，那么将workInProgress赋值为B，这一次循环结束，下一次循环会执行performUnitOfWork(B)</p><p>也就是会先执行图中的1和2。然后当performUnitOfWork(C)时，next是null了，因为C没有子节点了。这个时候，会执行completeUnitOfWork(C)</p><h1 id="completeUnitOfWork"><a href="#completeUnitOfWork" class="headerlink" title="completeUnitOfWork"></a>completeUnitOfWork</h1><p>执行到这里，想知道发生了什么，就不得不去看completeUnitOfWork的代码了。下面是精简过后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Attempt to complete the current unit of work, then move to the next</span><br><span class="hljs-comment">// sibling. If there are no more siblings, return to the parent fiber.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork: Fiber</span>): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">completedWork</span>: <span class="hljs-title class_">Fiber</span> = unitOfWork;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">const</span> current = completedWork.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">const</span> returnFiber = completedWork.<span class="hljs-property">return</span>;<br><br>    <span class="hljs-keyword">let</span> next;<br><br>    next = <span class="hljs-title function_">completeWork</span>(current, completedWork, entangledRenderLanes);<br>    <br><span class="hljs-comment">// 这是针对Suspense组件的，暂时可以不看</span><br>    <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) &#123;<br>      workInProgress = next;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> siblingFiber = completedWork.<span class="hljs-property">sibling</span>;<br>    <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) &#123;<br>      workInProgress = siblingFiber;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    completedWork = returnFiber;<br><br>    workInProgress = completedWork;<br>  &#125; <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootInProgress</span>) &#123;<br>    workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看上述代码，是有一个循环的，也就是completedWork不为null之前一直执行。此处开始从自己往兄弟、父节点开始遍历。首先对自己执行了completeWork，然后拿到了自己的子节点。如果有子节点，那么将workInProgress赋值为自己的兄弟节点，然后结束当前循环。通常来讲，由于beginWork已经检查了是否有子节点，有的话不会进到complete的流程里面来。通常来讲，只有使用Suspense等特殊场景，才会进到这个分支里去。对于C来说，他没有子节点，不会进入这个循环。</p><p>然后取C的兄弟节点，取到了D，则会将workInProgress赋值为D，结束当前循环。等下一次循环的时候，执行performUnitWork(D)，流程和前面讲过的一样。</p><p>而如果当前节点没有兄弟节点了，例如E，则会将遍历的对象设为父节点，对父节点执行completeWork，重复这个循环。对于D,E这两个节点来说，顺序就是begin D-&gt;begin E-&gt;complete E-&gt;complete D。</p><p>最后，构建流程会回到Fiber的根节点，构建结束。</p><p>结合performUnitWork和completeUnitOfWork两个方法，用自然语言描述Fiber树的构建流程就是，有子节点就遍历子节点，没有子节点了去找右兄弟节点。兄弟节点也没有了，就回到父节点。</p><p>用伪代码来描述（略去complete里重复验证子节点的那一部分），省略函数实参中可计算出来的入参和不重要的入参，可以如下表述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">function performUnitOfWork(node)&#123;<br>child = beginWork(node) // 返回子节点<br><br>if(child)&#123;<br>workInProgress = child<br>return //下一次循环<br>&#125;else&#123;<br>do&#123;<br>completeWork(node)<br>if(node.sibling)&#123;<br>workInProgress = node.sibling<br>return //下一次循环<br>&#125;else&#123;<br>node = node.return // 父节点<br>&#125;<br>&#125;while(node)<br>&#125;<br>&#125;<br><br>while(workInProgress)&#123;<br>performUnitWork(workInprogress)<br>&#125;<br></code></pre></td></tr></table></figure><p>再回去结合那张图，我们其实可以明白，beginWork就是向下走的过程（图中1,2,4）。向下走到头了，会对自己执行completeWork，就会先向右（图中3,6）。向右也走到头了，就会向上走（图中5,7,8）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一篇，我们从整体上对React构建Fiber tree的流程有了大致的认知，但是我们其实并没有深入了解beginWork和completeWork具体干了什么。后面我们会再深入了解。</p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通俗易懂的React原理（一）：fiber架构</title>
    <link href="/2025/07/25/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Afiber%E6%9E%B6%E6%9E%84/"/>
    <url>/2025/07/25/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Afiber%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开个小坑，记录自己学习React源码过程中的一些心得。感觉市面上讲解React源码的书籍、视频都讲的一般，颇有照本宣科的意思。我希望能用通俗的话，把自己对React的理解记录下来。一方面是自己遗忘了之后，能回来看看，另一方面也是希望帮助到其他希望了解React源码，却又摸不着门道的人</p></blockquote><p>第一篇我们首先来讲一讲Fiber架构。所谓Fiber架构，是React16开始的新架构。说到虚拟DOM，相信大家都不陌生。所谓Fiber，简单来说就是通过链表来实现的虚拟Dom tree。你写的React组件最终会被转换成Fiber Node，通过指针相连，最终得到一个虚拟Dom tree，或者我们也可以叫它叫做Fiber tree。</p><h1 id="Fiber-tree的结构"><a href="#Fiber-tree的结构" class="headerlink" title="Fiber tree的结构"></a>Fiber tree的结构</h1><p><img src="fiber%E6%A0%91.png"></p><p>一个简单的Fiber tree可能就如上图所示，A~F是tree上面的Fiber Node，箭头则是将他们连接起来的指针。我们可以看到，每个Fiber Node最多有三条指针指向其他Fiber Node，分别是指向子节点（child，即第一个孩子），指向右侧兄弟（sibling），和指向父节点（return）。</p><p>在Reconciliation 阶段，React会通过遍历节点的方式，去构建Fiber tree。在遍历Fiber tree的时候，React会沿着我标的数字顺序去遍历，并且每个节点一去一回，会遍历两次（后面会讲到，分别是beginWork和completeWork）。</p><p>这个遍历有点像深度优先搜索。用文字概括一下遍历的顺序，先从根节点开始，正向遍历。对于任何一个节点，正向遍历它之后，都会继续正向遍历他的子节点（例如，1,2,4）。当没有子节点，即当前是叶子结点的时候，立刻反向遍历自己（未在图中标出）。然后去正向遍历当前节点的兄弟节点及其子节点（例如，3,6）。如果没有兄弟节点了，那么反向遍历父节点（例如，5,7,8）。</p><h1 id="新老架构"><a href="#新老架构" class="headerlink" title="新老架构"></a>新老架构</h1><h2 id="Stack架构的不可中断"><a href="#Stack架构的不可中断" class="headerlink" title="Stack架构的不可中断"></a>Stack架构的不可中断</h2><p>Fiber架构，是React16新推出的架构。更早的React版本，是Stack架构，即通过堆栈（递归），去完成虚拟Dom tree的构建。而递归就有一个问题，它是不可中断的。一旦中断，就没办法从上一次中断的地方继续构建，因为之前层层递归的函数调用栈已经被销毁了，找不回来上一次递归进行到了哪。</p><p>所以如果当构建虚拟Dom tree花费的时间比较久的时候，就会一直占用主线程，导致浏览器无法渲染下一帧，让用户感觉到卡顿。</p><h2 id="Fiber架构是可中断的"><a href="#Fiber架构是可中断的" class="headerlink" title="Fiber架构是可中断的"></a>Fiber架构是可中断的</h2><p>相比之下，Fiber架构通过链表实现，然后去遍历链表，则可以在每遍历到一个节点的时候，判断一下是否需要中断。</p><p>如果要中断，那我用一个全局变量保存一下当前遍历到那个节点就好了。恢复的时候，我再从保存的节点继续遍历。</p><p>例如下图，将已经遍历过的节点用红色表示。假如我刚正向遍历到D，就被中断了（可能是因为已经占用了主线程太久了），那就停止遍历，记录一下我正在遍历D。等继续的时候，我就可以从D开始继续遍历</p><p><img src="fiber%E6%A0%91%E8%A2%AB%E6%89%93%E6%96%AD.png"></p><h2 id="举一道面试题的例子"><a href="#举一道面试题的例子" class="headerlink" title="举一道面试题的例子"></a>举一道面试题的例子</h2><p>碰巧我跟朋友交流，她刚遇到了一道面试题，我觉得就很像React的这个中断机制。如果单纯的语言描述难以理解的话，不妨用一个简单的场景来类比吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">要求：实现从<span class="hljs-number">1</span>~n的累加。为了避免长时间阻塞主线程，需要每<span class="hljs-number">15</span>ms中断一次。<br>将后续数字的累加放到宏任务队列当中继续执行。最终返回一个promise<br></code></pre></td></tr></table></figure><p>这道题如何来实现呢，首先累加，我们最优先想到是循环，然后题目要求每15ms中断一次。那我们可以每次遍历，都判断一下当前已经执行多久了。如果超过15ms，就记录一下当前的进度，然后通过setTimeout(fn, 0)来使得在下一次事件循环执行宏任务的时候，继续刚才的任务。</p><p>最后，题目要求返回一个promise。那我们最后肯定是要new一个Promise，然后return这个promise的。当累加完毕的时候，使这个promise resolve即可。</p><p>参考实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">start, end</span>)=&gt;&#123;<br>    <span class="hljs-keyword">let</span> resolve, result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">helper</span> = (<span class="hljs-params">start, end</span>)=&gt;&#123;<br>        <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(startTime)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=start; i&lt;=end; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime &gt; <span class="hljs-number">15</span>)&#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                    <span class="hljs-title function_">helper</span>(i, end)<br>                &#125;, <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            result += i<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(result)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        resolve = res<br>        <span class="hljs-title function_">helper</span>(start, end)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br>               <br></code></pre></td></tr></table></figure><p>React的遍历，你也可以简单理解成这样。React在16的时候改成Fiber架构，就是为了可以在虚拟Dom tree构建到一半的时候，中止构建，结束js的执行，让主线程转而去渲染。然后等下一次事件循环，再继续去构建虚拟Dom tree。</p><p>虽然React16就转到了Fiber架构，但是这个版本并不会中断Fiber tree的构建，而是依旧会一直遍历，直到完整的Fiber tree被构建完毕。所以React16,17更像是过渡的版本，从原本的Stack架构迁移过来。</p><p>直到React18开始，React才正式启用了Concurrent模式。即<strong>在使用特定API的时候</strong>，根据是否阻塞主线程过久，在构建Fiber tree的时候可能会中断，并且可能有多个更新的流程并发执行。具体的细节我们后面源码部分再讲，前期主要做铺垫，有一个初步的了解。</p><h1 id="Fiber的双缓冲更新"><a href="#Fiber的双缓冲更新" class="headerlink" title="Fiber的双缓冲更新"></a>Fiber的双缓冲更新</h1><p>React维护了两份Fiber tree，一份叫做current，一份叫做workInProgress。记住这两个变量名，它们在后面的源码里面会经常出现。</p><p>这两份tree也不是永恒不变的，而是会互相切换，类似于显卡的前缓冲区和后缓冲区。current是当前被渲染出来的Fiber tree，即前缓冲区。而workInProgress则是重新渲染的时候，正在构建中的Fiber tree，即后缓冲区。</p><p>当workInProgress被构建完毕时，workInProgress和current身份互换。这样维护两份，而不是直接在原来一份上面更新，是为了避免渲染出修改了一半的Fiber tree。</p><p>值得注意的是，workInProgress和current两颗tree中的对应节点，也有指针互相指着。即<code>workInProgress.alternate = current</code> ，且<code>current.alternate = workInProgress</code>。由于重新渲染的时候经常需要复用上一次渲染的部分数据，所以有alternate会方便很多，可以拿到这个Fiber Node上一次渲染时候的一些状态</p><p>当正在构建workInProgress时，如图。对于下图，需要补充说明的是FiberRootNode和HostRootFiber。FiberRootNode并不属于Fiber tree当中，它管理着两颗Fiber tree，并且通过current来指向current tree，可以把它看做React应用的大本营。而HostRootFiber则是根节点</p><p><img src="current.png"></p><p>而当workInProgress构建完成，并且提交给Renderer渲染完毕后，FiberRootNode的current指向也发生了切换，然后current和workInProgress也就互换了</p><p><img src="%E5%88%87%E6%8D%A2%E5%90%8E.png"></p><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><p><a href="https://www.bilibili.com/video/BV15t4y1E7tz/">Lin Clark 在React Conf 2017上对fiber的介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>通俗易懂的React原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手实现react-ssr 2</title>
    <link href="/2024/06/16/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0react-ssr-2/"/>
    <url>/2024/06/16/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0react-ssr-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>仓库链接：<a href="https://github.com/miku03090831/Attempting-SSR-based-on-React/tree/stage-2">本篇代码</a></p><p>运行方法参考readme，请使用pnpm，因为本次使用的rspack尚未推出1.0版本，预计后续可能会有很多breakchange，所以lock文件至关重要，而我只上传了pnpm的lock，非常抱歉。</p><p>环境：node 20.12.0  pnpm 8.15.5 其余依赖以lock文件为准</p></blockquote><p>上一篇，我们已经完成了服务端的部分。理论上，我们这期只要补完浏览器端水合的功能，就基本完成了。但是困难总比想象的多，而且我最初的设想也太过天真</p><p>因为我没有不依赖脚手架，从零搭建项目的经验，一开始想着不打包，直接运行，最多过一下babel转一下嘛，但是后面问题越来越多。。。</p><h2 id="我以为要做的"><a href="#我以为要做的" class="headerlink" title="我以为要做的"></a>我以为要做的</h2><p>我以为就是在上次的index.js里面，执行一下水合就好了</p><h5 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.jsx&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; hydrateRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;<br><br><span class="hljs-title function_">hydrateRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>), <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure><p>因为上次html的模板里，最后一个script标签引了这个js文件，虽然我知道不会就这么简单顺利，但是问题还是多的超出了想象。</p><h2 id="简单列一下遇到的困难"><a href="#简单列一下遇到的困难" class="headerlink" title="简单列一下遇到的困难"></a>简单列一下遇到的困难</h2><ul><li>上一期为了能在node端运行，用了cjs的规范去导入和导出。但是浏览器不支持cjs规范，就很尴尬，cjs是node环境下提供的支持。平时我们的代码能跑，都是因为webpack在对代码进行打包的时候，将代码里的require转为了自己实现的导入导出方法。现在我没用webpack打包就很尴尬，浏览器不认识require，而且这个用babel转了也没用，babel只能把import转为require，但是没有给require提供polyfill，大概是因为这个本来是webpackl的工作吧</li><li>而且还有问题就是不打包的话，浏览器端是拿不到react的代码的（不考虑node端的话，或许可以参考vite，对import进行处理，返回node_modules里的react包）。我改用cdn的方式引入react，node端又会报错。然后判断require存在的时候调require，也没有用，查了一下大概是条件判断引入require是没用的。。。</li><li>然后还遇见的问题真的是很多很多，再加上我对早些时候的什么requirejs，seajs之类的完全不了解，在我尝试了两个小时未果后，感觉有点搞不定node和浏览器的同构渲染了，所以最后还是决定上打包器</li></ul><h2 id="用Rspack"><a href="#用Rspack" class="headerlink" title="用Rspack"></a>用Rspack</h2><p>看到了字节Web Infra微信公众号的推文，Rspack在JSNation 2024获得”Breakthrough of the Year”奖项，与之前的Deno、Vite、Svelte、Astro、SolidJS 等杰出的项目共享同一份殊荣，我就突然觉得这个东西未来非常可期，所以打算在这个小demo里面尝试一下。</p><p>参考<a href="https://www.rspack.dev/zh/guide/start/quick-start">rspack的文档</a>，我们其实不需要rsbuid这么重的脚手架，我们只需要Rspack CLI来帮我们打包就可以了。我们使用<code>pnpm add @rspack/core @rspack/cli -D</code>去安装依赖，然后添加配置文件rspack.client.js和rspack.server.js，主要就是让rspack用builtin:swc-loader去处理一下我们的代码（比如处理jsx，es6等等），然后再打包到一起。模式选择用开发模式打包，这样报错我们更容易看一些。</p><h5 id="rspack-client-js"><a href="#rspack-client-js" class="headerlink" title="rspack.client.js"></a>rspack.client.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./index.js&quot;</span>,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;index.bundle.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jsx|js)$/</span>,<br>        <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>],<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;builtin:swc-loader&quot;</span>,<br>        <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">jsc</span>: &#123;<br>            <span class="hljs-attr">parser</span>: &#123;<br>              <span class="hljs-attr">syntax</span>: <span class="hljs-string">&quot;typescript&quot;</span>,<br>              <span class="hljs-attr">tsx</span>: <span class="hljs-literal">true</span>,<br>            &#125;,<br>            <span class="hljs-attr">transform</span>: &#123;<br>              <span class="hljs-attr">react</span>: &#123;<br>                <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;automatic&quot;</span>,<br>                <span class="hljs-attr">development</span>: <span class="hljs-literal">false</span>,<br>                <span class="hljs-attr">refresh</span>: <span class="hljs-literal">false</span>,<br>              &#125;,<br>            &#125;,<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="rspack-server-js"><a href="#rspack-server-js" class="headerlink" title="rspack.server.js"></a>rspack.server.js</h5><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs nix">m<span class="hljs-attr">odule.exports</span> <span class="hljs-operator">=</span> &#123;<br>  <span class="hljs-params">target:</span> <span class="hljs-string">&quot;node&quot;</span>,<br>  <span class="hljs-params">entry:</span> <span class="hljs-string">&quot;./server.js&quot;</span>,<br>  <span class="hljs-params">output:</span> &#123;<br>    <span class="hljs-params">filename:</span> <span class="hljs-string">&quot;server.bundle.js&quot;</span>,<br>  &#125;,<br>  <span class="hljs-params">mode:</span> <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-params">module:</span> &#123;<br>    <span class="hljs-params">rules:</span> [<br>      &#123;<br>        <span class="hljs-params">test:</span> <span class="hljs-operator">/</span>\.(js|jsx)$<span class="hljs-operator">/</span>,<br>        <span class="hljs-params">exclude:</span> [<span class="hljs-operator">/</span>[\\<span class="hljs-operator">/</span>]node_modules[\\<span class="hljs-operator">/</span>]<span class="hljs-operator">/</span>],<br>        <span class="hljs-params">loader:</span> <span class="hljs-string">&quot;builtin:swc-loader&quot;</span>,<br>        <span class="hljs-params">options:</span> &#123;<br>          <span class="hljs-params">jsc:</span> &#123;<br>            <span class="hljs-params">parser:</span> &#123;<br>              <span class="hljs-params">syntax:</span> <span class="hljs-string">&quot;typescript&quot;</span>,<br>              <span class="hljs-params">tsx:</span> <span class="hljs-literal">true</span>,<br>            &#125;,<br>            <span class="hljs-params">transform:</span> &#123;<br>              <span class="hljs-params">react:</span> &#123;<br>                <span class="hljs-params">runtime:</span> <span class="hljs-string">&quot;automatic&quot;</span>,<br>                <span class="hljs-params">development:</span> <span class="hljs-literal">false</span>,<br>                <span class="hljs-params">refresh:</span> <span class="hljs-literal">false</span>,<br>              &#125;,<br>            &#125;,<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>接下来我们在package.json里面，添加打包和启动服务的命令</p><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; pnpm run build &amp;&amp; pnpm run build:server &amp;&amp; node ./dist/server.bundle.js&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rspack build -c rspack.client.js&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;build:server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rspack build -c rspack.server.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.19.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^18.3.1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^18.3.1&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;@rspack/cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.7.3&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;@rspack/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.7.3&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>接下来，还需要把server返回的html模板里的js文件，从原始代码改成打包后的产物</p><h5 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.jsx&quot;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactDom</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react-dom/server&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;react&quot;</span>);<br><br><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">express</span>();<br>server.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&quot;.&quot;</span>));<br>server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-keyword">const</span> elementString = <span class="hljs-title class_">ReactDom</span>.<span class="hljs-title function_">renderToString</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elementString)<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-string">`&lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">  &lt;html lang=&quot;en&quot;&gt;</span><br><span class="hljs-string">  &lt;head&gt;</span><br><span class="hljs-string">      &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="hljs-string">      &lt;title&gt;my react ssr&lt;/title&gt;</span><br><span class="hljs-string">  &lt;/head&gt;</span><br><span class="hljs-string">  &lt;body&gt;</span><br><span class="hljs-string">      &lt;div id=&quot;root&quot;&gt;<span class="hljs-subst">$&#123;elementString&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">      &lt;script type=&quot;module&quot; src=&quot;./dist/index.bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;/body&gt;</span><br><span class="hljs-string">  &lt;/html&gt;`</span>;<br>  res.<span class="hljs-title function_">send</span>(html);<br>&#125;);<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>然后<code>pnpm run server</code>，本地服务器顺利启动，就大功告成了。</p><p>上一次的代码里面，因为只做了服务端渲染，没有水合，所以页面是无法交互的。就比如上次我们的代码，给div添加了点击事件。但是因为上次拿到的只是一个html文件，是没有点击事件一说的，我们可以试一下，点击div，什么都没有发生。</p><p>然后在这次成功添加了水合事件之后，我们再点击div，控制台就输出了“111”，说明水合成功了，点击事件添加上了</p><p>顺便说下，上次服务端返回的html模板有问题。。。root那个div元素之后不要换行，直接拼renderToString返回的字符串就行，不然服务端返回的html的虚拟dom会多一个内容为换行符的text节点，导致水合失败，降级到纯客户端渲染。。。我被这个东西搞吐了，查了很久为什么水合失败，幸好最后发现了</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>ssr</tag>
      
      <tag>动手实践</tag>
      
      <tag>同构渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手实现react ssr</title>
    <link href="/2024/06/11/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0react-ssr/"/>
    <url>/2024/06/11/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0react-ssr/</url>
    
    <content type="html"><![CDATA[<p>关于ssr相关的介绍，可以移步之前的一篇博文，本文不再赘述</p><p>日常工作中，我们可能都接触过ssr，不过我们可能通常是借助于框架（例如Next.js）的支持来完成ssr。今天我想尝试，摆脱高度封装的前端框架，只依赖react相关的库，来实现ssr。</p><p><a href="https://github.com/miku03090831/Attempting-SSR-based-on-React">本篇代码</a> <code>pnpm i</code>安装依赖，<code>npm run server</code>启动服务</p><p>环境：node 20.12.0 react和react-dom版本均为18.3.1</p><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/697570886">知乎专栏：SSR原理与实践</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们的目的，是本地的8080端口起一个node服务，然后当我们访问localhost:8080的时候，服务端能返回给我们一个页面，。在拿到页面之后，浏览器会对页面进行水合，从而使得页面可交互。</p><p>首先，我们先安装一下依赖。我比较喜欢pnpm（节省磁盘空间，避免幽灵依赖），所以我直接在命令行敲<code>pnpm i react react-dom express</code> 。安装react（将jsx转为虚拟dom），react-dom（将虚拟dom转成dom），express（用于起一个web服务器）</p><p>然后我们新建三个文件，分别是server.js，index.js，App.jsx</p><p><strong>App.jsx</strong>里面，我们就简单实现一个组件吧，然后要用commonjs的方式去引入和导出（因为我们是极简版本，甚至都没有经过打包构建流程，为了能让node端识别，就直接按cjs规范写了）</p><p><strong>index.js</strong>里面，我们要去写用于客户端执行的代码，我们暂且随便在里面console.log一句话吧，用于证明index.js被成功加载。</p><p>本期的重头戏来了，<strong>server.js</strong>，不多bb先上代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml">const express = require(&quot;express&quot;);<br>const App = require(&quot;./app.jsx&quot;);<br>const ReactDom = require(&quot;react-dom/server&quot;);<br>const React = require(&#x27;react&#x27;)<br><br>const server = express();<br>server.use(express.static(&#x27;.&#x27;))<br>server.get(&quot;/&quot;, function (req, res, next) &#123;<br>  const elementString = ReactDom.renderToString(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>);<br>  const html = `<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>my react ssr<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>         $&#123;elementString&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>`;<br>  res.send(html);<br>&#125;);<br><br>server.listen(8080);<br><br></code></pre></td></tr></table></figure><p>对于访问根目录的请求，我们依旧是通过cjs的require，拿到app.jsx的内容。然后借助react-dom&#x2F;server的api <code>renderToString</code>，将jsx组件转成html字符串 。</p><p>接下来就是拼模板啦，直接copy模板，然后把得到的html字符串放到模板字符串中间，并且在最后写一个script标签，加载未来可期的index.js。然后返回response就可以了</p><p>然后为了解决node不认识jsx的问题，我们又装了bable的一系列包。依旧是用pnpm安装@babel&#x2F;cli，@babel&#x2F;core，@babel&#x2F;node，babel&#x2F;preset-env，@babel&#x2F;preset-react。然后在package.json添加一个script，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babel-node server.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后我们就可以通过npm run server，来启动服务了。打开浏览器，访问localhost:8080，可以看到页面正常展示。但是打开控制台，发现index.js没加载出来，404了。是因为请求localhost:8080&#x2F;index.js 这个静态资源路径，express是不知道你要什么的。需要通过<code>express.static(pathxxx)</code>中间件，来告诉express，以pathxxx作为静态资源目录。例如我这里把index.js放在了根目录，那pathxxx就是“.”就可以了。</p><p>再次重启服务，打开控制台，看到index.js正常被加载，打印出了我们想要的东西。</p><p>本次暂时只实现服务端渲染的部分，后续客户端水合，且听下回分解</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>ssr</tag>
      
      <tag>动手实践</tag>
      
      <tag>同构渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于tapable来模拟webpack插件机制</title>
    <link href="/2024/04/22/%E5%9F%BA%E4%BA%8Etapable%E6%9D%A5%E6%A8%A1%E6%8B%9Fwebpack%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/04/22/%E5%9F%BA%E4%BA%8Etapable%E6%9D%A5%E6%A8%A1%E6%8B%9Fwebpack%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 前两天看到ByteFE公众号发了篇文章，从源码去讲webpack。我之前也从很多方面去学习webpack，只是源码一直没太看得进去，这一次我想仔细地读一读。</p></blockquote><h2 id="简要介绍tapable"><a href="#简要介绍tapable" class="headerlink" title="简要介绍tapable"></a>简要介绍tapable</h2><p>说实话，之前看webpack源码一直没看的太懂，看不进去，有一部分原因就是它的hooks我根本看不懂是在干什么。比如这样，一堆hooks，还有全是回调函数，看不进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">callAsync</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">callAsync</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">readRecords</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">finalCallback</span>(err);<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(onCompiled);<br>&#125;);<br>&#125;);<br>&#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>我去看了一下，<code>this.hooks</code>里面的各个属性，都是从tapable导出的类的实例。我就去了解了一下tapable这个包，它是一个基于发布订阅模式的处理消息的npm包，webpack的插件机制就是基于它实现的。</p><p>它的基础用法就是，先从tapable导出的某种hooks实例化一个对象A。然后通过一个方法比如A.tap，去给A绑定一个回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// compiler.hooks.beforeRun就是对象A。tap方法的第一个参数，我将它理解为是一个标记之类的东西</span><br><span class="hljs-comment">// 因为一个事件可以被好多地方监听，第一个参数就相当于是区分是哪一处代码在监听。实际用处不大</span><br><span class="hljs-comment">// 第二个参数就是回调方法</span><br>compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;plugin1-beforerun&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeRun in Plugin1&quot;</span>);<br>   &#125;);<br></code></pre></td></tr></table></figure><p>然后我就可以在另一个地方，通过A.call来主动触发事件。此时，所有A.tap绑定的回调都会被触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 触发beforeRun事件（此处的this和上面代码的compiler是一个实例）</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">call</span>();<br><span class="hljs-comment">// 然后会执行上面绑定的回调</span><br></code></pre></td></tr></table></figure><p>tapable导出的hooks有很多种，有同步触发的，有异步触发的。有多个监听者并行触发的，有串行触发的。我们今天就只看最简单的一种，同步触发，来简易地模拟一下webpack的插件机制。</p><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>首先我们<code>pnpm init</code>，然后<code>pnpm i tapable</code>（我确实喜欢pnpm，没有幽灵依赖，依赖版本明确，节省磁盘空间）</p><p>然后我们新建一个src目录，接下来我们就模仿webpack的代码，开始动手。</p><p>首先我们来写两个简单的webpack插件</p><h4 id="src-x2F-Plugin-x2F-plugin1-js"><a href="#src-x2F-Plugin-x2F-plugin1-js" class="headerlink" title="src&#x2F;Plugin&#x2F;plugin1.js"></a>src&#x2F;Plugin&#x2F;plugin1.js</h4><p>我们先来用class来实现一个webpack插件。我们需要实现一个class，它有一个apply方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin1</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 监听beforeRun事件</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;plugin1-beforerun&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeRun in Plugin1&quot;</span>);<br>    &#125;);<br>    <span class="hljs-comment">// 监听run事件，并接收一个参数</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;plugin1-run&quot;</span>, <span class="hljs-function">(<span class="hljs-params">stage</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;stage&#125;</span> in plugin1`</span>);<br>    &#125;);<br>    <span class="hljs-comment">// 监听afterRun事件，并接收三个参数  </span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">afterRun</span>.<span class="hljs-title function_">tap</span>(<br>      <span class="hljs-string">&quot;plugin1-afterrun&quot;</span>,<br>      <span class="hljs-function">(<span class="hljs-params">stage, timestamp, result</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>          <span class="hljs-string">`<span class="hljs-subst">$&#123;stage&#125;</span> in plugin1, timestamp is <span class="hljs-subst">$&#123;timestamp&#125;</span>, and the result is <span class="hljs-subst">$&#123;result&#125;</span>`</span><br>        );<br>      &#125;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Plugin1</span>;<br><br></code></pre></td></tr></table></figure><h4 id="src-x2F-Plugin-x2F-plugin2-js"><a href="#src-x2F-Plugin-x2F-plugin2-js" class="headerlink" title="src&#x2F;Plugin&#x2F;plugin2.js"></a>src&#x2F;Plugin&#x2F;plugin2.js</h4><p>接下来我们用function来实现一个webpack插件，我们直接在函数体里面给事件绑定回调就可以了，代码完全和上一个插件一样，只是打印出来的plugin1改成plugin2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Plugin2</span>(<span class="hljs-params">compiler</span>) &#123;<br>  compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;plugin2-beforerun&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;beforeRun in Plugin2&quot;</span>);<br>  &#125;);<br>  compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;plugin2-run&quot;</span>, <span class="hljs-function">(<span class="hljs-params">stage</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;stage&#125;</span> in plugin1`</span>);<br>  &#125;);<br>  compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">afterRun</span>.<span class="hljs-title function_">tap</span>(<br>    <span class="hljs-string">&quot;plugin2-afterrun&quot;</span>,<br>    <span class="hljs-function">(<span class="hljs-params">stage, timestamp, result</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-string">`<span class="hljs-subst">$&#123;stage&#125;</span> in plugin2, timestamp is <span class="hljs-subst">$&#123;timestamp&#125;</span>, and the result is <span class="hljs-subst">$&#123;result&#125;</span>`</span><br>      );<br>    &#125;<br>  );<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Plugin2</span><br></code></pre></td></tr></table></figure><p>接下来就是我们用来类比webpack的两个文件</p><h4 id="src-x2F-Compiler-js"><a href="#src-x2F-Compiler-js" class="headerlink" title="src&#x2F;Compiler.js"></a>src&#x2F;Compiler.js</h4><p>类比webpack中&#x2F;lib&#x2F;Compiler.js，我们只实现其中核心的run方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">SyncHook</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;tapable&quot;</span>);<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompiler</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span> = &#123;<br>      <span class="hljs-attr">beforeRun</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>(),<br>      <span class="hljs-attr">run</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>([<span class="hljs-string">&quot;stage&quot;</span>]),<br>      <span class="hljs-attr">afterRun</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncHook</span>([<span class="hljs-string">&quot;stage&quot;</span>, <span class="hljs-string">&quot;timestamp&quot;</span>, <span class="hljs-string">&quot;calResult&quot;</span>]),<br>    &#125;;<br>  &#125;<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在不同的阶段，去触发不同的事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">beforeRun</span>.<span class="hljs-title function_">call</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;run&quot;</span>);<br>    <span class="hljs-comment">// 做个运算，来当做run了（类比compile代码）</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>++;<br>    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hooks</span>.<span class="hljs-property">afterRun</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;afterRun&quot;</span>, timestamp, <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyCompiler</span>;<br><br></code></pre></td></tr></table></figure><h4 id="src-x2F-webpack-js"><a href="#src-x2F-webpack-js" class="headerlink" title="src&#x2F;webpack.js"></a>src&#x2F;webpack.js</h4><p>类比webpack中&#x2F;lib&#x2F;webpack.js，只不过把调用webpack的代码也写进来了。</p><p>这个文件的核心部分写的相当简陋，webpack里面只做了创建compiler和compiler.run两件事</p><p>而createCompiler里面则负责将compiler实例化，并且注册插件。如果只是我这样简易的实现的话，没必要把注册插件的代码特地拿出来写一个方法，完全可以写到compiler的构造函数里。但是实际的webpack在createCompiler里面还做了很多事，不方便写到构造函数里。而我为了能够使读者更容易将我的代码和webpack类比起来，所以采用了和webpack相似的写法。</p><p>注册插件的时候，如果插件本身是一个函数，那么直接执行它就可以了。如果插件本身是一个类，那么则需要实例化，并且调用它的apply方法。以上两种方式，都会让插件去成功监听webpack触发的各种事件。插件可以根据自己的需要，给不同的阶段加上不同的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyCompiler</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Compiler&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Plugin1</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Plugin/plugin1&quot;</span>);<br><span class="hljs-keyword">const</span> plugin2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Plugin/plugin2&quot;</span>);<br><br><span class="hljs-keyword">const</span> plugin1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin1</span>();<br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">plugins</span>: [plugin1, plugin2],<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createCompiler</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> compiler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCompiler</span>(options);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(options.<span class="hljs-property">plugins</span>)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> options.<span class="hljs-property">plugins</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        plugin.<span class="hljs-title function_">call</span>(compiler, compiler);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        plugin.<span class="hljs-title function_">apply</span>(compiler);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> compiler;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">webpack</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> compiler = <span class="hljs-title function_">createCompiler</span>(options);<br>  compiler.<span class="hljs-title function_">run</span>();<br>&#125;;<br><br><span class="hljs-title function_">webpack</span>(options);<br><br></code></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>其实tapable远不止上面这么简单，比如各处监听者的回调触发的时机，各处回调之间的互相通信，等等。但是这个简单的例子，已经足够让大家了解webpack的插件机制了。后面的文章随缘更新，也许是继续深入了解webpack，也许是更进一步研究tapable</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>webpack plugin</tag>
      
      <tag>tapable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入js——作用域，作用域链，执行栈（一）</title>
    <link href="/2023/07/23/%E6%B7%B1%E5%85%A5js%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <url>/2023/07/23/%E6%B7%B1%E5%85%A5js%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在补js基础。当初自学js的时候，总是感觉学的不扎实。只能说不去上手，再怎么死读书，也理解不了。积累了经验，然后自己去思考，这个时候再去看理论，就容易理解了。</p><p>感觉工作一年以来，确实学到了很多，但是过于专注于应用方面的知识，反倒基础上有些东西忘记了。虽说平时写代码多半没什么影响，但是基础扎实，才能让你知其所以然。搞技术的永远不能放弃对“知其所以然”的追求。</p><p>本篇文章小目标是当一个自己的笔记，免得过段时间又忘了。大目标就是写的详细一点，能让更多的人知其所以然</p></blockquote><p>最精简的结论：</p><p>js作用域是静态作用域（词法作用域），在定义的时候就已经确定了。</p><p>而执行上下文，顾名思义是运行时的东西，要看是谁调用了谁。</p><p>todo 作用域和执行栈的画图解释，闭包，作用域的分类（全局script作用域，模块作用域）。js执行两阶段，活动对象等等</p><h2 id="浅谈作用域和作用域链"><a href="#浅谈作用域和作用域链" class="headerlink" title="浅谈作用域和作用域链"></a>浅谈作用域和作用域链</h2><p>当访问变量时，js引擎会首先在当前作用域找这个变量，找不到就沿着作用域链向上找，直到全局作用域。沿着作用域链能找到的变量，就可以访问。沿着作用域链找不到的，就不能访问。</p><p>js的作用域是静态作用域（也叫词法作用域），在定义的时候就已经被确定了，也就是说，要以代码被定义时的层级，作为作用域链。与之相对的是动态作用域，要以代码被调用的层级来作为作用域链（现代编程语言多数为静态作用域）</p><p>举个例子，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">const</span> f= <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> f<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fun1</span>()<br><span class="hljs-title function_">result</span>()<br></code></pre></td></tr></table></figure><p>这段js代码，打印出来的是2，因为fun2内部访问a的时候，沿着作用域链寻找，作用域链是按定义的层级来的，所以会找到fun1里面的a，而不是全剧最外面的a。</p><p>如果是动态作用域，那么会打印出来1，因为调用f的环境是在全局。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>js调用函数，是以栈的形式去实现的。有一个执行环境的栈，栈里面每一个元素都是一个执行上下文。至于什么是执行上下文，后面会详细讲解，可以简单理解为包含了函数执行相关信息，比如入参，和里面定义的变量等等。</p><p>最初的执行栈就只有一个元素，就是全局上下文。然后如果调用了别的函数，就会创建一个新的上下文，并且推入栈中，如果在函数内又调用了函数，就继续创建新的上下文并入栈。当函数执行完毕，这个函数的上下文就出栈。</p><p>这就是很基本的执行栈规则</p><p>很忙，有空再更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>作用域</tag>
      
      <tag>执行上下文</tag>
      
      <tag>执行栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack运行时代码简要分析</title>
    <link href="/2023/06/27/webpack%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BB%A3%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/27/webpack%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BB%A3%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>开个坑，主要也是怕自己后面忘了</p><p>简单写写，有空了补上</p><p><code>__webpack_modules</code>是一个数组，每个元素都是一个函数，函数接受三个参数：第一个参数<code>module</code>好像没用到，第二个是一个对象（会把本模块要导出的属性，赋值给这个对象），第三个是<code>__webpack_require</code>方法（用于引入其他的模块）。函数体里面就是原本这个模块的代码，然后会通过<code>__webpack_require.d</code>方法（类似<code>object.assign</code>的作用），把模块的导出值上的属性，全挂到第二个入参上面。然后如果还要引入别的模块，就会调用第三个入参，传入目标模块的moduleId</p><p><code>__webpack_require</code>方法，接收一个参数<code>moduleId</code>。首先检查这个<code>moduleId</code>是否在缓存数组里，如果有直接返回缓存内容。没有，就定义一个module对象，有一个exports属性，值是空对象，然后先把module缓存塞进缓存数组，再调用<code>__webpack_modules[moduleId]</code>，如上文所说传入<code>module</code>，<code>module.exports</code>,<code>__webpack_require</code>。因为是浅拷贝，所以前面定义过的<code>module.exports</code>就能拿到引用的模块的导出值了。最后<code>return module.exports</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack动态加载原理简述</title>
    <link href="/2023/06/17/webpack%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <url>/2023/06/17/webpack%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要动态加载"><a href="#为什么需要动态加载" class="headerlink" title="为什么需要动态加载"></a>为什么需要动态加载</h2><p>上一篇讲我写webpack针对markdown的loader的时候，提到了希望能动态加载以优化性能。篇幅原因没有展开说，打算单独写一篇文章讲一下。</p><p>当我们访问网站的时候，浏览器会向服务器请求页面资源。首先请求的当然是html文件。html文件里会带很多script标签，浏览器解析到这些标签的话，就会去下载这些js资源。当然有些script标签带了async或者defer属性，不会阻塞后续dom的解析。但是很多单页应用，本身渲染就是强依赖js的，js下载的慢，就会推迟页面开始渲染的时机。因此，我们肯定都是希望下载js越快越好的，因此我们就希望缩减js的体积。</p><p>缩减js体积的办法有很多，主要思路都是将非首屏必须的js资源拆出来，以减小首屏js的体积，首屏js加载完了就可以渲染出东西来了。所以所以我们可以对组件做动态加载。动态加载会让组件从项目js中拆出来，被打包成一个单独的js文件，被引入。webpack中我们可以通过import()语法，去动态加载组件</p><h2 id="动态加载的实现"><a href="#动态加载的实现" class="headerlink" title="动态加载的实现"></a>动态加载的实现</h2><p>知其然，也想知其所以然。动态加载是怎么实现的呢？是webpack借助类似jsonp的方式来实现的。</p><p>说白了就是，被动态加载的组件会被单独打包，当你写的import()被执行的时候，webpack会去拼一个script标签出来，script标签的src属性就是被单独打包的组件的url。</p><h4 id="window对象上的webpackJsonp数组"><a href="#window对象上的webpackJsonp数组" class="headerlink" title="window对象上的webpackJsonp数组"></a>window对象上的webpackJsonp数组</h4><p>细致地说，在首屏的js中，webpack会在window上挂一个数组，用来记录已被动态加载完毕的组件。最初这个数组为空。然后被动态加载的组件，所在的js文件的开头，就是向window对象上的那个数组，push自己进去。因此当动态加载的js被下载完毕时，就会立刻执行push方法，后面有讲，这个push方法被动了手脚，在真的push之前，会执行一些必要的操作（详见webpackJsonpCallback）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## 首屏js<br><span class="hljs-keyword">var</span> jsonpArray = <span class="hljs-variable language_">window</span>[<span class="hljs-string">&quot;webpackJsonp&quot;</span>] = <span class="hljs-variable language_">window</span>[<span class="hljs-string">&quot;webpackJsonp&quot;</span>] || [];<br> <span class="hljs-keyword">var</span> oldJsonpFunction = jsonpArray.<span class="hljs-property">push</span>.<span class="hljs-title function_">bind</span>(jsonpArray);<br> jsonpArray.<span class="hljs-property">push</span> = webpackJsonpCallback;<br> jsonpArray = jsonpArray.<span class="hljs-title function_">slice</span>();<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; jsonpArray.<span class="hljs-property">length</span>; i++) <span class="hljs-title function_">webpackJsonpCallback</span>(jsonpArray[i]);<br> <span class="hljs-keyword">var</span> parentJsonpFunction = oldJsonpFunction;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## 被单独打包的<span class="hljs-title function_">js</span><br>(<span class="hljs-variable language_">window</span>[<span class="hljs-string">&quot;webpackJsonp&quot;</span>] = <span class="hljs-variable language_">window</span>[<span class="hljs-string">&quot;webpackJsonp&quot;</span>] || []).<span class="hljs-title function_">push</span>([[<span class="hljs-number">0</span>],&#123;<br><span class="hljs-comment">/** 被动态引入的组件，被打包后的内容 */</span><br>&#125;]);<br></code></pre></td></tr></table></figure><h4 id="动态加载的起点，requireEnsure方法"><a href="#动态加载的起点，requireEnsure方法" class="headerlink" title="动态加载的起点，requireEnsure方法"></a>动态加载的起点，requireEnsure方法</h4><p>当执行到动态加载的时候，会调用webpack的requireEnsure方法。requireEnsure方法首先检查，这个模块是否被加载过，如果没加载过，就new一个Promise，然后去添加一个script标签，并为这个script标签设置好onerror和onload事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## 首屏js<br>__webpack_require__.<span class="hljs-property">e</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">requireEnsure</span>(<span class="hljs-params">chunkId</span>) &#123;<br> <span class="hljs-keyword">var</span> promises = [];<br><br><br> <span class="hljs-comment">// JSONP chunk loading for javascript</span><br><br> <span class="hljs-keyword">var</span> installedChunkData = installedChunks[chunkId];<br> <span class="hljs-keyword">if</span>(installedChunkData !== <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 0 means &quot;already installed&quot;.</span><br><br> <span class="hljs-comment">// a Promise means &quot;currently loading&quot;.</span><br> <span class="hljs-keyword">if</span>(installedChunkData) &#123;<br> promises.<span class="hljs-title function_">push</span>(installedChunkData[<span class="hljs-number">2</span>]);<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-comment">// setup Promise in chunk cache</span><br> <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br> installedChunkData = installedChunks[chunkId] = [resolve, reject];<br> &#125;);<br> promises.<span class="hljs-title function_">push</span>(installedChunkData[<span class="hljs-number">2</span>] = promise);<br><br> <span class="hljs-comment">// start chunk loading</span><br> <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br> <span class="hljs-keyword">var</span> onScriptComplete;<br><br> script.<span class="hljs-property">charset</span> = <span class="hljs-string">&#x27;utf-8&#x27;</span>;<br> script.<span class="hljs-property">timeout</span> = <span class="hljs-number">120</span>;<br> <span class="hljs-keyword">if</span> (__webpack_require__.<span class="hljs-property">nc</span>) &#123;<br> script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;nonce&quot;</span>, __webpack_require__.<span class="hljs-property">nc</span>);<br> &#125;<br> script.<span class="hljs-property">src</span> = <span class="hljs-title function_">jsonpScriptSrc</span>(chunkId);<br><br> <span class="hljs-comment">// create error before stack unwound to get useful stacktrace later</span><br> <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br> onScriptComplete = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br> <span class="hljs-comment">// avoid mem leaks in IE.</span><br> script.<span class="hljs-property">onerror</span> = script.<span class="hljs-property">onload</span> = <span class="hljs-literal">null</span>;<br> <span class="hljs-built_in">clearTimeout</span>(timeout);<br> <span class="hljs-keyword">var</span> chunk = installedChunks[chunkId];<br> <span class="hljs-keyword">if</span>(chunk !== <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">if</span>(chunk) &#123;<br> <span class="hljs-keyword">var</span> errorType = event &amp;&amp; (event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;load&#x27;</span> ? <span class="hljs-string">&#x27;missing&#x27;</span> : event.<span class="hljs-property">type</span>);<br> <span class="hljs-keyword">var</span> realSrc = event &amp;&amp; event.<span class="hljs-property">target</span> &amp;&amp; event.<span class="hljs-property">target</span>.<span class="hljs-property">src</span>;<br> error.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="hljs-string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="hljs-string">&#x27;: &#x27;</span> + realSrc + <span class="hljs-string">&#x27;)&#x27;</span>;<br> error.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ChunkLoadError&#x27;</span>;<br> error.<span class="hljs-property">type</span> = errorType;<br> error.<span class="hljs-property">request</span> = realSrc;<br> chunk[<span class="hljs-number">1</span>](error);<br> &#125;<br> installedChunks[chunkId] = <span class="hljs-literal">undefined</span>;<br> &#125;<br> &#125;;<br> <span class="hljs-keyword">var</span> timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-title function_">onScriptComplete</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-attr">target</span>: script &#125;);<br> &#125;, <span class="hljs-number">120000</span>);<br> script.<span class="hljs-property">onerror</span> = script.<span class="hljs-property">onload</span> = onScriptComplete;<br> <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br> &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);<br> &#125;;<br></code></pre></td></tr></table></figure><h4 id="加载完毕的回调，webpackJsonpCallback"><a href="#加载完毕的回调，webpackJsonpCallback" class="headerlink" title="加载完毕的回调，webpackJsonpCallback"></a>加载完毕的回调，webpackJsonpCallback</h4><p>然后还有一个很重要的方法，叫webpackJsonpCallback。window对象上的数组，push方法被劫持了，就是被改为webpackJsonpCallback方法。在webpackJsonpCallback里，会执行之前promise的resolve，然后把自己记录为已加载状态，最后再把自己push到数组里（劫持了原来的push方法，相当于在真的push之前作了上述操作）。这里也就能看出来，import()的本质是一个promise（严谨地说是promise.all）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## 首屏js<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">webpackJsonpCallback</span>(<span class="hljs-params">data</span>) &#123;<br> <span class="hljs-keyword">var</span> chunkIds = data[<span class="hljs-number">0</span>];<br> <span class="hljs-keyword">var</span> moreModules = data[<span class="hljs-number">1</span>];<br><br><br> <span class="hljs-comment">// add &quot;moreModules&quot; to the modules object,</span><br> <span class="hljs-comment">// then flag all &quot;chunkIds&quot; as loaded and fire callback</span><br> <span class="hljs-keyword">var</span> moduleId, chunkId, i = <span class="hljs-number">0</span>, resolves = [];<br> <span class="hljs-keyword">for</span>(;i &lt; chunkIds.<span class="hljs-property">length</span>; i++) &#123;<br> chunkId = chunkIds[i];<br> <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;<br> resolves.<span class="hljs-title function_">push</span>(installedChunks[chunkId][<span class="hljs-number">0</span>]);<br> &#125;<br> installedChunks[chunkId] = <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-keyword">for</span>(moduleId <span class="hljs-keyword">in</span> moreModules) &#123;<br> <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(moreModules, moduleId)) &#123;<br> modules[moduleId] = moreModules[moduleId];<br> &#125;<br> &#125;<br> <span class="hljs-keyword">if</span>(parentJsonpFunction) <span class="hljs-title function_">parentJsonpFunction</span>(data);<br><br> <span class="hljs-keyword">while</span>(resolves.<span class="hljs-property">length</span>) &#123;<br> resolves.<span class="hljs-title function_">shift</span>()();<br> &#125;<br><br> &#125;;<br></code></pre></td></tr></table></figure><p>以上就是webpack动态加载的原理</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>动态加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写一个简单的webpack loader的踩坑</title>
    <link href="/2023/06/16/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84webpack-loader%E7%9A%84%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/06/16/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84webpack-loader%E7%9A%84%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为觉得hexo框架搭的博客功能一般，就有了想要自己写一个博客的想法。然后就想着如果把markdown文件也放到项目里的话，会比较方便，发现需要编写一个加载markdown的loader，于是就有了这篇博客，来记录一下踩过的坑和收获</p></blockquote><h2 id="loader的作用"><a href="#loader的作用" class="headerlink" title="loader的作用"></a>loader的作用</h2><p>我们都知道，直接在代码里面通过require或者import去引入markdown文件是会报错的，因为webpack在打包的时候不知道如何去处理markdown文件。webpack是负责打包js模块的，非js模块的文件，如果要被打包，那么就需要有loader去处理。</p><p>比如你要import一个txt文件或者markdown文件，这种就相当于是纯文本字符串。你让webpack去打包这种东西它是不认识的。你需要把它改成一个js模块，模块的导出值是原本文件的内容。</p><p>所以，我们需要给markdown文件专门编写一个loader。</p><p>简单来讲，可以是这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## ./md-loader.<span class="hljs-property">js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`export const content = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(source)&#125;</span>`</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这个loader接收原本文件的内容，然后返回一个新的字符串，字符串的内容就是一个js模块。</p><p>这样webpack导入这个文件的时候，看到的就是这个loader返回的内容，也就是一个js模块了。</p><h2 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h2><p>引入文章的内容，我们肯定是希望懒加载，动态import进来的。这样可以让文章的内容被放在一个单独的js包里。我们可以首屏渲染出页面的框架，然后呈现一个加载的动画，再通过一个单独的请求去拿到文章内容。</p><p>我们可以通过js原生的import()语法去动态加载，也可以通过next&#x2F;dynamic提供的dynamic方法去加载（next的dynamic只适用于加载组件，貌似还只支持函数组件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../../public/test.md&quot;</span>).<span class="hljs-title function_">then</span>(<br>     <span class="hljs-function">(<span class="hljs-params">&#123; content &#125;</span>) =&gt;</span> &#123;<br>       <span class="hljs-title function_">setMd2</span>(content);<br>     &#125;<br>   );<br></code></pre></td></tr></table></figure><p><img src="data:image/png;base64,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AEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEAAAAII80AAAAAhJFmAAAAAMJIMwAAAABhpBkAAACAMNIMAAAAQBhpBgAAACCMNAMAAAAQRpoBAAAACCPNAAAAAISRZgAAAADCSDMAAAAAYaQZAAAAgDDSDAAAAEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEAAAAII80AAAAAhJFmAAAAAMJIMwAAAABhpBkAAACAMNIMAAAAQBhpBgAAACCMNAMAAAAQRpoBAAAACCPNAAAAAISRZgAAAADCSDMAAAAAYaQZAAAAgDDSDAAAAEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEAAAAII80AAAAAhJFmAAAAAMJIMwAAAABhpBkAAACAMNIMAAAAQBhpBgAAACCMNAMAAAAQRpoBAAAACCPNAAAAAISRZgAAAADCSDMAAAAAYaQZAAAAgDDSDAAAAEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEAAAAII80AAAAAhJFmAAAAAMJIMwAAAABhpBkAAACAMNIMAAAAQBhpBgAAACCMNAMAAAAQRpoBAAAACCPNAAAAAISRZgAAAADCSDMAAAAAYaQZAAAAgDDSDAAAAEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEAAAAII80AAAAAhJFmAAAAAMJIMwAAAABhpBkAAACAMNIMAAAAQBhpBgAAACCMNAMAAAAQRpoBAAAACCPNAAAAAISRZgAAAADCSDMAAAAAYaQZAAAAgDDSDAAAAEAYaQYAAAAgjDQDAAAAEEaaAQAAAAgjzQAAAACEkWYAAAAAwkgzAAAAAGGkGQAAAIAw0gwAAABAGGkGAAAAIIw0AwAAABBGmgEA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" alt="动态加载"></p><p>这样做的好处是，减小首屏资源的包体积，让首屏资源能更快的拿到，从而缩短白屏时间。</p><h2 id="区分场景，让loader有不同的导出值"><a href="#区分场景，让loader有不同的导出值" class="headerlink" title="区分场景，让loader有不同的导出值"></a>区分场景，让loader有不同的导出值</h2><p>更进一步地说，我们未来的博客肯定是有一个文章列表页，和文章详情页的。文章列表页的文章可能会非常的多。如果对于每一个文章，我们都去请求文章的完整内容，是有点多余的，试想每篇文章几百上千字，都在一个页面去请求，也会比较影响性能。在列表页，外显的信息可能只需要文章的标题，tag，或者第一段之类的部分信息。所以我们其实希望，列表页import markdown文件的时候，只拿到一些文章摘要信息。</p><p>但是呢，我们在详情页import markdown文件的时候，有需要文章完整的内容。或许也可以通过，每写一篇博客，就自动生成一个文件来存文章摘要来实现，但是这样总显得有点捞。我还是希望能做到，对同一个文件，可以手动控制import的时候，需要摘要信息还是完整信息。</p><p>webpack的loader是可以接收参数的。我们可以在webpack的配置文件里去写，比如这样（以next.js的配置文件next.config.js中，配置webpack为例)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## ./next.<span class="hljs-property">config</span>.<span class="hljs-property">js</span> <br><br><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> &#123;<span class="hljs-type">import(&#x27;next&#x27;).NextConfig</span>&#125; */</span><br><span class="hljs-keyword">const</span> nextConfig = &#123;<br>  <span class="hljs-attr">webpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    config.<span class="hljs-property">module</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;./md-loader&quot;</span>,<br>          <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">content</span>: <span class="hljs-literal">true</span> &#125;,<br>        &#125;,<br>      ],<br>    &#125;);<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = nextConfig;<br><br></code></pre></td></tr></table></figure><p>我们通过options传参数进去，然后再loader里面可以通过loader-utils去获取options。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## ./md-loader.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">const</span> &#123; getOptions &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;loader-utils&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>) || &#123;&#125;;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options.<span class="hljs-property">content</span>);<br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">content</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`export const content = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(source)&#125;</span>`</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">`export const title = &#x27;test&#x27;`</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>特别注意，loader-utils要装^2.0.0版本的，不能装默认的^3.0.0版本，因为3.x版本里面没有getOptions这个api了。或者不借助loader-utils，也可以用this.query去获取传入的参数。还要特别注意，由于箭头函数的this指向问题，loader非常不适合用箭头函数去写。</p><p>上面的loader文件里面，我们获取options里面的参数，然后根据options里面content的值，去决定loader是返回md文件的内容，还是只是返回一个title字符串（title内容仅作为demo，实际可以通过正则，从md文件匹配出标题，tag，分类，第一段内容等信息）。</p><p>不过问题来了，把参数写在webpack配置文件里，好像每次import的时候，拿到的参数都是一样的。。。也做不到列表页和文章详情页，从loader拿到不同的内容。</p><p>经历了一番文档的阅读和代码的尝试，我终于找到了方法，能够在每次import的时候传入参数。我们要在import的时候，用inline的语法，为这次import指定loader。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## ./src/app/page.<span class="hljs-property">tsx</span><br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;!../../md-loader?content=true!../../public/test.md&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function">(<span class="hljs-params">&#123; content &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">setMd2</span>(content);<br>      &#125;<br>    );<br></code></pre></td></tr></table></figure><p>通过感叹号，将各个loader与最后的文件隔开，然后在每个loader后面用问号分隔，将参数以类似url的query string的格式写上去。</p><p>如果我在文章列表页import markdown文件，那么content就传false。如果我在文章详情页import markdown文件，content就传true。</p><p>最后来看一下实际效果</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABjEAAAO4CAIAAAAcHEOFAAAACXBIWXMAABJ0AAASdAHeZh94AAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AACAASURBVHic7N1/XBTXvf/xg6BR2tDLjyymaGtAqbeQCOGHqTQxyTcKcr/1K1ZsfkjBtDEmIjEVoWkf1lgfjYVgYhEbta3BqGmqVnyYBiHmptEUbyIQJGJKEIhtpHU3LHuDCRhQ+P5x5Dguy7IsMAub1/PBH7MzZ2Y/Mztru++cc8bj2LFjQgghREREhBDiw/pzQohvhYYIAMCgfVjXIPhHFQAAAAB6GePqAgAAAAAAAPClQyYFAAAAAAAAvZFJAQAAAAAAQG9kUgAAAAAAANAbmRQAAAAAAAD0RiYFAAAAAAAAvZFJAQAAAAAAQG9kUgAwsly5cuWNo0c7Ozpsbu3o6PjvN97o6urSuSoAAAAAGFperi4AAHCd48feOvbWX8991JiatnTsuHHaTZ0dHS8VvviPf/zD03PM3ffcO8g3ammxPP3LXz39i5/7+fmqlSWlR+vrG9JXLB/kwYUQ6zc8My9hbmxM9OAPNXgnyyv27H1FvbxjZuyDDywe/GEzVmUO1aEGqbz8ZPaaNeplePit+QUFLqzHVRy56wq2bjO3tKxb+7Pem0bOB9qXgq3b6s7WW61MnBc/bWrIb7b8dslD9zv+jSspPVp8pNTqXwAAAAA9OZpJ7di+Y+vW3+4/sC80NFStPHHixPbtO3btKhyW0gDgS+m7d9517ty5xoaGXYUvpi59eOzYsXJ9Z0fHrsIX//GPfwSHhMR9907XFjka+fv7qRgiY1WmEGLw0UP+5rzBljV0tDnUs7k5z+bmrMnKdm1JI5M2cn35j/uE5k7o9wO1meTqSRVfsHXb1KkhCfFz1KaB3o0J8XO0uwMAAOhvYGP3fvWrZ4apDgCANHbs2CUpP/zmN7/5j3/8Y8/ulzo7O4UQnZ2dMpD65je/uSTlhyqognOeWPn4O++edHUVw+j73190pLjY1VUAAAAA9gxg7N6KFY+XnThxqOjQgqQFw1cQAGDs2LGpaUt3Fb7Y2NCwZ/dLDz605OW9e2QglZq2VM9ASjvk7YmVj4eEBIueriJypdVAp/UbnjGbW4QQifPitcfR7pI4L172zpDjBP38/N5596RcqcYlafs0DbeMVZlLHrpfnqbsaaLOInTaVNktRbZRo6LUCEdtX5Xe51hSevTdk+XqRNZveGZmbIxsfLK84kjJ68N6juHht147x/T0mprTQoh5iYmq89SR4uJnc3Pk8p+LDvn6+j6bmxMefmtz8ycv7txp1VgI8Wxujsq5fv+HncEhIUKIxoaGH//o4d//YeePf/Sw3PTmW8fkgtwkl3OefTYmJlYIYbFYvt/z/yLWZGXPS0wcjnO/etarMp9Y+fhvtvxWvlQ3sPr4ZHc5IYT2DlQf6Mt/3KeCS9kxSg52E0LID1reLQ0Njeot1A0jevoxvXuy3Gxu0ac/nTzfkJBgWZI6d/klVV8udSfLZrI2WW19fYNso76kVicovykM9wMAAENlYPNJ/fznP0tetPjOu+709/fvvTU1Ne1U1SkhRERkhBrQN+O2iP0H9iUvWqzWHyo6tG7d00KIFSseX/bost67L0hasH79006dDgC4ibHjxqUuXVq488XGhoa83JxLly5NmTLlh6lpVjNMDSsZSGl/eKtf5upHacaqzKlTg+VP3PUbnpk2deq6tYuFEC//cZ+MdURPWKMSgYxVmX5+vnKXurP1ifPi5Vu8/Md9fn5+crmk9Oiwnpq5pcXf30+9VKcprk+OCrZue/mP+x58YPEdM2Pr6xtVJvXuyfJ5CXO1B+zrHIuPlLa0WPz8fFtaLGZzS319g4ifI4Sor2+cGRszfCe4+fnnVdyTkZ4+LzFRDut7Njdn90u7Un6YWl5+8khxscyPysuvdRl7Njcn59ln5fqM9HTZWC7HxMbI9SqHkrGUEOLPfz4gN6njWyyWH//oYRl1WSyW+vqzoieQUjvee/fsgJsCZFY1TFTmUlJ6dM/Lr1iFgPmb86zG7iktLRbRkzqVlB7dsvWFdWt/lhA/JzYmWjt2T35H1MuCrdsKtm5TsVTxkVJ1S+jvSMnr+Zvz5J35zrsnn1j5ePqK5bJgm3NOyWrTVyyXX/bYmGh532qnqVq/gf7yAABgKA1s7F5oaOiCpAX5+Vt6bzpx4sSjjy6rfv9U9funpkyZsmP7DrUpedFiuV4IMeO2CCFE9fun3vzrf2/d+tu6ujrZJjU1LWnBAtVMuzsAfDmNHTvu/gcf9PT0vHTpkqen5w8eeHA4Aqmnf/mrjFWZ6k92A5GOlLz+xMrH5XJISHDotKknyyuEEA8+sFj1krhjZqz89a42yfXaH/klpUcT58WrX+aJ8+JPnqyQy/7+fqo7RktLizrssE5z09Ji2bP3FW2otOSh++XCyfIKf79rJc1LmCt7ysyMjVZdZhoaGs3mFqtf9TbP0c/P19/fr76hQR45cV68mp36bH39tKkhQ3teNTWn7717tvxbv2GDzKTKy09O/sZklU99//uLZB+o5k+aJ39jslwZExPr63v1yi99+GEVEq168knZWIZWMpwSQgSHhCx9+OGysr+pt/7xI1f/C9Pd99xTfrJcCGFpaRFCyMP6+vrKY/7l1cNrsrJVkrUmK/utv/51aC+CFfXJxsZEm80t8l51hJ+fr7qH5b42mx0peX3JQ/er+/bBB35Qd7ZevcsdM2NdFUjJYoQQfn6+odOmhk6bKiuZGhIiehI3K6rakJBgdd+WlB69Y2asutuXPHi/bvUDAIAvgwE/dy8jY+W99/yf+Pi5s2bN0q7XvoyPn1ta+rp6+cK2q12+kxYsOFV1Sg798/f3j4iMaG5uDg0NPXHixJQpU9SQwIceejB50WJtFyoA+BLq7Oz44969V65cGT9+/KVLl155eW/q0qVjxw5xLGXzuXty2WxuUWN2pKk9MYp2WNMdM2OFEC0tlmlTp2obq45ILS0t77x7Upt2hU672tLf71pnpXkJc3+z5bfFR0qHaaCT2dyixmpZ9V5RZbS0WOrO1qtmivyVfrK8IjYm+t2TFfKUtfo6x2lTp8oOVvX1DfMS5oZOm9rQ0Ojr62s2twx5WqHmOM9IT//Lq4dlhNT8SfOR4uLec0vNS0yUY/G03Z2EEAEBN6llXz8/IYTFYmn+pDnm+l5d0//zP7Vxkoq0/P385SDB4JCQeYmJ9949WztA78KFCy/u3KkGDMoyhuDM+6Y+WXmTWywWxwedaQdjype99zWbW6Zqrp5MIdW7uHaAm3p3P823zM510K7x9/OTuVVLS0ts7LX4VX3QAAAAQ2LAmZS/v//69U8/tvxx2aFJ68SJE48tv/pf1CMiI9T6gIAAuWAINGjXT5kyxWQ0CSFMRtOhokOHig4NtBgAcFfyKXsff/zP4JCQBx586I8v721saNj14oupaUv1HL5nc+KYjFWZd8yMVQPuHDmOI4+oDwkJzt+cV1J6NGNVpnZenqHi4BxVVjNkKTNjY2S6dLa+3mZvEZvnODM2es/LrwghzC0tISHBU6eGnK1v8PPz7Z1qDaH1GzZ8P2lBXNx3Zdi09OGHVRcnrTffOqamfFKTQPXmdAyxJit7TVb2vXfPfjY3RyVfamKpEU5OHSXvf6twCgAAAENlYGP3pAVJCyIiI6wipHXrnt6+fYccfKc6RjluxYrH5b7qz4nCAMA9qKfsBYeELEn54fjx49WT+HYVviifxKcDNX5Hq6Gh0d/fT6U2LS1XxzT5+fmera9XzeT0ST2b/OrrGx1804T4OU//4ud1Z+sbGhzdZQhZnYVWbEz0O++elFX17uLU1zmGhASbzS0nyytkJ7JpU0Pq6xvq6xunTh3GIV2+vr5LH374z38+IIQIuClADqazKTgk5M23joWH36o6UjU3f6K21teflROl9z5I7d//PnHiREeKefOtY6qYiRMn1v797wM/IReor29Qg/Islj5H/Fl9R+Rt706diaxu7N7/IAAAAAyGM5mUEOLnP//ZunVPy15O0qGiQ889t0kua9c7whBoKDtxwrlKAMDNdHZ27tn9knzK3pKUH8qn7Mkn8clYas/ul/SJpWbGxuzZ+4qaekZ1iVLz8pwsr1ATJMk5d9Tc5C//8U+a40S/8+5JOeGU3Mtm3mTV5colP+zlWahKWlos6ozksKwjJa/bnJvczjmGTpt6pOR1GUKFhATXna0/W1+vHfA1HP7v9+YfKS4uLz8ZExNbU3N690u75HqLxSLjpyPFxdqoJeCmqz2aX9y5s7End8hesyYl9YdCCNmzSR2ksaHhxZ07/+/35tspoLGhQTt1ugyw4uK+++LOnWp9efnJRldnHH5+vipXtaKyGNnTTbUXmpRqXsLc678jf7pjZqw7PZNO3tjqZlZP4QQAABgSAx67J4WGhq5Y8fi6dU9rx+J9+OGHs2bNMpvNVuv7NWvWrMeWP75j+w45h5TZbH77+NtqeikA+FL529vHGxsarj5lb+xYtX7suHGpaUt3Fb7Y2NBQ9re3777n3uGuRE71rUYtyeFmISHBd8yMlSvvmBmrHYP29C9+/vQvfyXnVHpi5ePmnp/6ISHB8rH08gdtX2PoWlqum+/JVT/s8zfnZazKVLNlPf2Ln6tNM2Njio+Uyqmjrdg5x6lTQ+qO1KthfaHTppo1s7kPE19f3zVZ2dlr1vy56NCbbx279+7ZcrZyIcSfe7o5f7/nf2fXZGWr8XRrsrI3P/+8nBNKuz6/oCAjPV17kH5Dw+w1a+TCvMTENVnZQojgkJDf/2GnHC0oNBNguZB8NmLGqszEefHamfUffOAH8nF1Qgj5yapNd8yMlS/zN+fJj1X7HbE58HP0CgkJXvLQ/er05XfcnUI3AADgWh7Hjl2dQiIiIkII8WH9OSHEt0Kt//utfBCe1bzjM26LiIiM2LWrUGgmk4qIjHj00WXbt++Q62fcFrH/wL7Q0FDZRq0XQqxb93RkRITKnuQj+aQ3//rf/v7+Q3qmAOACH9Y1CFv/qNpx5cqVt/7617tm32VzOvOOjo63jx+/+557PD09h6xKQAghxLO5OeHhtw73vOMYvRoaGve8/Ioj87IBAAA4wtFMCgDgBCcyKcBVyKRgX+8OZQAAAIPh5Ng9AAAAuLeGhkbtuEVHHqAJAADgOPpJAcAwop8UAAAAANjk5HP3AAAAAAAAAKeRSQEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9EYmBQAAAAAAAL2RSQEAAAAAAEBvXq4uAAAA9OnkuSuphe2ursLFYqd47kqb4OoqAAAAMMTIpABg2H1Y1+DqEjBafWwaJ4Svq6twsba29g/r/uXqKgAAADDEbGdS/HwCgCEUc/ttLnvvGnNQ4ZWCLEOSwXpL+Xvvu7IwOCZGiKUJri5iRJjs6gIAAAAwxGxnUmHTp+pcBwC4pTO19a4uAQAAAABGIuY4BwAAAAAAgN7IpAAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAeiOTAgD3VLnbGJRpDCq8LER3eq4xKNOYX+PqmgAAAACgh+3n7gEARruolMCmFFcXAQAAAAB9GFgm1XH6pY6Kgu7ONvvNxkU+ekPMykFUBQAAAAAAAHc2sEzqi3ef85oYOebmGDttuv5d3vn+i0ObSdXV1SUtTD5TUz2Ex7QSFj6j6OD+0NBQm1vXrl330blze3bvGr4CAAAAAAAAvjwGOHav6/KYm2NuiHrcTpMvKn97+V/lgypq5NmwYb2rSwAAAAAAAHAfzHEOAAAAAAAAvTmfSXVdbOq6eP7qcuvHXRf/1e8uYeEzyspOyOWyshNh4TPUpiUpqXKT2WwOC58h/w4WHdLurt1UV1cnVx4sOrR27Tp5NPlns/22bTu0h1q7dp3aZDabe7/LkpRU7Ur5LnK5rq5O7atOBwAAAAAAAI5z8rl7XReb2v+yVIz96lcWHRRCtL/+hOj83Hv+Sx5fCbSz18r0FadP18TFzRJCnD5dI4Soq6sLDQ01m81VVafi4maZzea7Zt+r5nUKC58RaDDI9kKIJ1b9RE4pVVZ2Imlh8vFjb/r7+wshDhYdCgoKkpu2bduxJCVVTvy0f/+fVZuw8Bm33houDyXTJXUoqyKfWPWTlekrli9fZvMUzGazemuz2Vxb+6FzFxAAAAAAAODLzJl+Ut2fG9v/srS74/MJ9+XJNRPuy+v64tO2wyndnxvt7HjrreF/KyuTy1sKtm7YsL7mzAdCiNraDxcmLRBC7N//5w0b1quJxjdsWF9SUqp2/83m5+RCXNyshUkLjh1/W76MjIxQEdLy5cuqqk7JXlTLly+TgZQQYmX6CqPJJISoq6s7WHRIzQ8VFzdLtRFCrF277pYpU/oKpIQQslOV3MXf31/lZQAAAAAAAHDcgDMpDyG6u650d12xXu/haXO91vTp36qqOmU2m+vq6hYmLQgP+3bVe1VCiNOnayJvjxRCNDU1aUfVqeFykjY8CgoKMhlNcvmWKVO0zSIjIz75pFkub9u2Qx5qS8FW2b7mzAcr01fYLO+XG34l+pvOPDQ0dGHSgt7jCgFg5GnNzzQGyb/dra4uBgAAAACuM+BMqluIMTd+3Xv+Sx5e49vfyJQr29/I9PAa7z3/pTE3ft3Ovv7+/guTFtTWflhz5oOEhPjQ0FCZ7PytrGz2XXfKNju2v3Cmplr92UmIDIGGvjbddFOAEELOLSWP01cOZcWRpGnDhvVnaqpldqamtQKAkaZyd7tIC2zKC2zKm5Bd3f7I0TZXVwQAAAAA1zg5x/mYG4MmzN81IWGrfDlh7m8mzH9pzI1B/e4YeXvk6dM1Ve9VTZ/+LSHEwqQFckYn2QcqKChIzjNlk3Yy8r+VlQUarmZSH507p21TVXXK39+/rq5OO6avqalJLgQaDGr8oJVfrP35yvQV2lnS7ZA51+7dex1pDAD6i0oJzAiXiz73x3sUV31hcm1BAAAAAKDh/HP3xtw4acxXb7667DPZkUBKCBEe9u2/lZV9dO6cDKEib498Ydv278bFya333nv3loKt2mfzaTsibd6cLxdkbyY1l1NV1SnVv2nz5vyV6SvkweU4QXkc1UDupR7DV1Z2Qht1LV++bGHSAvnQPfkAPqtJ0Ovq6rRrgoIcOmsAAAAAAABoOZ9JOSc0NLSq6tTChUnyZXjYt6uqTt16a7jaWnRw/7JHH5OTQL2wbbua71wIkZAQr+aZkk/WkxYmLTAZTXKTEEL2jQoNDV2ZvuKu2feGhc84fbpGO3Zvz+5dfysrU2+hnaZK9MwnFRY+w2Kx2DwFVV5TU5Od2dABYMRofaW0OzHyhj4HPAMAAACA7jyOHTsmlyIiIoQQH9afE0KETZ9qs/XF30d4TYwcc3OMnSN2/bv8irH6qz96b4gr7cPBokNV71XZn5h88GS/KhIoAAN1prZeCBFz+20urKFyt3F+tdfhPP+o69eXv/e+awsDAAAA8GXmNaDW42Of/KJy6+V/ldtp4zHWe1zsk4OrasTZUrC16OB+V1cBAANWuds4v9qjIMs6kAIAAAAA1xpYJjX2ttSxt6UOUykjUF1dXdLCZCHEhg3rtaMIAWBUMB01za/2KMgyJDFsDwAAAMAIM7BMagRamLRgYdKCYTp4aGjomZrqYTo4AAyvGnNkaXd2WiCBFAAAAIARaNRnUgAAW1rzCy8LIXIKjTk9q7LTAjPCXVgSAAAAAFxDJgUAbsknI88nw9VFAAAAAEBfxri6AAAAAAAAAHzp2O4n5e3trXMdAAAAAAAA+PKgnxQAAAAAAAD0RiYFAAAAAAAAvZFJAQAAAAAAQG9kUgAAAAAAANAbmRQAAAAAAAD0Zvu5ewCA0c501BRZ2n31hWFcVZavwaX1AAAAAIDWwDKptqqdn514rruzzX6zr8Smf3XWTwZRFQBgsAxzDE1z5GJbUe7Fnx9t+90cb9eWBAAAAADKwDKpi2//etzXo8ZOusNOm87z77RV7hiOTCo7+6nGxo/2739lyI/shFuCp/3kyVUrV65wdSEA0C/vb9x8sfjCZVeXAQAAAADXDHDsXtflsZPu+OodT9hp8tk7ouP8u4Mqqg85ORuH47DO+ajxrKtLAAAHtZZVi+w0H1eXAQAAAADXMJ8UALityt3G+dVCCJEYf+Pvwl1dDQAAAABoOP/cvSut56+0fnx1+dN/XmltcmSvW4Kn1dbW3hI87ZbgacnJ9wsh9u0/IF9u2bJVNTt+/G258pbgacePvy1X7tt/IDv7Kbmcnf2UfCnb7Nt/wM6bbtmyVR2tublZewS1SR1ZFZmcfL+dg8vd1bL2jABghIhKCWzKC2zKC1x+4WJQrsXk6noAAAAAQHEyk7rSet5y4IH/PfyofPm/ry63HHig67MLjuw7L/F7HzWelWPfbgmeJoT4qPFs+cn/ee75zbW1tbLNa68VyzZHil9NTXtYBUla2dlPLV2aKttkZz9ls40QQq6XR8vJ2fjYY+naI8yYcZvc1Nj4kTYUm5f4vRdeKJCFZWc/pXKx3rZs2Tpp0iR5kOTFixy5AgCgs6j4cYmmzjJCKQAAAAAjhjOZVNdnFywHHuju+PxriflyzdcS87u++LRlX7IjsdSuwp1yQSY4i5MXCSECAgKio6JMpk/kJjV11PTp06OjomzmTT95ctX06dNVmw8++LvNtwsICFAzkd97z90VlZXaI9x1151yecOGp597frO2yICAALl7Ts7G114r7ut0zp8/HzgxUC7LcwGAEcnzGwZXlwAAAAAAPQacSXkI0d11pbvrivV6D0+b63szGG6SCxMDA6OjotT64OBbLhiN6qUaOldRWamyKi2VBGn3VSMBtYMBm5ub5ZqY2O+Inp5TVkeQCZTapIqUdTY2ftTX6SxdmirH7vV74gDgIm1FhR3FM8ZG9d8SAAAAAHQy4EyqWwhPnyC/xfs8vMZ/WpwhV35anOHhNd5v8T5Pn6DB1yQnnFq5coUcEKfNrfq1OHmR3OujxrOye9S+/QdiYr9TfvJ/5EA8+7vLZKq34OBb+tpl+vTpclSg1aRUAOBSbUW5xqBM+XexOPLGphSeuwcAAABgBHHyuXuePpN8F/9JeHjKl//xvW3CY4ynz6Qhqen90zXaUXXa0XZOqKyoVAPxrMYAGi9c65b1wQd/14ZfJtMncmCgEKK6+v1Jk/o5tcXJi+695+6Y2O8sXZqqdgQA1/FOyvJOcnURAAAAANAX55+75+kz2fPGr19d/to3hiqQktSc4tp5x51WXf2+XFi79mnteu2s6qlpD6tpp+RLuVBbW/vc85sfeOAHoudpgFbBllWFffW0AgAAAAAAgOJkP6lhtTh50f59B+QMTbsKdw5o7F5va9asjon9jpy//Ejxq/MSv6c25eRsXLv2adkPKydno+qZJd9XTRF1pPhVO0nT+fPnHWwJAAAAAAAAyePYsWNyKSIiQgjxYf05IUTM7bfZbG3MDx339aixk+6wc8TO8+90/rvKsLJ2iCsdatnZT0VFR9l8Ut4twdOOFL9qfwhecvL9K1eu0MZYANBb+Xvvi77/UXWt8vfeH5mFAQAAAPgyGFg/qRvjsj57Z3PH+XfttPEY6/3V72YPrqqRrra2tqKykkAKAAAAAADAOQPLpLyjfuwd9eNhKmVU2Lf/gHy43pHiV11dCwAAAAAAwGg1EueT0kdOzsa+Nn3UeLavTYuTF9kc7gcAAAAAAADHOf/cPQAAAAAAAMA5ZFIA4N7ainKNQZmmIpOrCwEAAAAADTIpAHBnpqOfpQuPRFeXAQAAAABWbM8n1dbWpnMdAIBh0PpKqSjIGv9x7iVXVwIAAAAA16GfFAC4rcrd7TkzxicZXF0HAAAAAPRCJgUAbspk2VbtdTjFx9V1AAAAAIANZFIA4Jbaigo7RPyEKFfXAQAAAAA22Z5PCgAwutW0p4txVXO8XV0HAAAAANhGJgUAbqiy6rIwichM47VVucZ0w7iqLF9mlwIAAAAwEpBJAYAbikoJbEpRr1rzMy9NzjIw2TkAAACAkYP5pAAAAAAAAKC3gfWT6jj9UkdFQXdnm/1m4yIfvSFm5SCqGkpr166LvD1yYdKCg0WH1q5dd/zYm/7+/kP+LnV1dUkLk3dsfyEubtaQH3yg1Cn32+yjc+f27N6lT1UAXMcnI4+n7wEAAAAYWQaWSX3x7nNeEyPH3Bxjp03Xv8s7339x5GRSysKkBf3GNHYsSUl9bPmjfUVOoaGhZ2qq+z3Itm07hBDLly9zuowhtGHDeleXAAAAAAAAvqQGOJ9U1+UxN8fcEPW4nSZfVP728r/KB1UUAAAAAAAA3Jre80mVlZ0IC58h/8rKTsiVdXV1YeEzzGaz2lRXVyc3yQF32r3sH/9g0aHex9e+i81K1NutXbtOvqNcf7DokNqxqurUskcf0za2ojbJI6hK1q5dpxpsKdi6pWCrOrIQYklKqlUz2VKV11dV0rZtO9RZmM1m+xfEqoE8pvbi2LxuAAAAAAAAQ8755+51XWwSonvMjZOEEF2tHwsPzzE3fr3fvUpKSuUYNzkBk3Z2pydW/URuKis7od10sOhQUFCQ3LRt244lKal9TYEkQxbZ0mw219Z+2FcZZWUnlj36mM1K1q5dV3Rw/4YN6+X62XfdKcfl2R+717uSyNsj5fHDwmckJMTHxc06U1NtNXZvSUrqwoVJ8nTWrl23bdsOtUmVJ/Wuyt/fX2ZMstnBokNPrPqJ1ZUpKztx8GCRuqp9VWs2m9UVsH/dAAAAAAAAhoST/aS6Lja1/2Vpe2mGfNn++hPtf1na/bmx3x3VHEahoaGRkRHanju/2fycXIiLm7UwacGx42/Ll5GRESqpWb58WVXVqb56KsngRi77+/vbyY9e2LZdtQwNDdW+3cr0FaGhoapC5wKayMgINXfVyvQVp0/X9G5TVnbililTVLOUlIe2FGxVW3dsf0Hb2GZV/v7+6srMvuvOqqpTVm9hNJlumTJFLsfFzeprcnf5leCZmwAAIABJREFUKcit9q8bAAAAAADAkHCmn1T358b2vyzt7vjce942uWbCfXmfH3qw7XCK9/zd/e6+JCVVpSeffNIsoxbRk4lIQUFBJqNJLqtURYqMjJB7aQfiHT/2ptlsjoyMUEezr6rqVNLC5OsOe3ukXDAEGtTKW6ZMMZpMvXeXnZVUPb37bWlrNgQaqt6r6n0Qo8l0sOiQdiCe1k03BWhf9lWV2Wy+a/a9apPZbNZexoVJC+S4v6KD++1cGZnKhYXP2LBh/WCmgQcAAAAAAHDQgDMpDyG6u650d12xXu/haXO9loxydmx/QfbEWZKSaqexNoWxIvMaq+fc2ZxNyQ7tsMGBcvApe/1amb5iMM/gk2MV1Zg7bTilnKmpVgmanZo3bFi/YcN6Oa2V/QALAAAAAABg8AY8dq9biDE3ft17/kseXuPb38iUK9vfyPTwGu89/yX7U0rVnPlgZfoKNTTMaqyZNlT6W1lZoOFqJvXRuXPaNlVVp2xmSf7+/lVVpxxMppwelDeEAg2Gv5WVDeYIVe9V7dj+grwadk5cJmiRkRF99clSztRUr0xfsXv33sFUBWCEMB01BWUar/3tbnV1RQAAAABwjZPzSY25MWjC/F0TEq7OfzRh7m8mzH9pzI1B/e6oUhg527fW5s35ckFGJ9roSoUpmzfnr0xf0VcmtTJ9xROrfiJfms1mO7N6L1yYtOzRx1SO07uY3voaxzcghkBDU1OTXI6Lm1VVdUq9tdls7jcz6k3NVPXLDb/qvfVg0SFtVhVoMMiHG/Z+IqF2TVBQ/58jgNFhxoSmvMCrfyk+rq4GAAAAAK5x/rl78ol7V5d9Jjuyy8KkBQcPFsl5oHZsfyEyMkK7NSEhXk0RpR1ltjBpgclokpsWJi2wM9hNblIHOX7sTTuVCCHUYLeV6Sv6LT4hIX7Zo48Ncmjb7LvulBM8yZmbztRUh4XPUFOb2ynYplWrMu6afa/cvejgfqsZsiR1jhs2rI+Lm9VXd6pljz4mFxYmLVDz0AMAAAAAAAwTj2PHjsmliIgIIcSH9eeEEGHTp9psfXFH+Liox2+IetzOEb+o/G1H5W9vXGbjSXN9kRMe2Zzt6GDRoar3qkhJhoPsojWYCa0A9OtMbb0QIub22/R/a9NRU+SF8Xa6R5W/975LCgMAAAAAMeB+UmO8uv5d/kXlb+006fp3uYfnuEEVBV1sKdhadHC/q6sAMJyq24Oq24UQQngdzvOPcnE1AAAAAHDNwDKp8bFPflG59fK/yu208RjrPS72ycFVhWGkHsO3YcN6nq8HuDHDHEPTnKvLlbuN8zPNxFIAAAAARo6BZVJjb0sde1vqkBchHwxnc9PCpAVy7icMFTtXG4C7ioofl1jd+U+TiDK4uhQAAAAAEEI4/dw9AMBoYuoqdnUJAAAAAKBFJgUAbq81v/CymDE+iU5SAAAAAEaMAc5xDgAYJSp3G+f3jNPNTgtsCndpNQAAAABwPTIpAHBPUSmBTSmuLgIAAAAA+mA7k/L29ta5DgAAAAAAAHx5MJ8UAAAAAAAA9EYmBQAAAAAAAL2RSQEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9EYmBQAAAAAAAL15Dah1W9XOz048193ZZr/ZV2LTvzrrJ4OoamhkZz/V2PjR/v2vuLoQAHCZyt3G+dVCCCEM46qyfA0uLgcAAAAArhpYJnXx7V+P+3rU2El32GnTef6dtsodIyGTysnZ6OoSAMCFWvMz23NmTGjK83F1JQAAAABgbWCZlOi6PHbSHV+94wk7TT57R3Scf3dQRQEABs109FLOjAlNKQRSAAAAAEYiveeTuiV4Wm1tbXLy/bcET7sleNq+/QfUpi1btsqVtwRPa25uVuv37T+g1h8//nZy8v02d+n9Xvv2H8jOfqr3QbQHBwA31VZW1Z0dSSAFAAAAYIQaYD8pjSut54Xo9vSZLIS48uk/hYenp0+QIzvOS/xe+cn/CQgIaG5ujon9zsTAwLvuulPmRB81nhVC7Nt/4LHH0uU8UMePv52d/ZS2fXRUlDzOli1bz58/r3ZJTr6/r6mjjh9/e/++A7Ll8eNvO33KADB6XP7Y5DFZWB7J7CgWQgiRnRaYEe7imgAAAABAcbKf1JXW85YDD/zv4Ufly/99dbnlwANdn11wZN9dhTsDAgKEEAEBATk5G197rVgur1y5Qja49567Kyor5fKWLVut2sv1zc3Nzz2/Wb1cnLyoorKytrbW5jteMBqDg2+Ry3fddac8GgC4u+70YvGrvMCmvMCmNK+cQlORydUVAQAAAEAPZzKprs8uWA480N3x+dcS8+WaryXmd33xacu+ZEdiKYPhJrU8MTCwsfEjudzc3CzH1sXEfke+FEJUVFZ++9v/qW2vGgsh1HA8m2P3lMXJi+TYvb5CKwBwRx4FaT0P2gufUGDoLq7u56mpAAAAAKCbAY/d8xCiu+tKd9cV6/UenjbX90v2YJJzP2nH6PW7Y3RUVF+D9Xr7qPFsbW3tvMTviZ4RggDg1rwmG7o/NglhuLbq1pu9XVcPAAAAAFxnwP2kuoXw9AnyW7zPw2v8p8UZcuWnxRkeXuP9Fu9zZEopk+kTtVxd/f6kSZOEEJUVlWqMnnYO8uioqA8++Lu2vVwICAioqKwc0Gzl06dP/6jxbHRUlHZidQBwU95xkR45xZarw/Vq2tNNXnHMJwUAAABgxHByPilPn0m+i//0H//v9/Llf3xvm+/ifZ4+kxzZNzXtYblQW1v73PObH3jgB/KlypvWrn1aNU5evMiqvVwOCAhYnLzoscfSVcstW7aKngGAVhOZ79t/QJteqQGAAODGDHMMh2/uiMw0BmUagwrF4Tz/KFeXBAAAAACK88/dk0/cu7r8tW84vuOuwp1q+qcjxa/KvlFr1qyOif2OjJyOFL8qB9kJIRYnLzJeMMr2i5MX7SrcKedEF0Lk5GzMzn5KHWpX4U47b6oGA+bkbLzrrjsdrxYARq+olMCmFFcXAQAAAAC2OJ9JOc1guKn3jE4BAQHaldrllStXqEfy7dt/QI71k3JyNqpH7/U+jvGCUTZenLxocfKiIT0JAAAAAAAAOG+AmdQYr87z73z2jr0mneff8fAcN5ia+lJbW5ud/dSR4lcdbP/c85sdbwwAAAAAAADdDCyTujEu67N3Nnecf9dOG4+x3l/9bvbgqrpGPo9PvZQP5rO/i3q+Xk7OxunTpw9VJQAAAAAAABgqA8ukvKN+7B3148G8X+9Re/Y5MexOPl9vQLsAAAAAAABAT04+dw8AAAAAAABwGpkUAAAAAAAA9EYmBQAAAAAAAL0N8Ll7AIBRwWR5JLej+Pp12WmBGeGuKQcAAAAArNjOpM42/MPmev+77xvOYgBgRDO/9YarS3CYwfd3eZqXJssjuZ2TDS4rBwAAAACsMHYPANxfZWlH8YzxSWRSAAAAAEYMZ8bujaaeAgAwFEZ3L1GTZVu1yE7zcXUdAAAAAHAN/aQAwM2ZqjuLDePuZyYpAAAAACMJmRQAuLfWV0q7sxN9GbcHAAAAYEThuXsA4M5MRy/lGMZV0UkKAAAAwAhDPykAcGOtr5R2J0beQCcpAAAAACONM/2kfF69x36DL6alfDH9YafqAQAMnZrOHOF1eI63q+sAAAAAAGtjIno4vs8X30qz83fFf8YNDa8MX8WDV1pSsmlTnhCisbFx7pz7KioqXF3Rdfbu2bN3z56+ts6dc19jY6MOb+SguXPuG/xB4Dh199rZNDJv7IGyeX9u2pT35KpVLqlndGrNL7ycGD8hytV1AAAAAEBvzvST+iI01X4DT3O1U8XoLTg4+PWjbzi9u/zB/NCSJUNX0egzmAs4SE+uWvXQkiXR0dHO7d7vx2exWH6wOPlP+/b7+vo6WaKLOHdjO3099fwirF6dqcO7uBGfjDwfV9cAAAAAALYxnxQAAAAAAAD05vxz98a0XRAe3V0TbhZCjGn7V7fw7PYOdOI4sjeKXE5NTZO9LRobG5c/uuxP+/arTdu27wgODra/ySbZ3ur4ytw596ndtZWsXp0Zn5AghCgtKak5UxMeFi5HRcUnJMieGnPn3Cdb7tpVqBpb2bQpLzwsvOZMTWlJiRDiT/v2WywWWUxYWPjzmzerlnv37Nm1q1Aef2LgRIcv3rUyxPVdlp5cterMmZoBvZHaRZ2jvHTPbPz1z576qVpp8xzVtVLDyux0L7L5iWhXat/L6hrKS60a/+ypn4qeG2BoPz51LvKYrx99Qx5qYuBEuYsQouZMjaqzoqJi75496lKr6yzsdiWTZ9fc3Kw+FO2VVzv27rFVUVEhz72v42tvbO35Wt0Pks3rKWzdErJm+VnIQznyRbD6FJ7Z+Ovo6Gi1o/a8+v0iyEPJYhy83wAAAAAAI5OTmdSYtgtf+Z9VXV5f+Xz2H4QQE8rXelxua4vL7xp/00APVfzaa+r35Nw5931r+nQ1euiX69fL39sVFRUyh1I/O+1s0pI/ttVvbPlb2ib5s1+1nDvnPv+AAFlJaUlJeFi4fLu5c+6bPfvu6Ojo14++4ciQpU2b8rZt37F6debePXt+sDg5PiFBHufJVatKS0rkD/i9e/ZUVFSo0/nZUz9NTU3r97rJguXPe1nk3Dn3qYOoQVibNuXt3bNHFmnnjZ5ctSohIUGmFdpdhBDHjr3lyECwioqKkpISdfC+mtn8RGQx6kPctClv06Y8bQgir6HcN3bmTDk2TTvWbMg/vviEhNiZM62SoNKSktWrM+Wh7NxLe/fsuWC8oJo9uWpV7xhI2bQp75mNv1Z3hfbK96W0pGRi4ES5y949e+wfX561NqTr3aD39RR93BJ79+xRby0P5eAXQX0KKk1T9e/c+Qf5WQ/oi+Dg/QYAAAAAGLGcGbs35tInX/mfVeJye3vUL+Sa9qhfeHRe/ErZyjGXPhno0R5askT95k9NTTM3N6tNv1i3Ti5ER0fHJyScfPddRzZpFRUdXL06U/UWsdmJQyp+7TVty9WrM48de0suh/X0A5IVflhb6/jZpaamyWN+Z9YsIURS0kJVdnNzsxDCYrHs2lVodTqOHLn4tddSU9NUghCfkBAWFi5/nEdHR6v1s2fffcF4wf4bVVRUTJo8Sb1MSlqo+vgIIR5++EeO1GNubp40eZI6eF+dVmx+Inv37Hlm46/VLg8//KPSkhKLxSJfqmsYHBwcFhbe0NBg82oMx8dnRXuovsjrrAK1+ISEM2dq7ExLr/0QV2ZkaK+8nTJUAPTQkiX2jy+jT1W2g3dXX7fEBeOFgICAAR1K1Szby5NV1+db06ef//i8GPgXwcH7DQAAAAAwYjnTT6q7q6u7q8vDaq2Hp1zvxAG1A520PSO0vzMnBk5s1sRVNjepUUWiZ3xQaUmJg5HKBeOFXbsKtU80Uz+J1U9fIURAQEDNmRoHz0u21xasylbHsVgsYWHhVqcjF7TD2XoPubpgvDB79t3aNdHR0SrR047tCgsLt/9G5ubm0pKSvjr+OPhrPz4hQV5/+0MpbX4iZ87UhISEaN8xLCzcYrHIt1bXUAgxafIkbWqpDNPHZ0V7qL7IKE07ptI+7dnJ81VhnINlhIWFt7S09HXNa87UWN0njujrlkhKWrj80WWbNuUNdA51bc1hYeH+PWft5+d3pr8vgk0O3m8AAAAAgBHLqUzKO7AtLv8rZRkTKn95dexe5S/FmBva4vKdmFJq7pz7UlPT1EAeOy21v95tblq9OnMwj+VS4+BGCKcfC7hpU975j8+rYU32r6rUe6YtJ7x+9A2Vo+n/PL6R8/HZnLPJcb6+vv3GUlb8/Pycfru+2Lwl5D0pB4r2NcWYblx7vwEAAAAABsnJ5+51eU/8/Lu/aYvdKF+2x2z4PC6/y3sAk3NLjY2N2oFIcpSZov1lXlFR4a/JpOxs0uprqFdvEwMnDmZUl9N8fX3PnKmxOh1HduxdsLoOpSUlagyU6lVk5438AwKGakYemVmEhYX31evK5iditdJisZw5UzOg0Vj6f3z+AQFy0Jlk5zrbp+3919DQIDu1WXWYsjqa9n37vVbOXRn7t0R8QsKf9u0vLSmxM2ZwoJz7IvR7vwEAAAAARiwnMykhRNeEm7snGK4ue3/diUBKUj9EKyoqrH5Y7tz5B7kg12t7wdjZpPXQkiU/e+qn6oeunR+u35k1a9euQvUzuKKiot/f2wEBAVYhmhN8fX3jExK0p3PGscFlif/1X9qCra6DjHgsFosazmbnjaKjo8+cqVHdqSwWixO/8LUzQAkh+koJbX4iVit37vxDampav5mUdhzfcHx89kfShYSEnDlTI9+x93X+5fr1qqX9fmq7dhWqUn/21E9lPitHLxa/9ppcvyU/X7vLmZ6nEAoHrpXN+8Qm7fXs65awOhc1uHJYvwgWi2XunPusIioH77cvvbaiXGNQ5tW/fOfHrQIAAADA0HPyuXtDJTg4ODU17QeLk4UQqalpVo/Zmj37bjUvj9XYHDubtKKjo5/Z+Gt5fCHEMxt/baeSbdt32Jm/qbfYmTPljDbqoWbOWb0688lVq+TprF6d6chD94QQvr6+f9q3X52atuBnNv5aTiYVFhb+zMZfqxzBzhu9fvSNuXPuU7N6/WnffidORBWzenVmXymhzU/EaqWDAwlnz777Z0/9VD6Vb5g+vtTUtL6Ghvn6+tq5zps25an7085dJxtvyc+X+Yv2uv1i3bofLE6Wn4j21IQQ8QkJzc3N8vjxCQn2r5XVfWLn7rK6njZviQvGC+q8tm3fITMpV30RHLnfvtzainIvFkfe2DTHWwghasxBhabJWYYkg6vrAgAAAAAhhBAen376qfb1h/XnhBD/8bWv2Wztf/d9QojPdqTYOaJXc5Wn5YPW/3p9MGXJaWJshk12NkF/T65a9dCSJSQCztm0KS/cgWf5QZHB3+DnPnOC/NfP/NaA/+X5308/FULE3H7b0NfUj9b8zHaRFpgRLoQQwmR5JLcz8fpMqvy9911RGAAAAAAI4Vw/qRs+LLSztdtzwqX/XNZ7vfYpcop7REtufGqKzXPctn3HmTM1fQVSvZ89N2IfkTbcpY6oO0T7eEppkP2btIb7Su7aVbht+46hOpq787k//lJkoVGkBWaEtxUVdhTPmPA7OkkBAAAAGDGcyaRav/dXJ/Zy+ilyI58bn5pidY6lJSWbNuUtf3SZnYBgFF2T4S51RN0hg3w8pX3DdJoq1Fu9OnNkxpojk2GOoWmG5ZFcY5AQifE9g/gAAAAAYGRwZuyeE6NXAGBUG4Vj9+QcUpez0wIzDJZHcjuKDeOqsny1PaUYuwcAAADAhZx/7h4AYARrzS+8nBh/Y0a4EAbf32WNSzR1vMKj9wAAAACMGGRSAOCOTFdOC3HrzT3j9Qyet7q0HAAAAACwQiYFAO7IcEOiQeRUtcpXpqOXcoTHZOY4BwAAADBi2J7jfFrIN22ub7G7FQDcldP/+pW/9/6QF+MY76Ssyx9ntgdVtwshhPAoyDIkkUkBAAAAGDGcee4eAGA08MnI88lwdREAAAAAYBNj9wAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAeiOTAgAAAAAAgN7IpAAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAevNyYp+WydOGvA4AwFBrK8q9mG4SQghhGFeV5WtwcT0AAAAAcA39pADALbUV5V5Mv3lCU15gU17g4Zs7Ine3urokAAAAALhmYP2k/D4+O0x1AACGkumLYpNHQZqPfBUVPy4x91JRvE8SfaUAAAAAjAz0kwIAd+X5DZVAGTxvFd0fm1xZDQAAAABokUkBgDsyeN4qLm872iZfmY5eynFtPQAAAABwPWfmOAcAjHg+GVlXHsm9GFR6UQiRGD8uW3S4uiQAAAAAuIZMCgDclMH3d3k9yybLI6UeiUwmBQAAAGDEYOweALg/U3VnsWFsHJkUAAAAgBGDTAoA3JzpqCmyVBSk+RJJAQAAABg5GLsHAO6pcrdxfrUQQgjDuKo8AikAAAAAIwuZFAC4p6iUwKYUVxcBAAAAAH1g7B4AAAAAAAD0RiYFAAAAAAAAvZFJAQAAAAAAQG9kUgAAAAAAANAbmRQAAAAAAAD0RiYFAAAAAAAAvZFJAQAAAAAAQG9kUgDgBlrzM41BmebK69dW7jYGZco/600AAAAA4FpkUgAwytWYgzI7J8d7WK02HTXN//e4qrzAprzAwzMuz8+1mFxSHgAAAADYQiYFAKNaa37xmKo8/7he618p7c5O9DUIIYSIih+XaOp4pUb36gAAAACgD2RSADCq+WRkXQ2erlPTmSO84sKvvqos7SgW4vS/23QtDQAAAAD65uXqAgAAw8MwZrIQQrTmZ7afjr/xsLg4/8JlV9cEAAAAAFfRTwoA3FeNOSjz0uSswN/N8RZCJE7kv0MAAAAAGCn4fQIAbsrUEVk8rirP3yCEEG3//LcQE11dEgAAAAD0IJMCAHcUPjZbXBaJaqqpyx+bPBJneLu0JgAAAAC4hrF7AOCWfOJmiJxCc6UQQojK3e05hrFxNuZCBwAAAADXoJ8UAIxqbUW5F9NNcvny/EyjEB4FWYYkg4hKCTwsjPMzjUIIYRhXZfPxfAAAAADgImRSADCqeSdleSf1sS0qJbApRddqAAAAAMBBjN0DAAAAAACA3sikAAAAAAAAoDcyKQAAAAAAAOiNTAoAAAAAAAB6I5MCAAAAAACA3sikAAAAAAAAoDcyKQAAAAAAAOiNTAoA3EBrfqYxKNNcab2+rSjXGJRpKjK5oigAAAAA6BuZFACMcjXmoMzOyfEe1utNlkcyPxORXq6oCQAAAAD6QSYFAKNaa37xmKo8/zjr9W1FhV3L8wxJN7uiKAAAAADoD//9HABGNZ+MLCGE6DU4zzspy1v/agAAAADAQfSTAgAAAAAAgN7IpAAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAeiOTAgAAAAAAgN547h4AjGptRbkX068+de/y/EyjEB4FWYYkg6jcbZxffbVReq4xXYjstMCMcJcVCgAAAABaZFIAMKp5J2V5J9naEJUS2JSidzUAAAAA4CDG7gEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9EYmBQAAAAAAAL2RSQEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9Obl6gIAAIPXmp/ZniO8Duf5R1mvFEIIMWNCU4qPa0oDAAAAAFvoJwUAo1yNOSizc3K8h9Xqyt3tIi2wKS+wKW9CdnX7I0fbXFIdAAAAANhEJgUAo1prfvGYqjz/uF4bolICM8Llos/98R7FVV+YdC4NAAAAAPrG2D0AGNV8MrKEEIK8CQAAAMDoQj8pAHB7ra+UdidG3mBwdR0AAAAAoNBPCgDcXOXu9hzhdXiOt6sLAQAAAIBr6CcFAO6scrdxfrVHQZb2eXwAAAAA4HpkUgDgtkxHTfOrPQqyDEkM2wMAAAAwwpBJAYCbqjFHlnZnpxFIAQAAABiJmE8KAEa1tqLci+lXn7p3eX6mUQjZMao1v/CyECKn0JjT0zQ7LTAj3EVlAgAAAMD1yKQAYFTzTsryTrKx3icjzydD92oAAAAAwEGM3QMAAAAAAIDeyKQAAAAAAACgNzIpAAAAAAAA6I1MCgAAAAAAAHojkwIAAAAAAIDeyKQAAAAAAACgNzIpAAAAAAAA6I1MCgAAAAAAAHojkwIAAAAAAIDeyKQAAAAAAACgNzIpAAAAAAAA6I1MCgAAAAAAAHojkwIAAAAAAIDevFxdAABgmLTmZ7bn9LzITgvMCHdlNQAAAACgRSYFAO7KJyPPJ8PVRQAAAACATYzdAwAAAAAAgN7IpAAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAeiOTAgAAAAAAgN7IpAAAAAAAAKA3MikAAAAAAADojUwKAAAAAAAAeiOTAgAAAAAAgN7IpAAAAAAAAKA3MikAcAOt+ZnGoExzpY1NbUW5xqBMU5FJ96IAAAAAoG9kUgAwytWYgzI7J8d72NxoOvpZuvBI1LkkAAAAAOgPmRQAjGqt+cVjqvL84/rY+kqpKEgbf6u+NQEAAABAv8ikAGBU88nI8jX0sa1yd3vOjPFJfW0GAAAAANchkwIAN2WybKv2Opzi4+o6AAAAAMAGMikAcEttRYUdIn5ClKvrAAAAAACbvFxdAABgGNS0p4txVXO8XV0HAAAAANhGJgUAbqiy6rIwichM47VVucZ0w7iqviefAgAAAAA9kUkBgBuKSglsSlGvWvMzL03OMjDZOQAAAICRg0wKAEa1tqLci+kmuXx5fqZRCI8C4icAAAAAIx6ZFACMat5JWd5J/bTxycjj6XsAAAAARhaeuwcAAAAAAAC9kUkBAAAAAABAb2RSAAAAAAAA0BuZFAAAAAAAAPRGJgUAAAAAAAC9kUkBAAAAAABAb2RSAAAAAAAA0JuXqwsAAAxea35me47wOpznH9WzynTUFFnafa3JjAlNKT6uqA0AAAAAbCCTAoBRrsYcVCgK4j1Eaa9N5FAAAAAARirG7gHAqNaaXzymKs8/ztV1AAAAAMCA0E8KAEY1n4wsIYQwuboOAAAAABgQMikAcF/V7UHV7UIIcf1UUwAAAADgcmRSAOCeDHMMTXOuLlfuNs7PNBNLAQAAABg5mE8KANxfVPy4RHHlnwzwAwAAADBikEkBwJeAqavY1SUAAAAAgBaZFAC4vdb8wstixvgkg6sLAQAAAIAezCcFAKNaW1HuxfSrg/Iuz880CuFRkGVIMojK3cb51VcbZacFNoW7rEQAAAAA6I1MCgBGNe+kLO8kWxuiUgKbUvSuBgAAAAAcxNg9AAAAAAAA6I1MCgAAAAAAAHojkwIAAAAAAIDeyKQAAAAAAACgNzIpAAAAAAAA6I1MCgAAAAAAAHojkwIAAAAAAIDeyKQAwA3JIj2XAAAgAElEQVS05mcagzLNlb02VO42BmUagzKNQbkWkwsKAwAAAADbvFxdAABgcGrMQYWiIN5DlFptaM3PbM+ZMaEpz8cldQEAAACAHfSTAoBRrTW/eExVnn9crw2mo5dyZkxoSiGQAgAAADASkUkBwKjmk5Hla7Cxvq2sqjs7kkAKAAAAwAjF2D0AcEuXPzZ5TBaWRzI7ioUQQmSnBWaEu7gmAAAAAFDIpADAXXWnF4uqvMDfCTnnlGlyliHJVpcqAAAAANAfY/cAwF15FKT1DOsLn1Bg6C6ubnNtQQAAAACgkEkBgFvymmzo/th03apbb/Z2UTEAAAAAYI1MCgDckndcpEdOseVqKlXTnm7yimM+KQAAAAAjBvNJAcCo1laUezH9avJ0eX6mUQiPgixDkkEY5hgOXzBGZhqFEEJ4Hc7zj3JhmQAAAABwPTIpABjVvJOyvJP62BaVEtiUoms1AAAAAOAgxu4BAAAAAABAb2RSAAAAAAAA0BuZFAAAAAAAAPRGJgUAAAAAAAC9kUkBAAAAAABAb2RSAAAAAAAA0BuZFAAAAAAAAPRGJgUAAAAAAAC9kUkBAAAAAABAb2RSAAAAAAAA0BuZFAAAAAAAAPRGJgUAAAAAAAC9kUkBAAAAAABAb16uLgAAMExa8zPbc3peZKcFZoS7shoAAAAA0CKTAgB35ZOR55Ph6iIAAAAAwCbG7gEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9EYmBQAAAAAAAL2RSQEAAAAAAEBvZFIAAAAAAADQG5kUAAAAAAAA9EYmBQAAAAAAAL2RSQEAAAAAAEBvZFIAAAAAAADQm5erCwAADF5rfmZ7jvA6nOcfJVeYLI/kdhRf3yg7LTAjXP/aAAAAAMAGMikAGOVqzEGFoiDeQ5RqVhp8f5eneWmyPJLbOdmgd2kAAOD/s3f/MVJdB77gDwkmBMvodXe2sHECmwyZMVEnjtcQbGXHViyZziC3EcFkHXscjOaBog3LGz2gLbZf5s04YRDQjHZZLFlGK2P52YkMDMJtMWlQ8NqjN7jpZjw4LeMkxH6QAZvSdLMDC2aw89g/qrq6ftyqrv51im5/PkKo+tate8+999xbt751zikAytF3D2Bcu7D9wKfebGv4ZsWZjnVcPXD71CUyKQAA4LohkwIY16avaakbJGtKn3/6eHjijulxCgQAAFANmRTABJc+/tGB1JSHjSQFAABcT2RSABPbhZ91XHti0WBtqQAAAOIyxjnARJY+dGVzasqbGkkBAADXGe2kACawCz/ruLbojs9oJAUAAFxvtJMCmLh6PtocJr98/7RalwMAAKCYTApgXLu8b8vF1enM448fXHcuhEk7WlJLUiGEC9t3fbyo6aY7a1o+AACARDIpgHFt2pKWaUuSn5q+pm163MIAAABUy3hSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAABMWLvr6wedcp2oVcGK1lu5GMPYn8M+BNXMdt0eTaAafncPAACYsJb19e2ur1/W1zfonIOmG9Us5JMgt6NyOyR/15XupaJDUOXhGEnBitY+FusCRoVMCgAKdW/bvXBjCM2zep5bMLPWhWH8S+9d/trK9hBaG/vWzi18pnPF+rBRNYOoKgQiRdPHLjqpoEIuNnY5TumSy2VMmZkTA6Zyuyu3qPxlZh5X3qLSdVUofOZB6fxaUcF1Tt89gAngwvZ1525d13usYOLlfVvO3bou+297T5WL6jpcX3+4e/SLOJ7MW7usr+/eneF06550/vQ3NnZO2nh6uEtN712+e0XhAru3te9Nl5u/QPe23fXbTgx31QzfIMeoqvMltfS5ZX19jRs29mztKnpmwQ+/drqx6iP7zy92T1r6q3+ucm6uL6d/PKnzx0eSnvngV9+d1PndF3sHHoy2cteuUa9R3dt2V/0OcmJr/e76+t319cUXxlGVXUV9fYXHI5DuXFGfW1T/taJg4u765Z1nC1+zd3nezAkywUriv4GZzu5pT15FNUUquOYk7pzkleYFQJnoJxTmULmJFTaq6HEFpesaBWN0Llw379GZ2pVU8fLqQMEZ13U4VzHy36HKVrBKKx/aKoazFXmLqrJU3dtydbvg0pS3gdXeiWU3sHC9BTuq+ORKNHDpK157mR0V7QI+pipuhUwKYJzr6b113UdfaJpUOPXyvi0XD9xx05m2GWfaZpx5fPLmXel9Je+5CW/C3a/3Ln6mcd5YFTbJ6KVgZ/e0V3vnNLjU3c1T958q+HB415/9u2X/6cIbw1te+r1X2ht++FAqhBDCia15dyFn97SP5Ucy+g2tplV1jIZyvsz9Vmt4+1TxQuatbdywsafKCvD5R1JP/u3Fv/+gqvVFlJC3RjN6Z/1Yb8WsFS98+i8Olw21v/rFhqIHo6jctWtYNWroOyr51Ju7vm9ZX9+9O5uHtPahKs10yqY8Q9Z1uP6201/pyC2qeWkq99zUne9kJt67M5xuLMiM3nslzNrZeuWV14df2bq37W5cdePB3Fbk2lpWVaTSa07+3qjcKCk3T+5x0cyj1ZKrqBjlYqn8QK2qVY/quTB0Y/y139k9na803ztQ8QbykRNbcxXjnVlh1Wv9kceJrU0hW5E6GjY1DbzrzXyoub9WJHxFl2TIqxjyVnQdrs8tqngDyy2qfeFbs3r6lvX1LTvY2rswdyZ2Hc6dQT3PhJW3DX5Qzu5pr18fHmhNeq61ceCSUtQaOlnuZMw/ScvuqBpfwEdJxa2QSQGMaxe2H/jUm20N3yye/vHv0uGrt0zL/pX61KKkF6eKJ6Q7n9o49YF7SqaTcfPnlnzn0t8MqxVD9/On97fe0h9ezF3ftyCs371w45WVt+1uDQuefcg+v95UcYxG53yZu76jYf+qnuo+pcy6/ye/f+T/HnZjPWrp8/fdtOw/pX9a+vnh5s9+tejBqCt77RrlGjVv7bK+vvuifqtRO2dPXQrNsx6dX3mu1NKtsxa3p4/kAu7X06H5i0vvadjf/l5JllplsJI+9VZITMOrK9Lcb7WGom9c8lRTgPxGUon/Sl8ypEZqifshMZYqzRYH24exzoWamPlQc/9bVWrp6oaw8f3MO8vZPSc35SpGasEPW8OmHZl0Zu763Ak7v3Fnc2JUmpr9tQoVJmtkq6huK05dCs039nd1T83+WuXFhBBOvLDqyobV2cR23mOzFreffqErhJDeu2Pg+6SZD83ZEHqfqhzTpDtbT83pe27B7EHXOXzld9TEqLSVtkImBTCuTV/TUpf0kXj6w02TNu/KdNm7vG/X1QO3T10y6Efns6+n97fOWVrdR+y85tB5X7nkdxAY+GY4vXf57q1dA42xs9+eZVopN/WG0LuwtLlyYiPwdOeK+sPdA08d7r/faq+v39246kpoP92Y1Bi7e9tQmmeX1fC9dTfu3vsvRS2l39jY+d0Xe9/Y2DlpUuek5K43J17dOHXnY8nfnn1ldrWhRm6fF3zHVWmfD7xkYJ8v79y7LbOQE5kjktvn+cd04EB0Ha5f3nk216S8fxXd20o7jAy+h5Na0Z/YWlDyE1tzrd+LVp3/9XLyVoeze9rrt50YaACfW06FmlaFxGM0pPOlkvm3bAi9rxaXJ3O+FH95m/xN45GeSUt/9c9HejI1sKgxf0HPgoFvlfM6R+QduO5tu1fsSQ9e07IFyyzktZXtYf+q14bSnyK/80Jyz4WBog7rrE/ul5FcmYe9FUN08x/9x5/8ft/hhDvyH11b8KO78x+MuuRrVyhXo4a+o/J2eF6lHeapl1c9ittBJJ8XoyQxW6kYuGQ/4lZ06tL+gT/SR9qvfGV2Ksy+MT+oqliG5FWXDbIHLVK686mNYcM9lVtzVA6MQl4jqUodDPNU2Xcv1+KptAC56eWeCiWBVGL7qVE5FzIGKurCjQUvSngzHcYNT/5TI+oYmD7SfmVx8xdn9i/wqY0htF+q+hJ34tXBK8wIV1GVmQ/N2dDe3+qw6/DC8rdVWV3vbwoN3+qPaLufP70/hLdPpUP6vVfaB75POrvn5KZQGLp1HS4+EKkFz1bVAKrYmN58htG7gIdyd4CF0wteknBL0C+50lbYivCvhY4eO3702PFrAIyGaBfVcwfPzVz7L93FU/v+/doPZq794N8fvJRYtnOFU97eUvfSlqNVra+r7aW6779xpnh9bzyet4S8ec7t+f5Ldf1Pndn9cl3dL7oGCvKLgj8TFvX2lrqXHt99Lje9f/5ze77/Ul3b27kXndn9ckKpcoWpe3nPuaTnykks2LV/efE7bzz5DwWTjvzkjRDeWPbCv1y7du3aP/wyhK4X3y+YoaRgb2+pe3nPuWtdbZn/+7euvK62l+pyO+HoL/K25dyettyS83ZU/z7P7p/cthz9RWY5Z3a/nDkiXW3ZeQqOaf7+P/qLurrcU0XHYmCX5pYzyFb0r6KwGuQWW3hMC1ad91TZmpZZbK6GFFbp5ANazqDHaAjny7Vc2crXz5LlZ45gQoGP/KS/suX8wy9DeCN8553fXbt27dqpJ8PADMWnW/7CC/Zz9lCWr2kVtvfcnu8PXofz5FfUPEUVu/BwD+msL9jq/MWWq8xD3or+8yvvX1Wvff+dZeGXR6pbx2hLuHZlJNSoYe+oxLOs0qlXurSS61jBhaXseZGk+BiV+Vd5CZVWkDlf6opOjYJrY+EmnHvj8byaPJSzpqgwb2/JFr54V5Qv0sAmF57I5fZG7nHRTsifnvja0p2WuNjEOSs8VW7mQY5RklE5FwrOi4J3wKO/yO3hEd3w5D076NtrifyKd27P9wtvwArfvvPKVjAxV5eqqKjDXMVQtqKoVFVcBI7+oujAZQ9T4WlY1/Z28ftI/51S6SJL73777zoqnI9Fm5w7ecvv24QdNcYX8DKVtvjx9wtuOMveApWttOW2QjspgAmqp/fWLVe/+viMMy1TQsfFW7ecT2iPXfBX1/ubBm/zH0LIdlnaubX4x8LOvp7en7eEeY8VdFhY/My96+eHEMLMe1KLw6WScXVKFtXauD67qLmPPjM1r5vD1J3vZJo3p+5unhreulDNF3Hz1haNrFGF+ff19d3yavFXPQ1/vDRpUJif3PLSIw0hhHD39CfD70++l/9c+kj7QOvxzBatzyvMvLXLquq719qYnW3+LRvClXdPZaamlq7NLbmkR0buh95m35i3z/uHtWqe9ej8MHP21BBC9ovQXCEzDe9fz214w8HseCV5q0h98YGBtuXVfI964tW8apNpLd/fOGju+ndmhVWdW7d1rgyzegq+jcytOrV0dUPmcFeuaSE0HMw2gG/4UnPCEE7VGewYVX++9Jv5UHPf1tBaZkTnkp4RmZHRE7pB3XVf4jeNNx7Z+0efDyGEWff/JOx+71IIIdtzoaNkIen3XmnP+4a5qJtAck0LIeRXieHLdPHYWFLnu1/vDQPtzgq6bAzxrE8fac/b6uLeIkmVecgyR6fgX1Vn8c2fW/KdS4cSRzofc2WuXWVr1KjsqKHrej+vehRVg1DhvEiSOJhU4vRhmrc2M05N2NRU1FLgysrbMs0HXnul+d7cEDNnX0/3d+JO3d08Nan7XpUyo3E1bsg0usl7kypfpMwQNo0bEpY27F1R/W5MbHo21NUlLrbcwss0bQthdM6FgopaaP59/XcvI7/hCSG14NlqRynKW+aezpXtRc2I0nuX7248Naf/9LmxsPnvia1N+VfgEPrrUl/fsh+eeq26pqNDXsUQtyK9d/nuzPhQB1t7F1bZ3rnrcH39yS+9k71EL57dP2BfunNF/Wvvru7ft1+bPnCTNv++ai/pBQNvZUpV0GIo6eYzc/IODLxVckuQuKPG+AJeptKePXVloJPjPanFhW3fyt4SlK205bZi8iDFA2BcurB918eLmm5a0xhCqNvZcn7llqs/6wlrGsu+IL13R++G1fdV9Zv0py7tDzf+sOTN+uypKwVv6qnpXwmn3z2VMG7VoM6euhI29tRvzPu1wLEdBzdJ/2ia6wsnf/6R1JOT0j/9s1nfu7nK5fSsDLN6ksKLeWubRz7wytk97Y2rrgz8nTcA58C9V2rBs5kPDHn5QoH0hbfD1AfyRkqYOXtqaL9wNoTyVSK1dHXDyh3vnX0oNbPr/U3NydtYuIorm27bvTJv2sCno9SCjc+0N64KO98pzjoLZO6HKte0vPEmlj63bGnFQg2qzDEayvnS7+ye9sb2VE/fsiG9KsHdt7wYTj57JAzeyavksGYVn8K54UIqnKtz1/eFUJ89Kxc/c++wB0ErvlD0l/XUW2Fxc97w3rNvXBzSp9Jh6OdI77vtYVP77k15kxaP8gUkvXf5ayvbCyZVt08avrfu/Ultv1qRDRCHsJb85Rec9c2zevKHuG7KffbIhbNZZa9d1deosXf21KXQ3ttYn/+hZfQHfR9d89Yu61ub3rv8tYXbTvR/DJu6853Sb0Ey/ZuymzNz9o2ZC9rMECr2lctIDH3mru+buz7dueK2nq33zF2fdwVOKlL2JY8+c7Lx9RPr5w+acVQTUVWZKw1lvKehSVxU0cSEQo78XDh76lIIN5Z58sTW+p6868/UBwZZ1Cjf8GSuDxs6luXXwE1Nr23oWNaXqSSnLu0P4YdFBW4u+kJowLzHZi2+LX0kHZamQoXr0tBXUbCjNnQsy6/DpVtxdk/nyvaGg30LZoYwc+2yg2H3wh2djz5X+Z7hdGOY1dOXebNOn3orhOwbYu/C28LBvmWZK+TZU1fKLmEo5j02a/HG9Kl0mFfl22NqwQ9bTy8sePMteyzG+AKeXGlnzp66f1VP90P3zct0fmye1d9LdZi3BGW2QiYFMBGlf//LkD/G+acHGzk386twz1W39NxnxcI3oOIUo9zn4SrMnD01tM4Z6heDo+vsqUuhdU7S5+FZ9//k/b853Pu9R6r6pNT9eu/i5saRxhDldB1uXBV2vpO9aevetnvh8JZTEiCWCQ4Kzb9lQ/vJI+kw+/UqAprU9K+EqQ8kfE4LIfT/CE5HWHjb4dllGkGcPXUpNKdmhhBGr6YN05DOl35nT+UNt1FiIEAcXMMfL33vkcOnf3T3rEFmLJcLF5/CJXlQsrnr++auDyGkO1fc9trW2QWfH6pXJu4sycVywdmQG7o1fKk5bFg9zOJVZwRx593Tn/zb9N9/EKoItcuuZeZDzX0PJT0x/76Kn/bLXbuqrlFjb+bsG0Nzqqfy58zhyEUhmTGJRjEWyUjd3TxYjp9+75X2sL/9tfpVA9Ne7Qrz5ocR/Vxd6osPNJ9+5VQ6zC86z5OLNPOhORvqT+59bO4ojIVXHDaNfIHRjN25kN67vGdTrpFyunPFbYMN6T26NzxdhzNRTt4FMHV389QQUrmGvYW3N+m9y3s25UfbyXKNnhKvS8NbRf97SlVbEc6eupK9BwghZPbbW5VKnBmrMQy0Uu99t33qA1tTIRUeaD4dmnO/EpA+9VbYsHo09v+pS/tDqBxBFkqfeiuEgcHaKx+LWlXa3oX1uzMrygSC/YZ3S5C4FfruAUxEqc8sSoXNb17I/JU+dGVzmPSFCvef3c+fDtX+pH2209bK9cUNuWfek1o8MLpqeu/601WNAD37xsUlAzzPvCe1eGPPkEahDtmvnRNHjc2O0TjUBZZz15/9u/Do+6W/aJsg3fnUxv6+cmMg81Vt9k6x63DRMKtDMfdbA7+SU93ooSGEMPfRZ8LK9e1PvVVNL7a532pNqDYhhJDuXNHUu6Hjvnnz7yv4teYCJ15Ylc10RrGmDc/QzpfBnXh1Y+kw6pnhSJPHRv38I6knE3/Brdjcb7WGTU0lA0JnTuHns63uM18+D6GWpqZ/pfDv2V8L1fdCyhy+0l8Wn3dPQ9h4sn97T2xt6k38ZbHipSWc9am7m6cmbPUghrYVIzBrxQuhVr+UVO7aVXWNCsPZUUM69ebfsiGpevQb3hjnRSFU4hDaIzRwgSon0+m4J6/b4MHW0egP29Wzsj3xB0DLFWnut1oHTv+RqdA/rnSG6oaNH1FJhvCCEZ4LM+9J5fqMd2/LH+O899323HcM6b3rT+/Pf9kwbniGNMZ5unNFU29uqITC0vafVunO1lVXcn3tu7e9trI9188reaF71+f/cHCyka2iqq2Yd09D3tX+xAurBv3mrOAdsHtbz6bm1N2pkO05u6oz83aTeQf8Vv66Ssc4r0pCn7vKY5wXdU4cdEeN2QW8XKXNdITPXbLKdJouviUYpNImbYV2UgDj2uV9Wy6uzr7ZffzgunMhTNrRklqSmrak5ePfrfvw1uMfhhD6J5ZdyolXN0594J3qc5PU0ufuDctfy3WvyLbaTS14tuNSfVN/l5ncVy6DLGzBxmfSjf2vyn4tllrw7DthxW27c3eYVTUMnn/fwdbdC7O9wwq6TsycPTWEK5uq6rBQhZs/t+Q7Jw8dCXcN2rz/9fT+1jnPjsIqk818aMHO9teyX2E1zzr4zKWF5XrnDWbe2nt3DhzTxI4nSQW4J7V41enwTKVPYnmrWHZw2+68XjkNB/vum5fuXHHb6f2tjc/Oz8zTuKG+p3F56P+eMPcFXdjQsezZ/t+ZHrWaNhxDPV8G0/X+ptBwsLgwqdlfC6H9yiuvp5cm1PxqG+vNy3Rw6N+H/fsqtfS5xnfrc71Fijt5Jcgcpv6/Fj9z77MFHYUaN9T3ZI/soN+3Z8/uXGuR/so2/76eZ9ob+3t3VtsXIOmsn/lQc09ob8xtdXX1eWhbMQKfv++mZbdceKM13DU2y6+k7LVrCM0/k3ZUQXeehfW7C/Z54qmX380w03QoWznnru8LW+vzGhNVeYKXldgqahRaSxUmEYPX2NKWkvPuaQhN73evnTvEgLu4l01uV1dZpHmPzVpc0N1veKlQNXuvdJ5qdnv1hyZX8qG32BrhuZDpb5658rQ29jxzsjH75jt3fcf79U3ZCryho3FD+8nCV43SDU+C/jRh1cDpM3B7lnfVHXj7y36VNfA+2/92UNxBr2/Q8gx5FUPfisL3iGquDAXvgHlX9ex7RHZRVbwDFpx0pxvrT+delX/SDXRdrCD/zbR5Vk/fQM/rwXfUWF3Ay1Xa1NLVDQP3WiEMXG0q3hIMImErJv3rv/5r/iy/OvnfQgjz/6evBQBGrOsf3wrX60W16x/fyhbs7J72xlM17ig35vqDj+o3c5DdcqRnUtsNvxtkUJgTW+tPfqm6cGe8SneuuC1dtkfeCGWH9KpyPONIhn2+dG/b/dTs0k8aJ7bW94TEgKzrcH1Tb9kPJx/86ru3fPQfrzXWINdgxN7Y2Pk3X5zzUnX9f0dZuWvXBKxRmWyiQrpRYYbEsKNWBt2QES48t+SiMChxvRUCo2p22qB5U7kZqgyqSmcr/8JP0LnARBG10hbfn3Rv273wrdH4wqZ4K/TdA/ikO/FCXhPriers6+n9oZrOaDnpI+1XKg3xc/f0J//2/3224u9nnd1zsr+h+ESV3rv+dHhmwUQO3YoN+3xJ7KAXurf1bBr4xaXCp17vHfiRxFI3f27Jdy79zYuxfg2NUXXXfTfurrL/76grd+2agDVq0N+DqzDDKPwq3+gZ05IU9WocdL0VSlLNTht0QyockcovLDdb+Rd+gs4FJoqYlTZ94e3Cv0+9FQYfabQaxVuhnRTAGBof7aQmukyL62o7o4VcS+yx7Lwz/vW3Yx9pt5qKrst2UkPX3wmidF+lO1esDxtLq1m2VXw1HQoAAMZAwW+5jt0tn0wKYAzJpAAAABLpuwcAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNgm17oAAIzche3rPtwcJr/c1nDnwMTL+7ZcXJ0OIYSQmvJmS111vzkHAAAQg3ZSAONcT++t6z76QtOkwqmX9225uPqWz55pm3GmbcbLt1y94/kLtSkeAABAEpkUwLh2YfuBT73Z1vDNosnpfzuQnrSjaXrmrzubpiw6fmVfOnrpAAAAypBJAYxr09eU7ZT36Vm5J1Kf/mq49juZFAAAcN2QSQFMRKlPfzV8/PShy5m/0oeubK5teQAAAAoZ4xxgQpq+puX3K7dcvLXjYghhUdOUJ8LVWhcJAABggEwKYIJK1e1s63+cPr+yY9IiP7wHAABcN/TdA5j40sc/OpC64ZsyKQAA4LohkwKY4NKH0nd0hB2PlxsKHQAAoAb03QMY1y7v23JxdfYH9T5+cN25ECbtaEktSYVjz5978HgIIYTUlDfbBFIAAMD1RSYFMK5NW9IybUnSE3c+NuPMY7FLAwAAUCV99wAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACC2ybUuAAAjkz6/csvVAyGEEBY13bTz/mm5Z449f+7B45mHk19ua7izFqUDAABIpJ0UwLh2ed+ujxa1zDjTNuNMy5TQcXF7T/aJ9KH0g+9PebNtxpm2GS/f/vGDW86na1pQAACAfDIpgHFt2pKW1JJUCCGEVN0Pbg+b37wQQgjhws86rj2xqC7zzJ1NUxalr/6sp+xSAAAAIpNJAUxEPR9tDpO/2Zj961jH1QMh/PL9yzUtEwAAwADjSQFMFOnzTx8PTzw+Pftn6lNfCCGEC9vXffjLppteDhcf/ODjGpYOAAAgn3ZSABPD5X27rh5ITXm4MW9aT++t6658oWVGZuDzRTf7HgIAALhe+HwCMAFc3rfl4ur05JfbsgNIhRBC+uodB6a82daQCiGEy6ffD+HmmpUPAACgiEwKYNw79nwmkGq4Mzep8YYnwsdhUS6i+vh36UmLbp9Wm/IBAACU0HcPYHxLH0o/eHzSjpa8QCqEEKZ/8/aweVfvsRBCCMee/3Bz6oZvppJeDwAAUAvaSQGMZ+nzrR3XQgirt5xbnZ00aUdLakkq3PnYjJfDuQfXnQshhNSUN1vqRFIAAMD1QyYFMJ6l6na2lX3yzsdmnHksYiIgav4AACAASURBVGEAAACqpu8eAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQ2+RaFwCAMXJh+7oPN/f/8cTjM9Y01rI0AAAA+WRSABPV9DVt09fUuhAAAACJ9N0DAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxDa51gUAYIxc2L7uw839fzzx+Iw1jbUsDQAAQD6ZFMBENX1N2/Q1tS4EAABAIn33AAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMimAcS59fuW6c7euO3frunMrD10ufO7yvi3nbl2X3peuTdEAAADKkUkBjGuX9+36aFHLjDNtM860TAkdF7f39D+TPr9y3f8X7phcy9IBAACUIZMCGNemLWlJLUmFEEJI1f3g9rD5zQshhBAu79v133/QllpySy0LBwAAUI7vzwEmpGlLWqbVugwAAABlaScFMFGkzz99PDxxx/RalwMAAGBwMimAieHyvl1XD6SmPNxY64IAAABUQd89gAng8r4tF1enJ7/cVpeqdVEAAACqoZ0UwLh37PlMINVwZ61LAgAAUCWZFMD4lj6UfvD4pB0tAikAAGA80XcPYDxLn2/tuBZCWL3l3OrspEk7WlJLUuHY8+cePJ6dlHn2icdnrDHaFAAAcH2QSQGMZ6m6nW3Jz9z52Iwzj8UtDAAAQNX03QMAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYJte6AACMTPr8yi1XD4QQQljUdNPO+6f1P3Fh+7oPN2ce3v7ZM49Nr0npAAAAEmknBTCuXd6366NFLTPOtM040zIldFzc3pN94tjzH4bHZ5xpm3Gm7bNPHP9w5aHLNS0nAABAAZkUwLg2bUlLakkqhBBCqu4Ht4fNb17IPHHnYzPWNGYeTn+4adKBN/8tXaMiAgAAlJJJAQAAABCbTApgokiff/p4eOKO0nGjLvys49qiOz6TqkGZAAAAksmkACaGy/t2XT2QmvJwY/ETx57/cHOY/IOBsc8BAABqz+/uAUwAl/dtubg6PfnltrqixlDHnj/34PFJO1oa7qxNwQAAAJJpJwUw7h17PhNIFQdP6UPpB49P2pEbBB0AAOC6IZMCGN/6g6eSllA9vXd0XHvicYEUAABwPdJ3D2A8S59v7bgWQli95dzq7KRMw6gL23d9HELYvOvc5v55n3h8xpqS0aYAAABqQiYFMJ6l6na2JT4xfU3b9DWRCwMAAFA1ffcAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgtsm1LgAAI5M+v3LL1QMhhBAWNd208/5p2cmH0nd0XMvOk5ryZktdqjblAwAASKCdFMC4dnnfro8Wtcw40zbjTMuU0HFxe0/2idT9qTNtM860zTjTdtOOcLX10OWalhMAAKCATApgXJu2pCW1JNMCKlX3g9vD5jcvlM4z65Zw4IOPYxcNAACgPJkUwIR34b8eD0/cMb3WxQAAABhgPCmAiSJ9/unj4YnHB7KnY8+fe/B4CJlxphprVi4AAIBS2kkBTAyX9+26eiA15eG87OnOxzLjSc34wQcXb91yPl27wgEAABSRSQFMAJf3bbm4Oj355TI/rndn05RF6Y/+q1AKAAC4bsikAMa9Y89fXJ2e/HJbw52V5vr0rMS8CgAAoBZkUgDjW/pQ+sHjk3a0VAikLu/bdfXA7TdUTKwAAACiMsY5wHiWPt/acS2EsHrLudXZSZN2tKSWpDK9+bKTFjXddOb+aTUqIgAAQAKZFMB4lqrb2Zb4xLQlLdOWRC4MAABA1fTdAwAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAAgNhkUgAAAADEJpMCAAAAIDaZFAAAAACxyaQAAAAAiE0mBQAAAEBsMikAAAAAYpNJAQAAABCbTAoAAACA2GRSAAAAAMQmkwIAAAAgNpkUAAAAALHJpAAAAACITSYFAAAAQGwyKQAAAABik0kBAAAAEJtMCgAAAIDYZFIAAAAAxCaTAgAAACA2mRQAAAAAscmkAAAAAIhNJgUAAABAbDIpAAAAAGKTSQEAAAAQm0wKAAAA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" alt="请求文章内容"></p><p>能看出来，这里有个单独的js请求，里面就是导出的文章内容。</p><p>而当我只需要文章的标题时，我可以这么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">## ./src/app/page.<span class="hljs-property">tsx</span><br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;!../../md-loader?content=false!../../public/test.md&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function">(<span class="hljs-params">&#123; title &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">setMd2</span>(title);<br>      &#125;<br>    );<br></code></pre></td></tr></table></figure><p><img src="data:image/png;base64,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WZys3tJT6Ln4A7vv81/4y69/fQkp4ZLd+nu/9/HfvekHzz13bGwsbjk2NvaD5577+O/edMutAjsAAADgMrLcZSJOnTr1s5/9r7Vrr2trW8n1Zo+OjN279Z5Gr5bLJx/f+2T8eu2ari2b745f79t/oKurs1Qqn5guhRAGB/r6+9ZlL8WNHR35Bx+4P24cHRs/OnI2HqreuVpxcurgocPx63u33rOyJX4fuv76v/z61+/7/Bfit5PFyc/c+dkv3Hff7Oxse3t7tiXb/2S5/Md/dFf8+nvfP9soOjs7+2//8FPx68/ddVcsi8t6WuPxBwYHs/2rX832r3Ht+6697/NfeOzP//yJffvqjnzbli0xahwYHIzjv+Xmm77yyCOxNnBysviF++7Lzrhty5bP3PnZrGywkdv6+t5448yzzzy9atWqubm5Z595+qMf+9htfX3N37V41Y/Npo3rCz3dIYRt23fELTf2FjbccXvcp7quc+dDD+/88pfy+fbQ4GGoe1gAAACAJVtWYHfq1Kmv7d/3i1/8or09/+/uvvvd7373iowpzh/XKBqLoUmWoezbf2Df/gNZZheTvi2b744xSqGnO59vHxo+ks/nYwozOjYe9xwaPjJdOtdyG4ObmswunivuEw+YnXdFxAzrZLkcm15feOEnPT2FG274cKk03dNTmJ2dfeGFn3R1rcn2//a3/yqmYI989SuPfPUrMSn7L//5b779n74TA75bbr7pQ9df39NT+N73n27UErtty5YsWRs5erTR2AYGBx/56ldGjh7NOnarjzAwOBizvEe++pXYPPu5u+7KmnlfevHF7HPFT7FgWvfWSX8/hPC33/uvIYSPfuxj1e2xy1SpzGa3r1KZLZXLIYRdu/dkEVv2YDRS92EIIcw/LAAAAMBy/H+l2eeMnfxWuwAAAABJRU5ErkJggg==" alt="请求文章标题"></p><p>这样就做到了，对于同一份文件，借助loader来实现不同场景下，拿到的内容不同。</p><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>其实一开始是想，我这个博客到底如何设计架构，想要不要把项目代码和文章放到一块。如果不放到一块的话，好处就是每次发文章，项目完全不用重新部署。但是坏处就是，每次访问，都需要项目向另一个服务器请求文章内容，感觉这样会导致加载速度变慢。不如将文章直接和项目代码放到一起，这样如果是纯静态页面，可以全部依靠服务端渲染或者next13支持很好的服务端组件来实现。</p><p>一开始只是单纯的查如何用react渲染markdown，然后就动手尝试，发现需要编写loader来import markdown。后面又想到了，需要动态加载，通过单独的js文件来请求文章内容。再面又想到了，文章列表页有好多文章，如果每个文章都请求全部内容，又是很庞大的网络请求开销，于是就有了想法，想试试能不能通过loader去实现导出不同的内容，最终有了此文章，收获颇丰</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>loader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单通俗解释HTTP缓存</title>
    <link href="/2023/06/05/%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8AHTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2023/06/05/%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8AHTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>开始前的碎碎念</p><p>最近加班真的很严重，组里同事们都已经苦不堪言。业务交付压力非常大，根本没时间去磨练本领，学习技术。真的很讨厌这种没有成长的日子，每天被业务需求赶着跑。每天下班之后，本来应该用于提升自我的时间也被压榨用来写业务代码。</p><p>希望组里能早日摆脱现状，不然就只能润了</p></blockquote><p>很多人应该都听过http缓存，也是比较常问的面试题吧。还记得我当时什么也不会，刷面经的时候就看到什么http状态码里的304，然后就顺着去搜了一下，搜到了什么协商缓存，看了一下，看的云里雾里。主要还是当时真的欠缺太多基本知识了，搜到的博客里面又都没讲这些基础的点。所以我这次想来通俗的讲一讲，http缓存。注意，本文中所指的服务器，绝大部分都是前端的，返回给你html文件等等的那个服务器，而不是部署着接口的后端服务器。</p><h2 id="为什么需要http缓存"><a href="#为什么需要http缓存" class="headerlink" title="为什么需要http缓存"></a>为什么需要http缓存</h2><h3 id="理解静态资源"><a href="#理解静态资源" class="headerlink" title="理解静态资源"></a>理解静态资源</h3><p>我们都知道，访问一个网站，浏览器会向网站服务器发送很多http请求，去请求html文件，css文件，js文件等等。这些文件都是静态资源。静态资源，其实就是服务器上的文件罢了，不经常变化。你写一个网站的前端代码，写好了部署上去，就不变了。除非你重新部署，上面的文件才变。不像你请求接口，去查数据库里面的数据，那是经常变化的。</p><p>就因为静态资源不常变，所以我们可以把它们缓存起来。这样下次再请求的时候，缓存没过期的话，就可以直接从缓存里面读静态资源，会比从服务器再收一次静态资源快上很多。</p><p>注意：http缓存通常只针对get请求。这也很合理，因为浏览器访问网站，获取静态资源时，发送的请求都是get。至于你访问接口，就由你自己控制了。我的评价是接口都可以用post访问。</p><h2 id="如何判断缓存是否过期"><a href="#如何判断缓存是否过期" class="headerlink" title="如何判断缓存是否过期"></a>如何判断缓存是否过期</h2><p>http缓存有两种：强缓存和协商缓存。流程省流：先强缓存，再协商缓存，再重新向服务器请求。</p><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>通俗来说，浏览器向服务器请求静态资源的时候，服务器会说，你多久之内不要再来问我这个问题。于是这个时间内，每当浏览器需要用这个资源时，都会用第一次服务器给他的那份，这就是强缓存。</p><p>过了这个时间以后，强缓存失效了。浏览器会再去问服务器要这个资源，但是它问的时候会带上两个问题:</p><ol><li>你上次给我的东西，哈希值是这个，你看看变了没</li><li>你上次给我的东西，是某个时间更新的，你看看还是不是最新的</li></ol><p>服务器根据这两个问题来判断，浏览器的缓存还能不能用。如果能，服务器返回给浏览器的http状态码是304，意思就是和上次一样，我就不再给你一份了。如果不能，则服务器会重新发一份静态资源给浏览器。这就是协商缓存</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存就是指，你第一次请求静态资源的时候，服务器返回给你的response header里面如果带下面的两个字段之一：expires或者cache-control，则浏览器会用强缓存规则判断缓存是否过期。expires是直接写死的过期时间，下次再发请求的时候，取当前时间和过期时间比较，来判断是否过期。而cache-control下面的max-age字段则是指定了一个时长。下次请求的时候，会看距离上次过了多久，比较时长来判断是否过期。</p><p>expires来自http1.0，cache-control的max-age来自http1.1 。expires的缺陷是没考虑时区问题。客户端和服务端的所处时区不一致时，expires是服务端所在时区的时间，而客户端会把它当成是自己所在时区的时间。</p><p>看到这里我们可以知道，强缓存的过期时间是服务器那边人为控制的，人为指定了这个缓存能有效多久。如果缓存没过期，我直接问都不问服务器。所以这个时间设定不宜太长，不然即便这些静态资源被更新了，用户也拿不到，因为用户一直在读本地的缓存。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存失效的时候，浏览器还会再挣扎一下，走协商缓存。前提是第一次返回的静态资源的响应头里面有下面两个字段之一：etag或者last-modified。etag可以理解为是这个静态资源的哈希值，内容变化会导致etag的变化。last-modified是这个静态资源上次被修改的时间。</p><p>等到第二次请求这个静态资源时，浏览器会向服务器发一个请求，这次请求头里面的if-none-match的值为上一次的response的etag，if-modified-since值为上一次response的last-modified。服务器收到这个请求，会再去看一下服务器上的静态资源，它的etag和last-modified，然后自己根据浏览器传过来的etag和last-modified，判断一下浏览器那边的缓存是否还能用。如果还能用，也就是没过期，就返回一个http code304。如果不能用，就返回最新的静态资源过去（当然http code是200）。</p><p>至于服务器如何根据etag和last-modified判断，这个是看服务器具体怎么实现的，各大框架应该都已经有现成的实现了。反正单独看两个字段的话，肯定是比较etag是否一致，和last-modified值是否相同了。但是二者的优先级，是依靠具体实现的。etag的准确度肯定更高。如果在last-modified的最小时间精度内，文件被修改了多次，last-modified是区分不出来的。而且无谓的修改也会导致last-modified的改变，即使修改并没有改动到文件的内容。所以通常建议以etag为准。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>http</tag>
      
      <tag>http缓存</tag>
      
      <tag>小白都能懂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从invalid hook call报错说到npm install相关</title>
    <link href="/2023/04/09/%E4%BB%8Einvalid-hook-call%E6%8A%A5%E9%94%99%E8%AF%B4%E5%88%B0npm-install%E7%9B%B8%E5%85%B3/"/>
    <url>/2023/04/09/%E4%BB%8Einvalid-hook-call%E6%8A%A5%E9%94%99%E8%AF%B4%E5%88%B0npm-install%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="遇到了invalid-hook-call报错"><a href="#遇到了invalid-hook-call报错" class="headerlink" title="遇到了invalid hook call报错"></a>遇到了invalid hook call报错</h2><p>上周，业务下游的同事反馈了一个生产问题，说我们传的值有问题，领导让我帮忙排查一下。我最近一直没做那个项目相关的需求，打开那个项目切到release分支，拉代码，npm i然后启动，结果就白屏了。。。</p><p>打开控制台，看到了invalid hook call的报错，发生在公共组提供的一个组件里面。这个报错其实还有点讲究，我们都知道react的hook因为实现方式的限制，必须保证每次render都按相同的顺序执行，所以hook的使用是有限制的。当违反这些限制的时候就会报invalid hook call的错。但是除了刚接触react的新手，几乎没人会犯这样的错误。</p><p>这个报错的另外两个可能的原因，分别是react和react-dom的版本不匹配，和项目里存在多个版本的react。我在node_modules里面查看了报错的那个组件下面的node_modules，发现果然这个组件又单独装了个react的包进去。这样一来，我们项目里面就存在了两个react版本，导致了invalid hook call报错。</p><p>项目的实际依赖结构如下：</p><p>project<br>— node_modules<br>—— react 16.14.0<br>—— 某组件<br>——— node_modules<br>———— react 17.2.0</p><h2 id="为什么会装两个react"><a href="#为什么会装两个react" class="headerlink" title="为什么会装两个react"></a>为什么会装两个react</h2><p>我最近一直没碰过那个项目，那其他人呢，其他人开发没遇见这个问题？我真忍不了了，开始翻那个组件的依赖，看到它peerDependencies里面有个react，但是这个应该不是问题，peerDependencies不会真的被安装。我又翻这个组件的深层的依赖，终于看到有个包直接把react写在了dependencies里面。然后我先暂时用force-resolution统一了项目里面的react版本，然后跟公共组的同事说了之后，他们就把dependencies里面的react和react-dom去掉了。</p><p>其实我们直接用npm ls react命令也能看出来，项目里面就精装了多少个react和每个react的版本。</p><h2 id="npm的各种依赖"><a href="#npm的各种依赖" class="headerlink" title="npm的各种依赖"></a>npm的各种依赖</h2><h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h4><p>接下来就发散发散，说说npm的各种依赖吧。还记得半年前我刚工作的时候，还不懂devDependencies和dependencies的意义，改了组件的devDependencies，结果最后项目里没生效，还是向别人请教后才知道，组件的devDependencies最后不会被真的安装到项目里面去。</p><p>字面意思，devDependencies是指开发环境用到的依赖，比如用于预览组件的storybook，实际项目是用不到的，它是用来开发组件的时候预览用的，所以storybook就是典型的要写在devDependencies里面的。总结就是你有一个组件A，它依赖了一个npm包B，如果B写在dependencies里面，那么当项目安装A的时候也会安装B。而如果B是写在A的devDependencies里面，那么项目安装A就不会自动安装B。有的时候如果你错把一些依赖写在devDependencies里面，可能会导致项目里面少安装了一些依赖。这种时候建议使用peerDependencies</p><h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><p>peerDependencies意思就是我必须需要这个依赖，但是我不会自带这个东西，需要安装我的项目去安装这个依赖。比如有的组件只能运行在react项目中，则可以把react写在peerDependencies里面。然后安装这个组件的项目需要自己指明react为dependencies。如果实际项目中缺少这个依赖，则会提示报错。</p><p>我们应该明白各种依赖的意义，在实际开发过程中加以区分，将依赖的npm包写在最合适的位置。</p><h4 id="对devDependencies的补充"><a href="#对devDependencies的补充" class="headerlink" title="对devDependencies的补充"></a>对devDependencies的补充</h4><p>（后续追加更新，修正上面的内容。以上针对devDependencies的内容，对于发布npm包来说是正确的。而在web站点项目中，dependencies和devDependencies仅作为一个规范，并没有实际区别。这也解释了为什么公司有的项目把依赖的业务组件写在devDependencies，却能正常运行。虽不规范，却不报错。待我去公司再确认一下，项目在生产的install命令是什么）</p><p>二次追加更新，今天和同事聊天的时候，又意识到一个问题（虽然这个同事平时有种摸鱼的感觉，但是每次和他交流都感觉收获满满），即被打包和被安装是两码事。所谓的devDependencies不会被安装确实是没错，但是组件里面的devDependencies也是会被打包的。因为打包器不会去管这个依赖是dependencies还是devDependencies甚至在不在package.json里，只要node_modules里面能找到这个包，并且从打包入口开始根据import或require构建依赖关系时，确实遇到了这个包，这个包就会被打到最后的代码里面，除非用external字段指明不打这个包。用同事的话说，就是被塞到最后那个面目全非的打包后的js里面去了。</p><p>确实我之前也发现过这个问题，我写过一个简单的npm包，把react写在devDependencies里面，但是打包出来的产物快三千行，只有不到一百行是我的代码，剩下全是react我真的很难绷，后来我也是用external字段指明不打包react，最终才得到了简洁干净的打包产物。当时我还有点纳闷，明明是写在devDependencies里面，也没写在devDependencies里，怎么还被打包呢，今天才明白，写在devDependencies里面只会让我在安装我自己的npm包的时候不会再安装一个react进去，但是不能避免我的npm包里面含有react的代码。</p><p>其实这又进一步解释了为什么web站点项目中dependencies和devDependencies意义不大，我今天特地看了我们pipeline的命令，安装这一步没有指定是生产环境，所以devDependencies依赖也被装到node_modules里面去了，所以最后build的时候当然也会把devDependencies打进去。</p><h2 id="npm机制"><a href="#npm机制" class="headerlink" title="npm机制"></a>npm机制</h2><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><p>接下来再说说npm的机制。我们经常发现，有的时候项目里面明明package.json里面写的各种依赖很少，但是项目node_modules里面却有着巨多的文件夹。这其实是因为npm的扁平化机制。npm在安装包的过程中，会试图将依赖的依赖，以及更深层次的依赖，都提取到最外层来。提取到最外层，更有利于减少包的重复安装。</p><p>例如一个项目，依赖了A和B，而A和B又都依赖了C。npm在早期没有做扁平化处理的时候，会普通的嵌套安装，A里面装一个C，B里面装一个C，造成了重复安装。而扁平化之后，C会被提取出来，安装在最外层，也就是和A，B同级（前提是A和B依赖的C的版本是兼容的，比如相同版本，或者指定的版本范围存在交集）。如果A依赖<a href="mailto:&#67;&#64;&#49;&#x2e;&#48;&#46;&#48;">&#67;&#64;&#49;&#x2e;&#48;&#46;&#48;</a>，B依赖<a href="mailto:&#67;&#64;&#x31;&#46;&#x30;&#46;&#49;">&#67;&#64;&#x31;&#46;&#x30;&#46;&#49;</a>，那么不一定哪个版本的C会被提取出来安装到最外层，然后另一个版本的C被安装到自己的父级下面，这取决于A和B的安装顺序了。这样的扁平化管理，一定程度上减少了包的重复安装，但是具有一定的不确定性，被提升上去的版本可能会在某次更改后发生变化。</p><p>第三次追更：我是不是中了邪啊，前一天在文章里写的知识点，第二天就发作了。还是同一个倒霉项目，技术中心那边有一个包，把react-router-dom从dependencies里面去掉了，我们的组件库依赖了这个包，并且没锁版本，导致昨天好好的，今天发布的集成分支跑流水线的时候install出来的结果和之前不一样。react-router-dom里面自带了react-router包，原本装在node_modules最外层的是5.x版本，结果技术中心那个包把react-router-dom去掉了之后，安装的顺序发生了改变，最外层的变成4.x版本了，5.x版本被装到里层了，真的服气，老项目不上传packagelock真的是很坑。别人升级一个包，我们这边三个人找白屏原因找两小时。</p><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h4><p>第三次追更内容：既然说到了package-lock.json，就展开来说说。</p><p>作用大家都知道了，锁版本用的。你可能以为，你package.json里面不用模糊版本号，你的依赖就不会变，大错特错，你不能保证你的依赖在依赖别人时有没有锁版本号，你也改变不了。这就容易导致很多问题，我前面已经讲过惨痛的教训了。包括很多人，可能遇到git冲突，或者其他问题时，喜欢把package-lock.json删了，然后重新install，这是非常危险的，因为很多深层级的依赖可能都被你不知不觉的升级了。</p><p>package-lock.json里面一些有用的字段：</p><ul><li>version不用说，实际安装的版本号</li><li>requires里面是这个子依赖的package.json里面的dependencies的东西</li><li>dependencies字段是这个子依赖的package.json里面的dependencies实际被安装到子依赖的node_modules的东西（即没被扁平化提取到最外层的包，因为版本冲突）</li><li>integrity：校验用哈希值</li><li>resolved：安装的源。同时也通过这个源的地址去校验缓存是否可用，如果源地址一致，则从缓存中拿依赖压缩包。不一致则去新的源地址下载依赖压缩包。<strong>所以我们也能知道，必须有package-lock.json，npm才有可能使用缓存</strong></li></ul><h3 id="幽灵依赖"><a href="#幽灵依赖" class="headerlink" title="幽灵依赖"></a>幽灵依赖</h3><p>这种扁平化导致了一个问题就是幽灵依赖。即，我明明没有安装过某个包，但是我却可以使用它。还拿上面的例子，项目依赖了A和B，并没有直接依赖C，也就是说项目指明的依赖里面是没有C的，但是因为扁平化机制，C被提升到node_modules的最外层，项目里直接从C里面import东西，也是能做到的，这个就很恐怖了。</p><p>幽灵依赖会导致一些问题，首先最直接的一点就是，如果引入了幽灵依赖的原始依赖被移出，幽灵依赖也不存在了，但是去除原始依赖的人可能没察觉到这一点，直接导致项目挂掉。再次，更神不知鬼不觉的情况就是，你升级了原始依赖的版本，新版本的原始依赖不包含幽灵依赖了，项目还是直接挂掉。</p><p>还有一些问题就是，幽灵依赖的具体版本不可控，项目会在没有察觉的情况下使用新版本的幽灵依赖，而新版本和老版本可能不兼容，比如去掉了某个API之类的，还是会导致项目报错。</p><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><p>针对npm的扁平化提升遗留的缺点，和幽灵依赖的问题，新的包管理器pnpm出现了。pnpm通过硬链接，将node_modules下面的包都指向了全局的一个pnpm store当中。多个项目用到相同的包，其实最后硬盘里只会安装一份，这样也节省了硬盘的空间。总的来说，pnpm其实是具有很多优点的。我们的项目也尝试过使用pnpm，但是因为自身项目不规范等等的原因（比如项目本身存在使用幽灵依赖的情况），失败了，最后又转回了npm。</p><p>如果有机会从头开始规范做的话，还是挺建议使用pnpm的</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useState为什么获取不到更新后的值，如何解决</title>
    <link href="/2023/03/09/useState%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC/"/>
    <url>/2023/03/09/useState%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="令人困扰的问题"><a href="#令人困扰的问题" class="headerlink" title="令人困扰的问题"></a>令人困扰的问题</h2><h3 id="是因为异步吗"><a href="#是因为异步吗" class="headerlink" title="是因为异步吗"></a>是因为异步吗</h3><p>大家都知道，react的useState和useReducer，在set和dispatch之后，马上去获取值，是拿不到最新的值的。这个原因之一是useState和useReducer是异步更新的，也就是说我们刚调用完set和dispatch马上去取值，这种同步代码执行的时候，状态还没更新呢，所以拿不到。</p><h3 id="同步如何"><a href="#同步如何" class="headerlink" title="同步如何"></a>同步如何</h3><p>那我们如果换成redux呢？redux不使用中间件扩展的话，全部都是同步的操作，也就是说你上面一行dispatch之后，马上状态的更新就完成了。但是其实我们马上去获取，也是拿不到最新的状态的。其根本原因是React的机制。</p><h2 id="React的理念和机制"><a href="#React的理念和机制" class="headerlink" title="React的理念和机制"></a>React的理念和机制</h2><p>React的快照理念，导致了上述的问题。我们就拿React的函数组件来举例子，我们知道函数组件所谓的渲染就是执行一遍自己，所以组件重新渲染就会重新执行这个函数。那我们定义过的变量也就会被重新定义，也就是说，当你写<code>const [value,setValue] = useState(0)</code>的时候，每次函数重新渲染，value都被重新定义了一遍，并且被重新赋了值。这就是value虽然是const，但是仿佛能被改变值的原因。</p><p>React的理念如此，页面是某个状态的快照，状态和页面是一一对应的。状态变了，就要重新渲染。而组件每次重新渲染，都对应着一个新的状态，新的状态和旧的状态是完全隔离的，打个比方就像平行宇宙一样。每次重新渲染，就分出来一个平行宇宙。两个平行宇宙的你，可能相似，但不是一个人。</p><p>也就是说，更新后的状态，只存在于新的平行宇宙里。你setValue之后，再去获取value，获取的还是老的value。新的value值已经在下一次执行了，需要下一次渲染才能拿到了，所以这样是必定拿不到更新后的值的。</p><h2 id="如何能拿到更新后的值"><a href="#如何能拿到更新后的值" class="headerlink" title="如何能拿到更新后的值"></a>如何能拿到更新后的值</h2><p>一种方法是使用useEffect。当每次函数重新渲染后，都会执行useEffect，这个时候你是正处在新一次函数执行中的，所以是能拿到新定义的value值的。但是这样有个问题，就是如果useState的变量是个引用值，然后你要监听的是引用值里面的某个属性，当这个属性变化的时候去更改另一个属性，这样就会导致函数无限重新渲染。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">const [obj,setObj] = useState&#123;a:0,b:1&#125;<br></code></pre></td></tr></table></figure><p>我想做的是，每当obj.b变化的时候，我要去更新obj.a的值。我们首先不能直接obj.a&#x3D;xxx这样去做，肯定要<code>setObj(newObj)</code>这样去更改a的值，这就会导致我们监听的是obj，但是又会改obj的值，这时候这种方法就行不通了。</p><p>另一种方法借助useRef。useRef很特殊，返回一个带current属性的对象。每次重新渲染，函数组件都重新执行，但是useRef不会被重新定义，一直是最初的那个变量。因此useRef相当于是可以跨越不同平行宇宙的存在。我们可以将新的变量值赋给useRef，然后就能拿到新的值了。</p><p>我们可以封装一个自己的hook：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs react">const useGetState = (initialState) =&gt; &#123;<br>  const [state, setState] = useState(initialState);<br>  const ref = useRef(initialState);<br>  const syncSetState = useCallback((newValue) =&gt; &#123;<br>    ref.current = newValue;<br>    setState(newValue);<br>  &#125;, []);<br>  const getState = useCallback(() =&gt; ref.current);<br>  return [state, syncSetState, getState];<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以通过第三个返回值，来即刻拿到更新后的值。就先说这么多吧，困了，我恨加班</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Hooks</tag>
      
      <tag>useState</tag>
      
      <tag>useRef</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发布一个npm包的踩坑</title>
    <link href="/2023/03/06/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E7%9A%84%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/03/06/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85%E7%9A%84%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>试着自己发布了一个npm包，记录一下自己踩的坑</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>首先npm init，然后添加type:module字段，将其定义为一个es6模块。然后在files字段设置要发布上去的内容，比如dist文件夹。</p><p>接下来将开发用到的依赖添加到devDependencies里面去，比如react，和打包工具等等。这样当我们的包被引入时，就只会引进来我们的包，而不会把我们的依赖也一起安装下来。</p><h2 id="rollup设置"><a href="#rollup设置" class="headerlink" title="rollup设置"></a>rollup设置</h2><p>我们使用rollup来打包。常用的打包工具中rollup比较简洁，适合库的打包。我们在项目根目录添加rollup.config.js来配置打包参数。output中我们根据format的不同，分别打包到dist下的cjs和esm目录，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span> <br>      file<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/cjs/index.js&quot;</span><span class="hljs-punctuation">,</span> <br>      format<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cjs&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      file<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/esm/index.js&quot;</span><span class="hljs-punctuation">,</span><br>      format<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esm&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>然后为了支持ts，我们添加插件rollup-plugin-typescript2。</p><p>之后我们将rollup打包命令添加到package.json的build命令下。</p><p>然后因为我们的组件里依赖了react，为了避免将react也打进来，我们需要再添加externals字段，将react添加到其中。</p><p>之后我们执行npm publish就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>npm包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于SPA与SSR的简单介绍</title>
    <link href="/2023/02/28/%E5%85%B3%E4%BA%8ESPA%E4%B8%8ESSR%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/02/28/%E5%85%B3%E4%BA%8ESPA%E4%B8%8ESSR%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>本文将简要介绍几个概念，如SPA, CSR, SSR, 前端路由。适合小白，我将用浅显又生动的话语来介绍这些概念。</p><h2 id="什么是SPA"><a href="#什么是SPA" class="headerlink" title="什么是SPA"></a>什么是SPA</h2><p>SPA（single page application）单页应用，占了现如今web应用的绝大多数。其意思就如字面所言，但是或许小白们不能真正理解何为单页，且让我讲给你听。我们先说，CSR（客户端渲染）和SSR（服务端渲染）都是SPA，我们先讲CSR的情况</p><p>从一个很经典的问题讲起，“当你在浏览器地址栏里输入了一个url，并且敲了回车之后发生了什么”。你只需要知道前端的代码需要部署在服务器上面（注意与作为ajax请求目标的后端接口服务器不同，本文的服务器均指代部署着前端代码的服务器），浏览器会向服务器发送一个请求，而服务器会返回给你html，css和js这些静态资源。多说一嘴为什么叫静态资源，就是因为它是不变的（每个人拿到的都是相同的），它就是你写的前端代码打包出来的产物。试想如果你完的代码会自己变化就太恐怖了。而所谓的动态通常指依赖接口返回的数据（通常不同的用户拿到的也不同）。</p><p>而对于SPA来说，相信无论是用vue或者react的各位都还记得，项目的入口html文件里面有个div，id可能是root或者app，它就是页面的根节点。而vue或者react框架，就是写一堆js去生成dom元素，然后把生成的dom元素塞到根节点里面（挂载到根节点下）。如果你打开一个CSR（客户端渲染）的SPA应用，去查看控制台，network里面的Doc下面，有个很简洁的html文件，这个就是服务器传给浏览器的html文档。这个文档，也就是单页应用中的那个单页。</p><p>而单页，单就单在，这个网站的各个界面，点击跳转之后的界面，都是渲染在最初的这一份html文档上面的。打个比方，把网站当成一幅画，最初的那份html就是画布。你先在上面画了一个myWebSite.com&#x2F;home，然后你要跳转到myWebSite.com&#x2F;about，不是再拿一幅画布，而是把原来的画布擦干净，画一幅新的上去。这也就是前端路由的概念。在SPA中，当你去做一些跳转的操作时，不会再向服务器发送请求新的html文档，而是通过js的操作，去更新html上的内容。</p><p>关于前端路由的具体实现，本文不具体讲解，我们只需要知道前端路由是在不重新向服务器请求页面的前提下。改变了url。然后通过一些api，根据url的变化，去渲染不同的组件，从而使得我们能看到不同的页面。当然需要注意，虽然url被改变了，但是浏览器没有向服务器发送请求。如果你这时候刷新页面，则浏览器会试图向服务器发送请求，某些情况下会拿到404响应码，比如vue的history模式路由。</p><p>我们回顾SPA的渲染过程，它只在你第一次输入URL并且敲回车的时候请求一次服务器，拿到所有的html，css，js之后，浏览器开始完全接管页面的渲染和交互。通过执行js，将你写的组件挂载到根节点当中。当你试图在应用内（也就是你写的项目里）跳转时，你写的js会在原有html上渲染出新的组件，而你的交互也都是通过浏览器去执行js来实现。这就是CSR（客户端渲染），页面的渲染都是在浏览器上完成的。</p><h1 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR"></a>什么是SSR</h1><p>大部分小白们可能刚接触vue和react的时候写的都是CSR，也就是上面提到的内容。CSR有一些缺点，比如FCP（First Contentful Paint）首次内容绘制时间长，说白了就是首屏的白屏时间长（相对较长）。因为一开始浏览器拿到的只有一份空的html，所以用户看到的是白屏。你写的组件要等到浏览器去执行js去渲染到html上。假设浏览器执行js要10秒钟，那用户就会看到10秒的白屏，认为你这个网站好卡啊。</p><p>当然这是CSR的缺点之一，其次还有不利于SEO，说白了就是不容易被搜索引擎给抓取到，因为搜索引擎也会认为你这个网站是个空的html（搜索引擎也有做优化，稍有改善）。</p><p>为了解决这些问题，人们采用了SSR（服务端渲染）的解决方案。其实最早前后端没分离的时候，就是由后端服务器将动态的数据塞到html模板里面，返回给前端的。当你输入url按下回车之后，浏览器拿到的就是一份完整的有内容的html，而不是空的html。当然这是古早时期的行为了，不在本文讨论范围内。</p><p>为了解决CSR由浏览器绘制页面导致的白屏时间长的问题，SSR直接由服务端将你的组件渲染好塞到html文档里面，一起返回给你。说白了，和客户端渲染的区别就是，第一次拿到的是带内容的html文档，css和js。浏览器拿到带内容的html文档，就可以直接展示给用户看了。然后浏览器再执行js，将点击事件之类的添加到页面上，不然你的页面就只能看，没有任何交互了。</p><p>举个服务端渲染的例子，我想访问myWebSite.com&#x2F;home,，服务器会渲染好一个home的html（html当然只能看不能点），连带着css，js返回给浏览器，之后浏览器在执行js。我们以最流行的React框架Next为例讲解，对于静态的页面，那可能如果myWebSite.com&#x2F;home依赖动态数据，那么你可以在getServerSideProps方法里面去获取，然后将数据作为方法的返回值，这样一来你的页面就能从props拿到动态的数据。比如&#x2F;home页面可能需要从接口拿用户信息，你可以选择普通的将调用接口写在组件的生命周期里（由浏览器执行js的时候调用），也可以将调接口写在getServerSideProps里（由服务端调用），再讲接口的数据传给页面组件。</p><p>那么服务端渲染的前端路由切换是怎么样的呢，还是以next为例，我们这里只讲解getServerSideProps的情况，这种最复杂有趣，其他情况请参见next文档。当你在next中使用前端路由跳转到一个通过getServerSideProps来进行服务端渲染的页面时，你要记得你依然是一个单页应用，next会支持你在原有的html文档上面切换要渲染的组件。但是你的页面是依赖getServerSideProps来给你提供数据的，而getServerSideProps不能在浏览器调用。这下困难了，不能像CSR那样不借助服务器就完成页面的切换了。这个时候next框架会替你向服务器发送一份请求，求助服务器帮忙执行一下新页面的getServerSideProps方法，并且将结果以json格式返回给浏览器。这个请求的url是形如<code>myWebSite.com/&#123;配置的basepath&#125;/_next/data/&#123;generateBuildId&#125;/&#123;query&#125;/&#123;页面的名字&#125;.json</code>。如果这个请求挂掉了（不常见的原因，比如我司配的软路由不恰当，将这个请求导向了错误的地址），那么next的补救措施是，让浏览器重新向服务器发送请求，有服务器渲染一个新的要跳转到的页面，再返回给浏览器，相当于重新执行了一遍最初的工作。</p><p>SSR也有缺点，比如每当浏览器重新向服务器请求的时候，都会请求很多的数据，包括当前页面的带内容的html，所有页面的css，所有页面的js（不考虑代码分割，懒加载的情况）。每当SSR的前端路由请求挂掉时，SSR都要重新请求大量的数据。而相对的，CSR只有首次渲染依赖前端服务器，而且这一次请求的内容是不带内容的html，所有页面的css，所有页面的js。这样看来哪怕是单次比较，CSR请求的东西也是比SSR少的，也就是说CSR虽然首次绘制出内容要晚于CSR，但是因为网络传输的内容少，所以会更早拿到请求的内容，从而更早执行完js，使得用户可以交互。而SSR虽然一开始拿到了有内容的html，让用户更早看到页面，但是要传输的内容多，从而晚执行完js，使得用户更晚才能交互。这个指标叫TTI（Time To Interactive），首次可交互时间。</p><p>所以SSR和CSR其实各有优缺点，使用的时候需要综合考量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SPA</tag>
      
      <tag>SSR</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端知识随手记录</title>
    <link href="/2023/02/17/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/17/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近几个月被业务需求搞的要死，已经到了周末两天都要去加班的地步了。也没机会像之前那样，晚上下班之后到家学习一两个小时了。最近被逼急了，想着这样加班岂不是永远没有学习的时间，没有学习怎么能提升自己，于是晚上决定十一点到家也要翻翻书，哪怕就十几分钟，也比啥也不干强。碰到什么零碎知识点就记下来，有空回顾回顾</p></blockquote><ol><li>浏览器解析拿到的html文档时，是按顺序解析html节点的。按顺序将html构建成dom，但是一旦遇到script节点（如果没有defer和async），就会暂停构建dom，转而去执行其中的js代码。js代码可以操作已经存在dom。<br>为了避免js操作的dom还未存在的情况，所以script标签通常放在html的结尾。</li><li>script标签 async和defer属性的作用（今天听同事聊做面试官的时候问的问题，正好也回顾一下）。这两个属性使得script标签不会阻塞后续html文档生成dom树的过程。两个属性按字面意思，async指异步，js的加载和执行都是并行的。defer指推迟，js并行加载，但是等到dom被完全加载的时候才开始执行。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>零碎知识点</tag>
      
      <tag>想到啥记啥</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css踩坑之子元素margin-top影响父元素</title>
    <link href="/2022/08/22/css%E8%B8%A9%E5%9D%91%E4%B9%8B%E5%AD%90%E5%85%83%E7%B4%A0margin-top%E5%BD%B1%E5%93%8D%E7%88%B6%E5%85%83%E7%B4%A0/"/>
    <url>/2022/08/22/css%E8%B8%A9%E5%9D%91%E4%B9%8B%E5%AD%90%E5%85%83%E7%B4%A0margin-top%E5%BD%B1%E5%93%8D%E7%88%B6%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为css的知识比较琐碎，所以特地记录一下工作中踩过的坑</p></blockquote><h2 id="一个简单的答案和解决办法"><a href="#一个简单的答案和解决办法" class="headerlink" title="一个简单的答案和解决办法"></a>一个简单的答案和解决办法</h2><p>前两天在工作中踩了个坑，给一个子元素设置了100px的margin-top，然后父元素没有设置border-top和padding-top，原本期待的是父元素能够顶到最上面，然后子元素在父元素内部，和父元素的顶部保持一个100px的距离。但是结果是，子元素的顶和父元素的顶贴在了一起，然后父元素没有顶到最上面，反而被挤下来了100px的距离。</p><p>上网了解了一下之后，知道了解决方案是给父元素设置padding-top或者border-top，这样就能达到预期了。</p><p>然后我又深入了解了一下，原来是涉及到外边距合并的知识。当两个垂直方向的外边距相遇时会发生合并，二者不会相加，而是合并成二者的较大值（可以理解为两个外边距重叠了）。这个其实我之前就知道，不过之前我知道的情境是兄弟元素之间的外边距合并，上面的margin-bottom和下面的margin-top会合并。但是我才知道，原来父子元素的margin-top也会合并。</p><p>而给父元素加伤padding-top和border-top就不会合并，是因为两个垂直外边距中间被border或者padding隔开，因此不会合并。</p><h2 id="更进一步探究"><a href="#更进一步探究" class="headerlink" title="更进一步探究"></a>更进一步探究</h2><p>而好奇的我不会在此停下，既然说的是合并成二者中的较大值，那如果有一方是负外边距怎么办？负外边距是不是相当于永远不起作用了？</p><p>然后我又找啊找，同时自己也试啊试，最终发现了一篇讲的很好的文章<a href="https://zhuanlan.zhihu.com/p/30110209">图解 外边距合并、负外边距</a>，也能解释我实验的结果</p><p>结论就是：当要合并的外边距都为正时，取二者最大值。当一正一负时，正的和负的相抵消，最后为正就是正多少，为负就是负多少。当两个负外边距时，会取绝对值较大的负外边距，作为二者重合多少的标准。</p><p>当然，这种情况几乎没有什么用，我觉得也很少会有同时用到负外边距和外边距合并的情况，这么布局多少沾点魔鬼了，平时应该合理使用padding和margin，尽量让布局更加简明易懂</p>]]></content>
    
    
    <categories>
      
      <category>css踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>外边距合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊react与函数式编程</title>
    <link href="/2022/08/20/%E8%81%8A%E8%81%8Areact%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/08/20/%E8%81%8A%E8%81%8Areact%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>react不是魔法</p></blockquote><p>今天我想来聊一聊函数式编程，和它在react中的体现。</p><h2 id="何为函数式编程"><a href="#何为函数式编程" class="headerlink" title="何为函数式编程"></a>何为函数式编程</h2><p>我们可以把函数式编程理解成一种范式，一个规范。纯函数是函数式编程的关键概念，函数式编程希望我们尽可能多地使用纯函数。正是依赖于纯函数的特点，函数式编程使得我们对于程序的结果具有更高的掌控性。</p><p>至于函数式编程中的什么，函数是第一等公民啊，函数柯里化，高阶函数，闭包，什么之类的，别的文章里面讲烂的东西我也不赘述了，我只想讲讲纯函数。</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>我今天不说编程意义上普遍的“函数”（也被叫做方法），我想谈谈数学上的函数和编程上的纯函数。</p><p>数学意义上的函数，近代定义就是定义域到值域的对应关系。通俗地说，我们把函数理解成一个机器（对应关系），给它一个输入，它给你返回一个输出。如果你给它相同的输入，它能确保给你相同的输出，那么它就是一个函数。</p><p>纯函数是指，你编写的函数，也能做到和数学意义的函数相同的事情，并且不能有副作用。即以下两点</p><ul><li>首先，在决定输出的时候，所依赖的东西必须是输入的子集。不能有会变的因素影响到函数的输出。比如我要输出一个数字，我不能根据当时的时间和天气来得到结果，也不能因为某个定义在函数外部的变量得到结果。这些都会导致输入不变时，输出发生变化。</li><li>其次，函数不能有副作用。什么算副作用呢？所有影响了函数外部的东西的操作，都是副作用（side effect，不是负作用）。比如你修改了外部的一个变量，发送了一个请求，打印了一个数据，这些都是副作用。为啥叫做副作用呢，因为这些操作都是与函数不相关的，它们使得函数的影响不局限于函数本身之内了。这违背了函数式编程的初衷。副作用使得函数的影响范围不可控。<br>值得注意的是，改变了函数的实参，也是副作用。因为实参是定义在函数外部的变量。一个很好的例子是sort(Array.prototype.sort)，它就不是一个纯函数。当你调用a.sort()之后，a变成了排序后的数组。a当然也是sort的参数，因为对于sort来说，a就是this。而sort改变了this。所以说sort不是一个纯函数。<br>这其实是一个很不好的事，通常在这种情况下，我们应该新建一个对象，将新建的对象返回，而不是在原来的对象上面做更改。当然代价是更多的内存，不过这换来了更高的可调试性。我们试想一下，你写了一个会改变实参的方法，别人把自己定义的变量作为参数传给你，结果变量却被改变了，别人会被你气死，因为他万万想不到，变量的值不符合预期，竟然是因为变量作为参数传给了你。</li></ul><p>换句话说，纯函数的要求是相同输入对应相同的输出，并且不能对函数之外的部分造成影响。纯函数有以下优点：</p><ol><li>可缓存性：因为相同的输入有相同的输出，所以可以把某个输入对应的输出缓存起来，下次拿到相同的输入时，直接返回缓存的结果，不必重新计算。</li><li>可测试性（重要）或者说，可预期的：纯函数测试起来很简单，你能完全掌握这个函数做的事，只需要通过观察它的输出是否正确。而如果有副作用的非纯函数话，函数对外界做出了影响，这些影响无法通过函数的输出检测到，容易被忽略，但是又可能会导致bug。这就是为什么纯函数比非纯函数好。</li><li>可并行性：因为纯函数不会对函数外界造成影响，因此多个纯函数就互不影响，可以并行运行，各玩各的。不过js是单线程语言，这点并不能体会到。</li><li>引用透明：即调用这个函数的语句，可以被函数计算的结果替代。</li></ol><p>由于这些优点，纯函数可以大大降低代码的耦合关系，使得结果完全可以预计，你写的变量也不会被别人的代码改变值。这样会使得开发与调试的难度大幅降低。因此，我们在开发的过程中，都应该注意尽量使用纯函数。</p><h2 id="React中的函数式编程"><a href="#React中的函数式编程" class="headerlink" title="React中的函数式编程"></a>React中的函数式编程</h2><h3 id="react不是魔法"><a href="#react不是魔法" class="headerlink" title="react不是魔法"></a>react不是魔法</h3><p>首先解释下“react不是魔法”这句话。是的，react不是魔法，它只是JavaScript代码。</p><p>你大可以把他当做一个黑盒子，你学着别人的样子，写着按照jsx语法写着代码，然后你的代码就出现在了屏幕上，就像我之前写vue时一样。我当初用着vue-cli的时候，根本不知道自己写的代码是如何变成dom的，只知道写template，script和style三部分。我不是在黑vue，只是说react的写法看起来更加原始，更能够让人们明白，自己写的每一行代码是如何变成dom的。当然vue也有很多不用脚手架的方法，写起来也不那么“黑盒”，只是当初我完全看不懂，也就无从深入了解罢了。</p><p>而实际上，react就是需要你去写一个jsx，然后将这个jsx转成React.createElement。通过这个API去构造虚拟节点。而这个jsx，其实就是类组件中render()的返回值，或者函数组件的返回值。</p><h3 id="react的组件其实就是函数调用"><a href="#react的组件其实就是函数调用" class="headerlink" title="react的组件其实就是函数调用"></a>react的组件其实就是函数调用</h3><p>我们这里取最简洁的函数组件为例，暂时不考虑使用hooks的情况，函数组件就是一个纯函数，接受一个props，返回一段jsx。react的渲染，其实就是首先用createRoot方法渲染根组件，然后按照组件的层级，一层一层地向下调用函数罢了。我始终忘不掉我之前用Remax写小程序的时候，看到最开始的app.js时的震撼。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./app.css&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = props=&gt;props.<span class="hljs-property">children</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><p>一开始我不明白这是啥意思啊，后来我知道，原来这就是根组件啊。我没在它里面添加逻辑，它就只需要把它的子组件返回出去，然后让它的子组件去渲染就好了。因为箭头函数的语法，整个组件的代码简洁的令人震惊。看明白了之后我感觉我更加理解react组件是什么东西了。如果只是用函数组件（不带hooks）的话，react就是函数式编程，它的渲染就是一个一个纯函数的调用。</p><p>当然了，一个react应用，没有副作用的话很难实现功能，因为发送请求等等都是副作用。所以副作用是几乎不可避免的，函数组件在hooks出现之前功能是不完备的。而函数式编程，也只是一个范式，一个规范，我们只能尽可能去遵守。后面有时间的话，再来说一说带hooks的函数组件，和函数式编程的关系吧。</p>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react的一些坑</title>
    <link href="/2022/08/14/react%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <url>/2022/08/14/react%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些刚写react踩过的坑吧，想到多少就写多少</p></blockquote><h2 id="从一个工作中的需求开始"><a href="#从一个工作中的需求开始" class="headerlink" title="从一个工作中的需求开始"></a>从一个工作中的需求开始</h2><p>有个需求是，点击按钮出来一个弹窗。本来弹窗有个关闭按钮，但是UED在视觉稿上面加了行字，“点击关闭按钮或弹窗外的其他地方，关闭弹窗”。我想了想，合理，避免有些奇怪的操作使得弹窗没关掉。实现的方法就是监听点击事件呗，然后判断点击的是哪，如果弹窗是打开的，并且点击的地方不在弹窗里，就把弹窗关掉。</p><p>具体代码我直接CSDN找了一个，好用的。通过createref来获取dom，对document使用addEventListener，监听点击的event.target，判断和弹窗dom的关系就可以了。本来是个挺简单的事，但是我用了之后发现，本来那个打开弹窗的按钮也不好用了。后来发现，因为那个按钮也是弹窗之外，所以弹窗打开就马上关闭了。一开始没想到事件捕获和冒泡，我想当然地以为，应该先触发document的点击事件，这个时候弹窗没出现，所以无事发生，然后再触发按钮的点击事件，打开弹窗。这和实际的结果并不相符。</p><p>我调试的时候发现，点击按钮后总是先打开弹窗，再触发document的点击事件，把弹窗关上。我当时想的解决办法是，把点击按钮的onClick外面包一层setTimeout，延迟0。将打开按钮的操作改成了异步事件，根据事件循环机制，异步会在同步代码执行完毕一轮之后，再去执行，这样就保证了打开弹窗的操作，一定在判断点击位置然后关闭弹窗之后。这样就能正常打开弹窗了。</p><h2 id="其他的解决方法"><a href="#其他的解决方法" class="headerlink" title="其他的解决方法"></a>其他的解决方法</h2><p>后来我下班之后，又继续研究这个问题，这时候才想明白，之前两个点击事件的执行顺序不对，是因为事件的捕获和冒泡机制。原来onClick和addEventListener默认都是冒泡，所以执行顺序就是先最低层级的dom元素，最后是document，就出问题了。然而addEventListener的第三个参数改成true，就变成捕获阶段了，这样就对了。然后我就想，写个简单的demo来验证一下。</p><h2 id="问题并不简单"><a href="#问题并不简单" class="headerlink" title="问题并不简单"></a>问题并不简单</h2><p>然后就出问题了，我用vite脚手架建了个基本的react demo，然后用函数式组件，直接在函数体内部（没有使用useEffect）完成了对document添加点击响应事件的操作，然后我发现，怎么每回一点击屏幕，都会触发两次点击事件。我寻思为啥会触发两次呢？我顿时就想到，有可能是添加了两个点击响应事件。如果像我这样直接在函数体内部，不使用useEffect把addEventListener添加到一个元素上，然后组件重新渲染，函数重新执行，就会对一个事件添加多个响应函数。当然本身或者子组件除外，因为重新渲染的时候点击事件也没了。</p><h2 id="函数式编程与副作用"><a href="#函数式编程与副作用" class="headerlink" title="函数式编程与副作用"></a>函数式编程与副作用</h2><p>但是我这显然是没有重新渲染的，一个连state都没有的根组件咋可能会去重新渲染。但是我通过chrome的api，getEventListeners查看，发现确实有2个eventListener。然后我试着加了个state，然后改变state，发现eventListener变成4个了，再改变state，变成6个了。这更加说明了每次组件重新渲染的时候，都渲染了两次。后来我去查了一些，发现是react18的严格模式下，开发环境的时候，组件的渲染会执行两遍，就是为了让开发者发现不应该出现的副作用。就比如我的这个添加eventListener应该写在useEffect内部，并且通过useEffect的return，清除副作用。这也给我提了个醒。</p><p>函数式组件写起来很方便，很简便。但是和类组件不同，类组件重新渲染只会重新执行render函数，而函数式组件是通篇执行。所以函数式组件更要注意副作用，一定要写在useEffect里面，并且做好清除工作，比如remove响应事件。然后我感觉，我对函数式编程和副作用的理解还有待加强。只能说这一个小需求，让我收获了很多。虽然后来mentor跟我说这种不影响整体功能的需求没必要花时间，但是我认为这次我的尝试，还是让我对react有了更深一步的了解。</p>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用react的一些心得与感想</title>
    <link href="/2022/08/08/%E4%BD%BF%E7%94%A8react%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <url>/2022/08/08/%E4%BD%BF%E7%94%A8react%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E4%B8%8E%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>刚忙完公司的新人训练营，9个人的团队2周完成一个小项目。我负责用remax开发一个微信小程序。remax就是蚂蚁的一个开源框架，让开发者能用react的语法去开发微信小程序。开发体验整体来讲非常不错，感觉也加深了我对react的理解。</p></blockquote><p>​之前我没有完整使用react开发一个项目的经验，这次是我第一次使用，不过我对于react的写法也算比较熟悉了，之前完成公司的需求的时候也学到了不少。不过公司的组件基本都是类组件，而我开发的项目都是用的函数组件。函数组件比类组件简洁太多，而且react hooks使用起来也非常爽。具体的细节以后有机会再写吧，本来是打算做完项目之后好好总结一下的，结果之前做项目太累了，周末好好放松了一下，就没啥时间去记录了。简单做个笔记吧。</p><ol><li><h2 id="react的数据绑定是单向的"><a href="#react的数据绑定是单向的" class="headerlink" title="react的数据绑定是单向的"></a>react的数据绑定是单向的</h2><p>只有model层影响view层（即页面会随着model层数据的变化，而重新渲染）。但是view层的数据变化，却不会自动改变model层的数据。这和vue是不同的。<br>举个例子就是，input框处理用户的输入，react需要监听onchange事件，然后获取用户的输入，将输入内容赋值给model层的变量，这个方向的数据流动是要自己去实现的。而vue只需要一个v-model的api，就可以将变量和用户的输入实现双向绑定，用户输入，变量自动改变，不需要自己去操作</p></li><li><h2 id="react的state："><a href="#react的state：" class="headerlink" title="react的state："></a>react的state：</h2><p>state就是状态，就是react会去监听的变量。当某个组件的state发生变化时，组件就会重新渲染（其他重新渲染的时机是，props变化，或者父组件重新渲染）。也就是说，一个变量是直接被定义，还是被当做state定义，区别就在于它是否需要被监听，用于重新渲染组件。如果它改变了，但是页面不需要重新渲染，那么他就不用被作为state定义。</p></li><li><h2 id="useState："><a href="#useState：" class="headerlink" title="useState："></a>useState：</h2><p>说到了state，原本是只有类组件有的。函数组件本来是无状态组件，但是为了让他能和类组件做到一样的事情，react后面加入了hooks，使得函数组件的功能和类组件一样完备。函数组件的state采用useState定义，返回一个数组，分别是变量和改变变量的方法。特别建议，当state的变量是数组或对象时，改变变量不要直接改变数组或对象元素，而是借助扩展操作符，重新创建一个数组或对象。</p></li><li><h2 id="useEffect："><a href="#useEffect：" class="headerlink" title="useEffect："></a>useEffect：</h2><p>这其实是我一开始特别难以理解的一个点。包括我之前是用vue的，面试前背响应式原理，vue3的什么effect看得我云里雾里的，然后react这个hooks的useEffect我看文档也不是很明白。但是后来实际使用就明白了，所谓的effect就是你要去干一件事。就比如，useEffect就是用来，当某个条件到来的时候，你要去做一件事。比如，查询的参数变了，你要去重新向后端查询结果。useEffect的第一个参数是一个函数，就是你要做的那件事。第二个参数是一个数组，里面放着你要监听的变量，如果没有这个参数，则每次组件重新渲染，都会执行这个effect。如果这个参数为空数组，则只在组件第一次挂载的时候执行一次effect。通常情况下，是参数包含的变量发生改变时，effect被执行。</p></li><li><h2 id="关于组件间状态共享："><a href="#关于组件间状态共享：" class="headerlink" title="关于组件间状态共享："></a>关于组件间状态共享：</h2><p>最基本的父子组件可以使用props，复杂一点的可以使用redux（后面有空再说吧，公司项目里有用到）。而还有一种方法是context，它可以跨越层级，使得状态不用通过props一层一层的传下去，而是相对于传入context的组件，它的所有子组件都能直接共享状态。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些部署相关的名词解释</title>
    <link href="/2022/07/24/%E4%B8%80%E4%BA%9B%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/07/24/%E4%B8%80%E4%BA%9B%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>毕业刚入职，看到公司的各种发布，部署平台，眼花缭乱，看文档的过程中也看到了很多不懂的名词，了解了之后做一下记录</p></blockquote><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li>serverless: 字面意思是“无服务器”，即开发者（开发公司）不用自己的机房服务器，采用云服务器厂商提供的云服务器</li><li>PaaS：platform as a service，平台即服务，指提供一个软件部署平台，用户使用平台部署软件时，无需关心部署的硬件和底层细节，只需关注业务逻辑</li><li>金丝雀发布：也叫灰度发布。意思是发布新版本时，通过对流量分流，先让一小部分用户能用到新版本（可理解为抢先体验），等到没有大问题之后再推广到全体用户。这和过去下矿时先用金丝雀来检验矿井下面是否有毒气体超标的行为相似，因此得名。</li><li>微服务：一个整体架构的的应用程序，可能包含了很多功能。举个简单例子，一个图书馆的借书系统，要管理借书卡（比如新增或修改一个账号，查询一个账号借的书），要管理图书（比如借书，还书，增加库存）。这么一个简单的系统，功能不复杂，采用整体架构没问题。但是当一个系统功能多起来，开发和维护的人员肯定也要多。如果这时还采用整体架构，当各个功能都有改动，要发新版本的时候，会很痛苦。微服务就是把系统按照功能拆分开来，使得拆分出的部分互相解耦，每个部分就是一个微服务，例如单独拆出来个微服务管理借书卡，单独拆出来个部分管理图书。这两部分可以通过RESTful API等方式进行通信，但是一个部分做出改动时，不会影响另一个部分的正常使用。这就是微服务</li><li>BFF层：Backend for Frontend，服务于前端的后端。由于微服务的拆分，或者多端（PC，移动等等）需要从后端返回的数据并不一致，使得前端在请求后端的接口时，通常要做聚合（把多个接口返回的数据组合起来）或裁减（对接口返回的数据做过滤，只用到一部分）。为了解决这个麻烦，BFF就相当于一个中间层，代替前端去请求后端的接口，并且对数据做聚合和裁剪等等，然后将直接可用的数据返回给前端，同时还能起到屏蔽后端修改的作用（当后端的接口做出什么改动时，BFF层做出修改，使得前端无需做出改动）</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>名词解释</tag>
      
      <tag>项目部署</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
