

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="qh_meng">
  <meta name="keywords" content="">
  
    <meta name="description" content="代码以React v19.1.0为例，https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;tree&#x2F;v19.1.0 ，并且经过简化，仅保留了关键的逻辑，以便于理解流程  自己实现的事件系统如果我们用原生的js，去给dom添加事件，应该用addEventListener，或者添加onclick之类的属性。但是这两种方法，都和我们React的写法不同。 React里，我们想给一个节点">
<meta property="og:type" content="article">
<meta property="og:title" content="通俗易懂的React原理（十二）：React的合成事件系统">
<meta property="og:url" content="https://miku03090831.github.io/2025/11/30/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9AReact%E7%9A%84%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="moe&#39;s blog">
<meta property="og:description" content="代码以React v19.1.0为例，https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;tree&#x2F;v19.1.0 ，并且经过简化，仅保留了关键的逻辑，以便于理解流程  自己实现的事件系统如果我们用原生的js，去给dom添加事件，应该用addEventListener，或者添加onclick之类的属性。但是这两种方法，都和我们React的写法不同。 React里，我们想给一个节点">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-30T08:59:57.000Z">
<meta property="article:modified_time" content="2025-12-01T18:19:16.057Z">
<meta property="article:author" content="qh_meng">
<meta property="article:tag" content="React">
<meta property="article:tag" content="合成事件">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>通俗易懂的React原理（十二）：React的合成事件系统 - moe&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"miku03090831.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/miku.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="通俗易懂的React原理（十二）：React的合成事件系统"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-30 16:59" pubdate>
          2025年11月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          44 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">通俗易懂的React原理（十二）：React的合成事件系统</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>代码以React v19.1.0为例，<a target="_blank" rel="noopener" href="https://github.com/facebook/react/tree/v19.1.0">https://github.com/facebook/react/tree/v19.1.0</a> ，并且经过简化，仅保留了关键的逻辑，以便于理解流程</p>
</blockquote>
<h1 id="自己实现的事件系统"><a href="#自己实现的事件系统" class="headerlink" title="自己实现的事件系统"></a>自己实现的事件系统</h1><p>如果我们用原生的js，去给dom添加事件，应该用<code>addEventListener</code>，或者添加<code>onclick</code>之类的属性。但是这两种方法，都和我们React的写法不同。</p>
<p>React里，我们想给一个节点添加点击的响应事件，应该用<code>onClick</code>属性。这不是DOM API的内容，而是借助React自己实现的事件系统完成的。并且，React自己实现的事件系统，还会模拟原生事件的捕获和冒泡流程。</p>
<p>React自己实现一套事件系统的原因很多。</p>
<p>首先，这套事件系统是基于事件委托的，它的好处在于不需要真的为每个dom注册和删除事件监听器。</p>
<p>其次，React可以更自由的控制事件的逻辑，比如可以给不同的事件设置不同的优先级（lane），这样事件触发的更新就可以根据优先级不同而区别处理。</p>
<p>在React17的时候，控制事件批量更新也是依赖这个自己实现的事件系统。只不过目前已经不需要在事件系统里实现批量更新了，React的调度机制会在一次渲染中自动合并所有同一优先级的更新，一起完成。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>React自己实现的事件系统，是基于事件委托实现的。事件委托的思想在于，将事件的监听器加在高层级的dom上面，然后监听到事件后，通过event.target确定事件具体发生在哪个子元素上。</p>
<p>React在18版本开始，将事件委托到了createRoot方法传入的dom节点上，也就是上一篇中我们提到的container。为了方便，我们后面有时候会称它为根dom。</p>
<p>我们还记得上一篇的<code>createRoot</code>方法中，调用了<code>listenToAllSupportedEvents</code>方法。这个方法，就是负责添加事件监听器的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToAllSupportedEvents</span>(<span class="hljs-params"><span class="hljs-attr">rootContainerElement</span>: <span class="hljs-title class_">EventTarget</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>)[listeningMarker]) &#123;<br>    (<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>)[listeningMarker] = <span class="hljs-literal">true</span>;<br>    allNativeEvents.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">domEventName</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// We handle selectionchange separately because it</span><br>      <span class="hljs-comment">// doesn&#x27;t bubble and needs to be on the document.</span><br>      <span class="hljs-keyword">if</span> (domEventName !== <span class="hljs-string">&#x27;selectionchange&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!nonDelegatedEvents.<span class="hljs-title function_">has</span>(domEventName)) &#123;<br>          <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">false</span>, rootContainerElement);<br>        &#125;<br>        <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">true</span>, rootContainerElement);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> ownerDocument =<br>      (<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>).<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span><br>        ? rootContainerElement<br>        : (<span class="hljs-attr">rootContainerElement</span>: <span class="hljs-built_in">any</span>).<span class="hljs-property">ownerDocument</span>;<br>    <span class="hljs-keyword">if</span> (ownerDocument !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// The selectionchange event also needs deduplication</span><br>      <span class="hljs-comment">// but it is attached to the document.</span><br>      <span class="hljs-keyword">if</span> (!(<span class="hljs-attr">ownerDocument</span>: <span class="hljs-built_in">any</span>)[listeningMarker]) &#123;<br>        (<span class="hljs-attr">ownerDocument</span>: <span class="hljs-built_in">any</span>)[listeningMarker] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">listenToNativeEvent</span>(<span class="hljs-string">&#x27;selectionchange&#x27;</span>, <span class="hljs-literal">false</span>, ownerDocument);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>rootContainerElement</code>入参，就是<code>createRoot</code>的入参。</p>
<p>我们可以看到，这段代码遍历全部的event，逐个为他们添加监听器，但也对部分事件做了特殊处理。</p>
<p>首先，<code>selectionchange</code>事件被单独添加到了<code>document</code>上。</p>
<p>其次，有一部分事件是<code>nonDelegatedEvents</code>，它们包含了<code>scroll</code>等等事件。它们只会执行一遍<code>listenToNativeEvent</code>，且第二个参数是，表示这些事件只添加了捕获阶段的监听器。而其他大部分事件，则会调用两遍<code>listenToNativeEvent</code>，表示在冒泡和捕获阶段，都添加了事件监听器。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToNativeEvent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">isCapturePhaseListener</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> eventSystemFlags = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (isCapturePhaseListener) &#123;<br>    eventSystemFlags |= <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>;<br>  &#125;<br>  <span class="hljs-title function_">addTrappedEventListener</span>(<br>    target,<br>    domEventName,<br>    eventSystemFlags,<br>    isCapturePhaseListener,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据是否为冒泡阶段的监听器，决定是否给<code>eventSystemFlags</code>的IS_CAPTURE_PHASE位置为1，然后传入<code>addTrappedEventListener</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTrappedEventListener</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">isCapturePhaseListener</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">isDeferredListenerForLegacyFBSupport</span>?: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> listener = <span class="hljs-title function_">createEventListenerWrapperWithPriority</span>(<br>    targetContainer,<br>    domEventName,<br>    eventSystemFlags,<br>  );<br>  <span class="hljs-comment">// If passive option is not supported, then the event will be</span><br>  <span class="hljs-comment">// active and not passive.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">isPassiveListener</span>: <span class="hljs-built_in">void</span> | <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-keyword">if</span> (passiveBrowserEventsSupported) &#123;<br>    <span class="hljs-comment">// Browsers introduced an intervention, making these events</span><br>    <span class="hljs-comment">// passive by default on document. React doesn&#x27;t bind them</span><br>    <span class="hljs-comment">// to document anymore, but changing this now would undo</span><br>    <span class="hljs-comment">// the performance wins from the change. So we emulate</span><br>    <span class="hljs-comment">// the existing behavior manually on the roots now.</span><br>    <span class="hljs-comment">// https://github.com/facebook/react/issues/19651</span><br>    <span class="hljs-keyword">if</span> (<br>      domEventName === <span class="hljs-string">&#x27;touchstart&#x27;</span> ||<br>      domEventName === <span class="hljs-string">&#x27;touchmove&#x27;</span> ||<br>      domEventName === <span class="hljs-string">&#x27;wheel&#x27;</span><br>    ) &#123;<br>      isPassiveListener = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> unsubscribeListener;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> There are too many combinations here. Consolidate them.</span><br>  <span class="hljs-keyword">if</span> (isCapturePhaseListener) &#123;<br>    <span class="hljs-keyword">if</span> (isPassiveListener !== <span class="hljs-literal">undefined</span>) &#123;<br>      unsubscribeListener = <span class="hljs-title function_">addEventCaptureListenerWithPassiveFlag</span>(<br>        targetContainer,<br>        domEventName,<br>        listener,<br>        isPassiveListener,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      unsubscribeListener = <span class="hljs-title function_">addEventCaptureListener</span>(<br>        targetContainer,<br>        domEventName,<br>        listener,<br>      );<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPassiveListener !== <span class="hljs-literal">undefined</span>) &#123;<br>      unsubscribeListener = <span class="hljs-title function_">addEventBubbleListenerWithPassiveFlag</span>(<br>        targetContainer,<br>        domEventName,<br>        listener,<br>        isPassiveListener,<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      unsubscribeListener = <span class="hljs-title function_">addEventBubbleListener</span>(<br>        targetContainer,<br>        domEventName,<br>        listener,<br>      );<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，通过<code>createEventListenerWrapperWithPriority</code>方法，得到一个事件的回调方法。</p>
<p>然后，有个passive事件的问题，React这里简单的处理了一下。<code>addEventListener</code>的第三个入参支持两种类型，通常我们会传一个布尔值表示是否为捕获阶段监听，其实也可以传入一个options对象。对象可接受的字段中，有个<code>passive</code>字段，当为true的时候表示回调方法里永远不会<code>preventDefault</code>。这个优化会大幅改善部分事件的性能。根据规范，这个值默认是false，可大部分浏览器将文档级节点Window节点、Document节点、Document.body节点上面的部分事件设为了true。</p>
<p>而React由于做了事件委托，不会将这些事件绑定到上述节点上。为了也能改善这些事件的性能，React在浏览器支持的情况下，给这些事件设置监听器的时候，也会传入<code>&#123;passive: true&#125;</code>。</p>
<p>在<code>addTrappedEventListener</code>的最后，根据是否为捕获阶段，是否需要设置<code>passive</code>，React分了四种情况去执行<code>addEventListener</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventBubbleListener</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">listener</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> listener;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventCaptureListener</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">listener</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, <span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">return</span> listener;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventCaptureListenerWithPassiveFlag</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">listener</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">passive</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, &#123;<br>    <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>,<br>    passive,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> listener;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventBubbleListenerWithPassiveFlag</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">listener</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">passive</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, &#123;<br>    passive,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> listener;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，React就在createRoot传入的dom节点上，注册了监听事件。而具体的事件回调方法，我们在下面详细展开。</p>
<h2 id="事件回调方法"><a href="#事件回调方法" class="headerlink" title="事件回调方法"></a>事件回调方法</h2><p>我们接下来要看具体的回调方法的逻辑了，看看前面被添加上去的listener是什么。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createEventListenerWrapperWithPriority</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Function</span> &#123;<br>  <span class="hljs-keyword">const</span> eventPriority = <span class="hljs-title function_">getEventPriority</span>(domEventName);<br>  <span class="hljs-keyword">let</span> listenerWrapper;<br>  <span class="hljs-keyword">switch</span> (eventPriority) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">DiscreteEventPriority</span>:<br>      listenerWrapper = dispatchDiscreteEvent;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContinuousEventPriority</span>:<br>      listenerWrapper = dispatchContinuousEvent;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultEventPriority</span>:<br>    <span class="hljs-attr">default</span>:<br>      listenerWrapper = dispatchEvent;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> listenerWrapper.<span class="hljs-title function_">bind</span>(<br>    <span class="hljs-literal">null</span>,<br>    domEventName,<br>    eventSystemFlags,<br>    targetContainer,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，根据具体是什么事件，得到事件的优先级。<code>getEventPriority</code>方法可以认为是穷举了dom上的事件，每个事件都被分配了一个的优先级。例如是离散事件优先级，还是持续性事件优先级，或者是默认优先级等等。</p>
<p>这里的优先级会设置在<code>ReactDOMSharedInternals.p</code>上面，后面React要更新状态的时候，会读取这个优先级，决定要产生一次什么lane的更新。其实上一篇，我们将React要开始首次mount，执行<code>updateContainer</code>的时候，就是从&#96;&#96;ReactDOMSharedInternals.p&#96;读取的优先级。</p>
<p>根据不同的优先级，listenerWrapper会被赋值为不同的方法，他们之间的区别就是要设置的优先级不同，本质上都是<code>dispatchEvent</code>方法。</p>
<p>最后，return一个方法，会给<code>dispatchEvent</code>方法绑定上事件名称，事件的flag，和container（依旧是createRoot的入参dom）这些参数。</p>
<p>也就是说，无论React里面触发了什么事件（除了少部分没有委托的），发生在哪个React Fiber对应的dom上，都会执行绑定在根dom上面的<code>dispatchEvent</code>方法。</p>
<h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p>假设我们有一个div，上面绑定了一个onClick事件。当我们点击这个div的时候，我们相当于是执行到了绑定在根dom上，onClick冒泡阶段的那个<code>dispatchEvent</code>。那么接下来，这个回调是怎么对应我们写的onClick方法，以及怎么处理模拟原生事件的捕获和冒泡问题呢？</p>
<p>一切问题都在<code>dispatchEvent</code>里了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> blockedOn = <span class="hljs-title function_">findInstanceBlockingEvent</span>(nativeEvent);<br>  <span class="hljs-keyword">if</span> (blockedOn === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-title function_">dispatchEventForPluginEventSystem</span>(<br>      domEventName,<br>      eventSystemFlags,<br>      nativeEvent,<br>      return_targetInst,<br>      targetContainer,<br>    );<br>    <span class="hljs-title function_">clearIfContinuousEvent</span>(domEventName, nativeEvent);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，<code>findInstanceBlockingEvent</code>返回了一个<code>blockedOn</code>，它表示是否有被阻塞的事件。阻塞的原因可能是，页面由服务端渲染，当前正处在客户端水合的过程中，无法响应点击事件。</p>
<p>如果被阻塞了，那么React会尝试将事件入队，等阻塞解除后重新处理。不过我们这里不考虑那么复杂的情况，只看没有被阻塞的情况就好了。</p>
<p>只不过，即便没有阻塞，<code>blockedOn</code>是null，我们也需要看看<code>findInstanceBlockingEvent</code>里面的代码。因为下面用到的模块变量<code>return_targetInst</code>，就是在<code>findInstanceBlockingEvent</code>方法里面被更新的。</p>
<h3 id="寻找事件发生的Fiber"><a href="#寻找事件发生的Fiber" class="headerlink" title="寻找事件发生的Fiber"></a>寻找事件发生的Fiber</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">findInstanceBlockingEvent</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-literal">null</span> | <span class="hljs-title class_">Container</span> | <span class="hljs-title class_">SuspenseInstance</span> &#123;<br>  <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">findInstanceBlockingTarget</span>(nativeEventTarget);<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">findInstanceBlockingTarget</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">targetNode</span>: <span class="hljs-title class_">Node</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-literal">null</span> | <span class="hljs-title class_">Container</span> | <span class="hljs-title class_">SuspenseInstance</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Warn if _enabled is false.</span><br><br>  return_targetInst = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">let</span> targetInst = <span class="hljs-title function_">getClosestInstanceFromNode</span>(targetNode);<br><br>  <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> nearestMounted = <span class="hljs-title function_">getNearestMountedFiber</span>(targetInst);<br>    <span class="hljs-keyword">if</span> (nearestMounted === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// This tree has been unmounted already. Dispatch without a target.</span><br>      targetInst = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> tag = nearestMounted.<span class="hljs-property">tag</span>;<br>      <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">SuspenseComponent</span>) &#123;<br>        <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">getSuspenseInstanceFromFiber</span>(nearestMounted);<br>        <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>        <span class="hljs-comment">// This shouldn&#x27;t happen</span><br>        targetInst = <span class="hljs-literal">null</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostRoot</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">root</span>: <span class="hljs-title class_">FiberRoot</span> = nearestMounted.<span class="hljs-property">stateNode</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRootDehydrated</span>(root)) &#123;<br>          <span class="hljs-comment">// If this happens during a replay something went wrong and it might block</span><br>          <span class="hljs-comment">// the whole system.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContainerFromFiber</span>(nearestMounted);<br>        &#125;<br>        targetInst = <span class="hljs-literal">null</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nearestMounted !== targetInst) &#123;<br>        <span class="hljs-comment">// If we get an event (ex: img onload) before committing that</span><br>        <span class="hljs-comment">// component&#x27;s mount, ignore it for now (that is, treat it as if it was an</span><br>        <span class="hljs-comment">// event on a non-React tree). We might also consider queueing events and</span><br>        <span class="hljs-comment">// dispatching them after the mount.</span><br>        targetInst = <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  return_targetInst = targetInst;<br>  <span class="hljs-comment">// We&#x27;re not blocked on anything.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，这里面还是嵌套调用了很多方法的。</p>
<p><code>findInstanceBlockingEvent</code>方法中，首先是通过<code>getEventTarget</code>，获取这个原生event所发生的dom，其实就是<code>event.target</code>啦，只不过考虑到兼容性和边界场景，封装成了一个函数。</p>
<p>接下来，找到了事件发生的dom，会调用<code>findInstanceBlockingTarget</code>方法，将dom传进去，去判断是否有发生阻塞，不能响应事件的Fiber。</p>
<p><code>findInstanceBlockingTarget</code>方法中，会调用<code>getClosestInstanceFromNode</code>方法，根据事件发生的dom节点，找到离这个dom最接近的Fiber节点。通常就是这个dom本身对应的Fiber。别忘了，dom节点最初也是从Fiber节点生成的，在那个时候为了方便反查，就已经在dom节点的<code>internalInstanceKey</code>字段上(实际<code>internalInstanceKey</code>是一个变量名称)，保存了它的Fiber对象。</p>
<p>所以，<code>targetNode[internalInstanceKey]</code>就是事件所发生在的Fiber节点。</p>
<p>不考虑后面跟水合、suspense相关的代码的话，return_targetInst也就是事件发生的Fiber了。</p>
<p>此时我们再回到上面<code>dispatchEvent</code>的代码里，调用<code>dispatchEventForPluginEventSystem</code>这段，看调用时候的传参就非常清楚了，分别是事件名称、事件的flag（比如是否为冒泡）、事件对象本身、事件发生的Fiber，以及根dom。</p>
<h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p>接下来，看看<code>dispatchEventForPluginEventSystem</code>里面的逻辑</p>
<p><code>dispatchEventForPluginEventSystem</code>里面，有一段处理的逻辑，我没太看懂为什么。是判断事件发生的Fiber，是不是根dom对应的树上的Fiber。我还不太理解什么场景下会不在同一棵树上，所以不清楚这段代码的必要性，下面的代码也就略去这一段吧。不过，不耽误我们继续看绝大多数场景下的流程。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventForPluginEventSystem</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetInst</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> ancestorInst = targetInst;<br><br>  <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-function">() =&gt;</span><br>    <span class="hljs-title function_">dispatchEventsForPlugins</span>(<br>      domEventName,<br>      eventSystemFlags,<br>      nativeEvent,<br>      ancestorInst,<br>      targetContainer,<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而<code>batchedUpdates</code>方法，在如今的React版本里，已经只是个空壳了，只是会执行传入的方法而已，不会包含批量更新的逻辑。</p>
<p>所以，接下来就是会执行<code>dispatchEventsForPlugins</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventsForPlugins</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetInst</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dispatchQueue</span>: <span class="hljs-title class_">DispatchQueue</span> = [];<br>  <span class="hljs-title function_">extractEvents</span>(<br>    dispatchQueue,<br>    domEventName,<br>    targetInst,<br>    nativeEvent,<br>    nativeEventTarget,<br>    eventSystemFlags,<br>    targetContainer,<br>  );<br>  <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>dispatchEventsForPlugins</code>方法的逻辑可以氛围两部分，先是调用<code>extractEvents</code>，收集全部需要执行的回调。然后，调用<code>processDispatchQueue</code>方法，把所有回调都执行一遍。</p>
<p>其中，<code>extractEvents</code>方法包含了多种对事件处理的插件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">dispatchQueue</span>: <span class="hljs-title class_">DispatchQueue</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetInst</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEventTarget</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> we should remove the concept of a &quot;SimpleEventPlugin&quot;.</span><br>  <span class="hljs-comment">// This is the basic functionality of the event system. All</span><br>  <span class="hljs-comment">// the other plugins are essentially polyfills. So the plugin</span><br>  <span class="hljs-comment">// should probably be inlined somewhere and have its logic</span><br>  <span class="hljs-comment">// be core the to event system. This would potentially allow</span><br>  <span class="hljs-comment">// us to ship builds of React without the polyfilled plugins below.</span><br>  <span class="hljs-title class_">SimpleEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>    dispatchQueue,<br>    domEventName,<br>    targetInst,<br>    nativeEvent,<br>    nativeEventTarget,<br>    eventSystemFlags,<br>    targetContainer,<br>  );<br>  <span class="hljs-keyword">const</span> shouldProcessPolyfillPlugins =<br>    (eventSystemFlags &amp; <span class="hljs-variable constant_">SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS</span>) === <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// We don&#x27;t process these events unless we are in the</span><br>  <span class="hljs-comment">// event&#x27;s native &quot;bubble&quot; phase, which means that we&#x27;re</span><br>  <span class="hljs-comment">// not in the capture phase. That&#x27;s because we emulate</span><br>  <span class="hljs-comment">// the capture phase here still. This is a trade-off,</span><br>  <span class="hljs-comment">// because in an ideal world we would not emulate and use</span><br>  <span class="hljs-comment">// the phases properly, like we do with the SimpleEvent</span><br>  <span class="hljs-comment">// plugin. However, the plugins below either expect</span><br>  <span class="hljs-comment">// emulation (EnterLeave) or use state localized to that</span><br>  <span class="hljs-comment">// plugin (BeforeInput, Change, Select). The state in</span><br>  <span class="hljs-comment">// these modules complicates things, as you&#x27;ll essentially</span><br>  <span class="hljs-comment">// get the case where the capture phase event might change</span><br>  <span class="hljs-comment">// state, only for the following bubble event to come in</span><br>  <span class="hljs-comment">// later and not trigger anything as the state now</span><br>  <span class="hljs-comment">// invalidates the heuristics of the event plugin. We</span><br>  <span class="hljs-comment">// could alter all these plugins to work in such ways, but</span><br>  <span class="hljs-comment">// that might cause other unknown side-effects that we</span><br>  <span class="hljs-comment">// can&#x27;t foresee right now.</span><br>  <span class="hljs-keyword">if</span> (shouldProcessPolyfillPlugins) &#123;<br>    <span class="hljs-title class_">EnterLeaveEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>    <span class="hljs-title class_">ChangeEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>    <span class="hljs-title class_">SelectEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>    <span class="hljs-title class_">BeforeInputEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>    <span class="hljs-title class_">FormActionEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>  &#125;<br>  <span class="hljs-keyword">if</span> (enableScrollEndPolyfill) &#123;<br>    <span class="hljs-title class_">ScrollEndEventPlugin</span>.<span class="hljs-title function_">extractEvents</span>(<br>      dispatchQueue,<br>      domEventName,<br>      targetInst,<br>      nativeEvent,<br>      nativeEventTarget,<br>      eventSystemFlags,<br>      targetContainer,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，对于所有事件，都用<code>SimpleEventPlugin</code>处理一下。</p>
<p><code>SimpleEventPlugin.extractEvents</code>的中，针对各种事件会赋予不同的合成事件。由于switch case枚举的事件太多，所以我们这里只列出click事件</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">dispatchQueue</span>: <span class="hljs-title class_">DispatchQueue</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetInst</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEventTarget</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> reactName = topLevelEventsToReactNames.<span class="hljs-title function_">get</span>(domEventName);<br>  <span class="hljs-keyword">if</span> (reactName === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticEvent</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">reactEventType</span>: <span class="hljs-built_in">string</span> = domEventName;<br>  <span class="hljs-keyword">switch</span> (domEventName) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;click&#x27;</span>:<br>      <span class="hljs-comment">// Firefox creates a click event on right mouse clicks. This removes the</span><br>      <span class="hljs-comment">// unwanted click events.</span><br>      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Fixed in https://phabricator.services.mozilla.com/D26793. Can</span><br>      <span class="hljs-comment">// probably remove.</span><br>      <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">button</span> === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticMouseEvent</span>;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Some events don&#x27;t bubble in the browser.</span><br>  <span class="hljs-comment">// In the past, React has always bubbled them, but this can be surprising.</span><br>  <span class="hljs-comment">// We&#x27;re going to try aligning closer to the browser behavior by not bubbling</span><br>  <span class="hljs-comment">// them in React either. We&#x27;ll start by not bubbling onScroll, and then expand.</span><br>  <span class="hljs-keyword">const</span> accumulateTargetOnly =<br>    !inCapturePhase &amp;&amp;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> ideally, we&#x27;d eventually add all events from</span><br>    <span class="hljs-comment">// nonDelegatedEvents list in DOMPluginEventSystem.</span><br>    <span class="hljs-comment">// Then we can remove this special list.</span><br>    <span class="hljs-comment">// This is a breaking change that can wait until React 18.</span><br>    (domEventName === <span class="hljs-string">&#x27;scroll&#x27;</span> || domEventName === <span class="hljs-string">&#x27;scrollend&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> listeners = <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<br>    targetInst,<br>    reactName,<br>    nativeEvent.<span class="hljs-property">type</span>,<br>    inCapturePhase,<br>    accumulateTargetOnly,<br>    nativeEvent,<br>  );<br>  <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// Intentionally create event lazily.</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">event</span>: <span class="hljs-title class_">ReactSyntheticEvent</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(<br>      reactName,<br>      reactEventType,<br>      <span class="hljs-literal">null</span>,<br>      nativeEvent,<br>      nativeEventTarget,<br>    );<br>    dispatchQueue.<span class="hljs-title function_">push</span>(&#123;event, listeners&#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，对于事件名称做个转换，<code>domEventName</code>是原生的事件名称，<code>reactName</code>是对应的属于React的事件名称。对于大部分事件，React都是采用on前缀+首字母大写的命名法，来将原本的事件名和React定义的事件名对应起来。</p>
<p>对于点击事件，我们先把事件对象设为鼠标合成事件，<code>SyntheticMouseEvent</code>。</p>
<p>然后，模拟浏览器的捕获和冒泡流程，收集目标Fiber到根元素的所有事件监听器。</p>
<p>其中，<code>SyntheticMouseEvent</code>是经由这段代码得到的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SyntheticMouseEvent</span>: $FlowFixMe = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">MouseEventInterface</span>);<br></code></pre></td></tr></table></figure>

<p><code>MouseEventInterface</code>包含了一些事件的属性，比如<code>screenX</code>，<code>movementX</code>等等。而实际上，其他的合成事件类型，也只是将不同的对象传给<code>createSyntheticEvent</code>方法，所以<code>createSyntheticEvent</code>是一个通用的，可以根据入参来生成不同合成事件对象的方法。</p>
<p>而<code>createSyntheticEvent</code>的逻辑如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><br><span class="hljs-comment">// This is intentionally a factory so that we have different returned constructors.</span><br><span class="hljs-comment">// If we had a single constructor, it would be megamorphic and engines would deopt.</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-params"><span class="hljs-title class_">Interface</span>: <span class="hljs-title class_">EventInterfaceType</span></span>) &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Synthetic events are dispatched by event plugins, typically in response to a</span><br><span class="hljs-comment">   * top-level event delegation handler.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * These systems should generally use pooling to reduce the frequency of garbage</span><br><span class="hljs-comment">   * collection. The system should check `isPersistent` to determine whether the</span><br><span class="hljs-comment">   * event should be released into the pool after being dispatched. Users that</span><br><span class="hljs-comment">   * need a persisted event should invoke `persist`.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by</span><br><span class="hljs-comment">   * normalizing browser quirks. Subclasses do not necessarily have to implement a</span><br><span class="hljs-comment">   * DOM interface; custom application-specific events can also subclass this.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// $FlowFixMe[missing-this-annot]</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">SyntheticBaseEvent</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-attr">reactName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">reactEventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">targetInst</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    <span class="hljs-attr">nativeEvent</span>: &#123;[propName: <span class="hljs-built_in">string</span>]: mixed, ...&#125;,</span><br><span class="hljs-params">    <span class="hljs-attr">nativeEventTarget</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_reactName</span> = reactName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_targetInst</span> = targetInst;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = reactEventType;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span> = nativeEvent;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">target</span> = nativeEventTarget;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTarget</span> = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> <span class="hljs-title class_">Interface</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Interface</span>.<span class="hljs-title function_">hasOwnProperty</span>(propName)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">const</span> normalize = <span class="hljs-title class_">Interface</span>[propName];<br>      <span class="hljs-keyword">if</span> (normalize) &#123;<br>        <span class="hljs-variable language_">this</span>[propName] = <span class="hljs-title function_">normalize</span>(nativeEvent);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>[propName] = nativeEvent[propName];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> defaultPrevented =<br>      nativeEvent.<span class="hljs-property">defaultPrevented</span> != <span class="hljs-literal">null</span><br>        ? nativeEvent.<span class="hljs-property">defaultPrevented</span><br>        : nativeEvent.<span class="hljs-property">returnValue</span> === <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (defaultPrevented) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsTrue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsFalse;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isPropagationStopped</span> = functionThatReturnsFalse;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// $FlowFixMe[prop-missing] found when upgrading Flow</span><br>  <span class="hljs-title function_">assign</span>(<span class="hljs-title class_">SyntheticBaseEvent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>    <span class="hljs-comment">// $FlowFixMe[missing-this-annot]</span><br>    <span class="hljs-attr">preventDefault</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultPrevented</span> = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">const</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span>;<br>      <span class="hljs-keyword">if</span> (!event) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;<br>        event.<span class="hljs-title function_">preventDefault</span>();<br>        <span class="hljs-comment">// $FlowFixMe[illegal-typeof] - flow is not aware of `unknown` in IE</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">returnValue</span> !== <span class="hljs-string">&#x27;unknown&#x27;</span>) &#123;<br>        event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsTrue;<br>    &#125;,<br><br>    <span class="hljs-comment">// $FlowFixMe[missing-this-annot]</span><br>    <span class="hljs-attr">stopPropagation</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span>;<br>      <span class="hljs-keyword">if</span> (!event) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">stopPropagation</span>) &#123;<br>        event.<span class="hljs-title function_">stopPropagation</span>();<br>        <span class="hljs-comment">// $FlowFixMe[illegal-typeof] - flow is not aware of `unknown` in IE</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">cancelBubble</span> !== <span class="hljs-string">&#x27;unknown&#x27;</span>) &#123;<br>        <span class="hljs-comment">// The ChangeEventPlugin registers a &quot;propertychange&quot; event for</span><br>        <span class="hljs-comment">// IE. This event does not support bubbling or cancelling, and</span><br>        <span class="hljs-comment">// any references to cancelBubble throw &quot;Member not found&quot;.  A</span><br>        <span class="hljs-comment">// typeof check of &quot;unknown&quot; circumvents this issue (and is also</span><br>        <span class="hljs-comment">// IE specific).</span><br>        event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isPropagationStopped</span> = functionThatReturnsTrue;<br>    &#125;,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * We release all dispatched `SyntheticEvent`s after each event loop, adding</span><br><span class="hljs-comment">     * them back into the pool. This allows a way to hold onto a reference that</span><br><span class="hljs-comment">     * won&#x27;t be added back into the pool.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-attr">persist</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// Modern event system doesn&#x27;t use pooling.</span><br>    &#125;,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks if this event should be released back into the pool.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125; True if this should not be released, false otherwise.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-attr">isPersistent</span>: functionThatReturnsTrue,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyntheticBaseEvent</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>乍一看很长，其实核心就是定义了一个SyntheticBaseEvent的构造函数，然后往这个函数的prototype上面定义了<code>preventDefault</code>和<code>stopPropagation</code>等方法，最后将<code>SyntheticBaseEvent</code>构造函数return回去。构造函数里面记录了一些事件的信息，比如事件名称，事件发生的Fiber，原生事件对象等等。</p>
<p>接下来一段代码比较取巧，是给合成事件对象添加特定属性和方法的步骤。前面我们提到了，为了得到鼠标合成事件，我们会传入<code>MouseEventInterface</code>对象。它上面有很多属性，它们的初始值是0。也有一些属性是需要从原生事件得到，经过处理的（比如需要针对不同浏览器做polyfill），这些属性在<code>MouseEventInterface</code>上会被定义成一个函数。而属性的初始值都被设成了0，所以<code>Interface[propName]</code>如果有值，就一定是一个函数，传入原生的事件对象，React就能计算出经过处理后自己需要的值。</p>
<p>随后<code>defaultPrevented</code>属性表示当前原生事件是否会阻止默认行为，而<code>returnValue</code>是一种过时的等效属性。根据原生事件是否阻止默认行为，而给合成事件的<code>isDefaultPrevented</code>赋值成true或false。</p>
<p>然后，默认是不阻止冒泡的。</p>
<p>以上就是构造函数内部的逻辑。</p>
<p>接下来的原型方法也得比较简单了，<code>preventDefault</code>和<code>stopPropagation</code>分别就是设置对象里面对应的标志位，然后执行原生事件上面的同名方法就可以了。</p>
<p>之所以同时设置自己的标志位，又要执行原生事件的对应方法，是因为React的合成事件只能管好自己，但是并不能阻止原生事件的行为，比如它该冒泡还是冒泡，就有可能被React管控外的事件监听器所监听到。当你在div的<code>onClick</code>方法里写下<code>e.stopPropagation</code>的时候，你显然是希望所有的上层的监听器都不会接收到事件，不管是React加的监听器，还是其他方式添加的监听器。不过<code>isDefaultPrevented</code>的设置就比较微妙了，好像没看到其他地方读这个值，哈哈。</p>
<h3 id="收集监听器"><a href="#收集监听器" class="headerlink" title="收集监听器"></a>收集监听器</h3><p>接下来，要调用<code>accumulateSinglePhaseListeners</code>方法，收集所有的监听器了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">targetFiber</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">reactName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEventType</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">inCapturePhase</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">accumulateTargetOnly</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">DispatchListener</span>&gt; &#123;<br>  <span class="hljs-keyword">const</span> captureName = reactName !== <span class="hljs-literal">null</span> ? reactName + <span class="hljs-string">&#x27;Capture&#x27;</span> : <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">const</span> reactEventName = inCapturePhase ? captureName : reactName;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">listeners</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">DispatchListener</span>&gt; = [];<br><br>  <span class="hljs-keyword">let</span> instance = targetFiber;<br>  <span class="hljs-keyword">let</span> lastHostComponent = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// Accumulate all instances and listeners via the target -&gt; root path.</span><br>  <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;stateNode, tag&#125; = instance;<br>    <span class="hljs-comment">// Handle listeners that are on HostComponents (i.e. &lt;div&gt;)</span><br>    <span class="hljs-keyword">if</span> (<br>      (tag === <span class="hljs-title class_">HostComponent</span> ||<br>        tag === <span class="hljs-title class_">HostHoistable</span> ||<br>        tag === <span class="hljs-title class_">HostSingleton</span>) &amp;&amp;<br>      stateNode !== <span class="hljs-literal">null</span><br>    ) &#123;<br>      lastHostComponent = stateNode;<br><br>      <span class="hljs-comment">// Standard React on* listeners, i.e. onClick or onClickCapture</span><br>      <span class="hljs-keyword">if</span> (reactEventName !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">const</span> listener = <span class="hljs-title function_">getListener</span>(instance, reactEventName);<br>        <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>) &#123;<br>          listeners.<span class="hljs-title function_">push</span>(<br>            <span class="hljs-title function_">createDispatchListener</span>(instance, listener, lastHostComponent),<br>          );<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// If we are only accumulating events for the target, then we don&#x27;t</span><br>    <span class="hljs-comment">// continue to propagate through the React fiber tree to find other</span><br>    <span class="hljs-comment">// listeners.</span><br>    <span class="hljs-keyword">if</span> (accumulateTargetOnly) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    instance = instance.<span class="hljs-property">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> listeners;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，根据当前事件触发的是否为捕获阶段的监听器，来确定最终的事件名到底是<code>onClick</code>，还是<code>onClickCapture</code>。</p>
<p>然后，从事件发生的Fiber，沿着Fiber树，不断向上，收集经过的每一个dom类型的Fiber节点的对应名字的监听器。由于监听器是在Fiber的props里面，而每个Fiber都把props记在了Fiber对象的<code>internalPropsKey</code>字段上，所以这自然很容易做到。</p>
<p>特别的，如果被遍历到的节点是可交互的dom元素（如button， input），且disabled属性为true，那么它们的点击事件就不会被收集进去。</p>
<p>收集到一个listener后，会把<code>&#123;instance, listener, currentTarget: lastHostComponent&#125;</code>这样的对象放进listeners数组里，最后，会把这个listeners返回回去。</p>
<p>然后就剩下这段逻辑了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// Intentionally create event lazily.</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">event</span>: <span class="hljs-title class_">ReactSyntheticEvent</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(<br>    reactName,<br>    reactEventType,<br>    <span class="hljs-literal">null</span>,<br>    nativeEvent,<br>    nativeEventTarget,<br>  );<br>  dispatchQueue.<span class="hljs-title function_">push</span>(&#123;event, listeners&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果这个事件是有监听器在关注着他的，那么就用到前面的合成事件构造函数，创建合成事件。把合成事件，和它所有的监听器数组，打包放入<code>dispatchQueue</code>中。</p>
<p>那么接下来我们又要回到前面了，前面除了<code>SimpleEventPlugin.extractEvents</code>，还有很多<code>XXXEventPlugin.extractEvents</code>。这里的意思就是，<code>SimpleEventPlugin</code>把通用的主流程搭好，只不过并没有枚举出全部的事件。没被枚举到的各种事件，需要各种各样的特殊处理，就自己用专门的插件去处理。例如中文输入法对应的<code>onCompositionStart</code>，<code>onCompositionEnd</code>事件，就是在<code>BeforeInputEventPlugin</code>里面专门去特殊处理的。</p>
<p>待全部的插件都走完后，那么这次触发的原生事件一定都有了自己对应的合成事件对象，并且还收集了合成事件对象的全部监听器。</p>
<p>接下来，回看<code>dispatchEventsForPlugins</code>方法，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventsForPlugins</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">domEventName</span>: <span class="hljs-title class_">DOMEventName</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">nativeEvent</span>: <span class="hljs-title class_">AnyNativeEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetInst</span>: <span class="hljs-literal">null</span> | <span class="hljs-title class_">Fiber</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">targetContainer</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">dispatchQueue</span>: <span class="hljs-title class_">DispatchQueue</span> = [];<br>  <span class="hljs-title function_">extractEvents</span>(<br>    dispatchQueue,<br>    domEventName,<br>    targetInst,<br>    nativeEvent,<br>    nativeEventTarget,<br>    eventSystemFlags,<br>    targetContainer,<br>  );<br>  <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>dispatchQueue</code>已经收集完毕，该执行下面的<code>processDispatchQueue</code>了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueue</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">dispatchQueue</span>: <span class="hljs-title class_">DispatchQueue</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">eventSystemFlags</span>: <span class="hljs-title class_">EventSystemFlags</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchQueue.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> &#123;event, listeners&#125; = dispatchQueue[i];<br>    <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(event, listeners, inCapturePhase);<br>    <span class="hljs-comment">//  event system doesn&#x27;t use pooling.</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">event</span>: <span class="hljs-title class_">ReactSyntheticEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">dispatchListeners</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">DispatchListener</span>&gt;,</span><br><span class="hljs-params">  <span class="hljs-attr">inCapturePhase</span>: <span class="hljs-built_in">boolean</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> previousInstance;<br>  <span class="hljs-keyword">if</span> (inCapturePhase) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = dispatchListeners.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">const</span> &#123;instance, currentTarget, listener&#125; = dispatchListeners[i];<br>      <span class="hljs-keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>      previousInstance = instance;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchListeners.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> &#123;instance, currentTarget, listener&#125; = dispatchListeners[i];<br>      <span class="hljs-keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>      previousInstance = instance;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">executeDispatch</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">event</span>: <span class="hljs-title class_">ReactSyntheticEvent</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">listener</span>: <span class="hljs-title class_">Function</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">currentTarget</span>: <span class="hljs-title class_">EventTarget</span>,</span><br><span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  event.<span class="hljs-property">currentTarget</span> = currentTarget;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">listener</span>(event);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-title function_">reportGlobalError</span>(error);<br>  &#125;<br>  event.<span class="hljs-property">currentTarget</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，根据事件的监听器的eventSystemFlags，来确认是冒泡阶段的监听器，还是捕获阶段的监听器。这影响着最后遍历监听器的顺序。</p>
<p>而我们首先要遍历<code>dispatchQueue</code>。别忘了，我们是在插件处理完这个事件的时候，会把event和监听器数组推到<code>dispatchQueue</code>里面。而一个原生事件可能因为被多个插件处理等原因，对应多个合成事件。所以需要遍历<code>dispatchQueue</code>，把一个原生事件产生的所有合成事件都处理一遍。</p>
<p>处理每个合成事件的方法就是<code>processDispatchQueueItemsInOrder</code>。他根据是捕获还是冒泡，按照不同的顺序，遍历一个合成事件所有的监听器，逐个取出执行。但是当遍历到某个监听器，发现<code>isPropagationStopped</code>返回了true，那么就说明上一个listener里，执行了<code>e.stopPropagation</code>，所以当前这个listener就不会被执行了，遍历终止。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86/" class="category-chain-item">通俗易懂的React原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/React/" class="print-no-link">#React</a>
      
        <a href="/tags/%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6/" class="print-no-link">#合成事件</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>通俗易懂的React原理（十二）：React的合成事件系统</div>
      <div>https://miku03090831.github.io/2025/11/30/通俗易懂的React原理（十二）：React的合成事件系统/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>qh_meng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/11/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84React%E5%8E%9F%E7%90%86%EF%BC%88%E7%95%AA%E5%A4%96%E7%AF%87%E4%B9%8B%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8D%B8%E8%BD%BD/" title="通俗易懂的React原理（番外篇之二）：意料之外的组件卸载">
                        <span class="hidden-mobile">通俗易懂的React原理（番外篇之二）：意料之外的组件卸载</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
